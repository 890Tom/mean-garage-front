{"ast":null,"code":"(function () {\n  var a = window.AmCharts;\n  a.AmSlicedChart = a.Class({\n    inherits: a.AmChart,\n    construct: function (b) {\n      this.createEvents(\"rollOverSlice\", \"rollOutSlice\", \"clickSlice\", \"pullOutSlice\", \"pullInSlice\", \"rightClickSlice\");\n      a.AmSlicedChart.base.construct.call(this, b);\n      this.colors = \"#FF0F00 #FF6600 #FF9E01 #FCD202 #F8FF01 #B0DE09 #04D215 #0D8ECF #0D52D1 #2A0CD0 #8A0CCF #CD0D74 #754DEB #DDDDDD #999999 #333333 #000000 #57032A #CA9726 #990000 #4B0C25\".split(\" \");\n      this.alpha = 1;\n      this.groupPercent = 0;\n      this.groupedTitle = \"Other\";\n      this.groupedPulled = !1;\n      this.groupedAlpha = 1;\n      this.marginLeft = 0;\n      this.marginBottom = this.marginTop = 10;\n      this.marginRight = 0;\n      this.hoverAlpha = 1;\n      this.outlineColor = \"#FFFFFF\";\n      this.outlineAlpha = 0;\n      this.outlineThickness = 1;\n      this.startAlpha = 0;\n      this.startDuration = 1;\n      this.startEffect = \"bounce\";\n      this.sequencedAnimation = !0;\n      this.pullOutDuration = 1;\n      this.pullOutEffect = \"bounce\";\n      this.pullOnHover = this.pullOutOnlyOne = !1;\n      this.labelsEnabled = !0;\n      this.labelTickColor = \"#000000\";\n      this.labelTickAlpha = 0.2;\n      this.hideLabelsPercent = 0;\n      this.urlTarget = \"_self\";\n      this.autoMarginOffset = 10;\n      this.gradientRatio = [];\n      this.maxLabelWidth = 200;\n      this.accessibleLabel = \"[[title]]: [[percents]]% [[value]] [[description]]\";\n      a.applyTheme(this, b, \"AmSlicedChart\");\n    },\n    initChart: function () {\n      a.AmSlicedChart.base.initChart.call(this);\n      this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, this.setLegendData(this.chartData));\n      this.drawChart();\n    },\n    handleLegendEvent: function (f) {\n      var e = f.type,\n        j = f.dataItem,\n        i = this.legend;\n      if (j.wedge && j) {\n        var h = j.hidden;\n        f = f.event;\n        switch (e) {\n          case \"clickMarker\":\n            h || i.switchable || this.clickSlice(j, f);\n            break;\n          case \"clickLabel\":\n            h || this.clickSlice(j, f, !1);\n            break;\n          case \"rollOverItem\":\n            h || this.rollOverSlice(j, !1, f);\n            break;\n          case \"rollOutItem\":\n            h || this.rollOutSlice(j, f);\n            break;\n          case \"hideItem\":\n            this.hideSlice(j, f);\n            break;\n          case \"showItem\":\n            this.showSlice(j, f);\n        }\n      }\n    },\n    invalidateVisibility: function () {\n      this.recalculatePercents();\n      this.initChart();\n      var b = this.legend;\n      b && b.invalidateSize();\n    },\n    addEventListeners: function (e, d) {\n      var f = this;\n      e.mouseover(function (b) {\n        f.rollOverSlice(d, !0, b);\n      }).mouseout(function (b) {\n        f.rollOutSlice(d, b);\n      }).touchend(function (b) {\n        f.rollOverSlice(d, b);\n      }).mouseup(function (b) {\n        f.clickSlice(d, b);\n      }).contextmenu(function (b) {\n        f.handleRightClick(d, b);\n      });\n    },\n    formatString: function (f, e, h) {\n      f = a.formatValue(f, e, [\"value\"], this.nf, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n      var g = this.pf.precision;\n      isNaN(this.tempPrec) || (this.pf.precision = this.tempPrec);\n      f = a.formatValue(f, e, [\"percents\"], this.pf);\n      f = a.massReplace(f, {\n        \"[[title]]\": e.title,\n        \"[[description]]\": e.description\n      });\n      this.pf.precision = g;\n      -1 != f.indexOf(\"[[\") && (f = a.formatDataContextValue(f, e.dataContext));\n      f = h ? a.fixNewLines(f) : a.fixBrakes(f);\n      return f = a.cleanFromEmpty(f);\n    },\n    startSlices: function () {\n      var b;\n      for (b = 0; b < this.chartData.length; b++) {\n        0 < this.startDuration && this.sequencedAnimation ? this.setStartTO(b) : this.startSlice(this.chartData[b]);\n      }\n    },\n    setStartTO: function (d) {\n      var c = this;\n      d = setTimeout(function () {\n        c.startSequenced.call(c);\n      }, c.startDuration / c.chartData.length * 500 * d);\n      c.timeOuts.push(d);\n    },\n    pullSlices: function (f) {\n      var e = this.chartData,\n        h;\n      for (h = 0; h < e.length; h++) {\n        var g = e[h];\n        g.pulled && this.pullSlice(g, 1, f);\n      }\n    },\n    startSequenced: function () {\n      var d = this.chartData,\n        c;\n      for (c = 0; c < d.length; c++) {\n        if (!d[c].started) {\n          this.startSlice(this.chartData[c]);\n          break;\n        }\n      }\n    },\n    startSlice: function (f) {\n      f.started = !0;\n      var e = f.wedge,\n        h = this.startDuration,\n        g = f.labelSet;\n      e && 0 < h && (0 < f.alpha && e.show(), e.translate(f.startX, f.startY), this.animatable.push(e), e.animate({\n        opacity: 1,\n        translate: \"0,0\"\n      }, h, this.startEffect));\n      g && 0 < h && (0 < f.alpha && g.show(), g.translate(f.startX, f.startY), g.animate({\n        opacity: 1,\n        translate: \"0,0\"\n      }, h, this.startEffect));\n    },\n    showLabels: function () {\n      var f = this.chartData,\n        e;\n      for (e = 0; e < f.length; e++) {\n        var h = f[e];\n        if (0 < h.alpha) {\n          var g = h.label;\n          g && g.show();\n          (h = h.tick) && h.show();\n        }\n      }\n    },\n    showSlice: function (b) {\n      isNaN(b) ? b.hidden = !1 : this.chartData[b].hidden = !1;\n      this.invalidateVisibility();\n    },\n    hideSlice: function (b) {\n      isNaN(b) ? b.hidden = !0 : this.chartData[b].hidden = !0;\n      this.hideBalloon();\n      this.invalidateVisibility();\n    },\n    rollOverSlice: function (i, e, n) {\n      isNaN(i) || (i = this.chartData[i]);\n      clearTimeout(this.hoverInt);\n      if (!i.hidden) {\n        this.pullOnHover && this.pullSlice(i, 1);\n        1 > this.hoverAlpha && i.wedge && i.wedge.attr({\n          opacity: this.hoverAlpha\n        });\n        var m = i.balloonX,\n          k = i.balloonY;\n        i.pulled && (m += i.pullX, k += i.pullY);\n        var l = this.formatString(this.balloonText, i, !0),\n          j = this.balloonFunction;\n        j && (l = j(i, l));\n        j = a.adjustLuminosity(i.color, -0.15);\n        l ? this.showBalloon(l, j, e, m, k) : this.hideBalloon();\n        0 === i.value && this.hideBalloon();\n        this.fire({\n          type: \"rollOverSlice\",\n          dataItem: i,\n          chart: this,\n          event: n\n        });\n      }\n    },\n    rollOutSlice: function (d, c) {\n      isNaN(d) || (d = this.chartData[d]);\n      d.wedge && d.wedge.attr({\n        opacity: 1\n      });\n      this.hideBalloon();\n      this.fire({\n        type: \"rollOutSlice\",\n        dataItem: d,\n        chart: this,\n        event: c\n      });\n    },\n    clickSlice: function (e, d, f) {\n      this.checkTouchDuration(d) && (isNaN(e) || (e = this.chartData[e]), e.pulled ? this.pullSlice(e, 0) : this.pullSlice(e, 1), a.getURL(e.url, this.urlTarget), f || this.fire({\n        type: \"clickSlice\",\n        dataItem: e,\n        chart: this,\n        event: d\n      }));\n    },\n    handleRightClick: function (d, c) {\n      isNaN(d) || (d = this.chartData[d]);\n      this.fire({\n        type: \"rightClickSlice\",\n        dataItem: d,\n        chart: this,\n        event: c\n      });\n    },\n    drawTicks: function () {\n      var f = this.chartData,\n        e;\n      for (e = 0; e < f.length; e++) {\n        var h = f[e];\n        if (h.label && !h.skipTick) {\n          var g = h.ty,\n            g = a.line(this.container, [h.tx0, h.tx, h.tx2], [h.ty0, g, g], this.labelTickColor, this.labelTickAlpha);\n          a.setCN(this, g, this.type + \"-tick\");\n          a.setCN(this, g, h.className, !0);\n          h.tick = g;\n          h.wedge.push(g);\n          \"AmFunnelChart\" == this.cname && g.toBack();\n        }\n      }\n    },\n    initialStart: function () {\n      var e = this,\n        d = e.startDuration,\n        f = setTimeout(function () {\n          e.showLabels.call(e);\n        }, 1000 * d);\n      e.timeOuts.push(f);\n      e.chartCreated ? e.pullSlices(!0) : (e.startSlices(), 0 < d ? (d = setTimeout(function () {\n        e.pullSlices.call(e);\n      }, 1200 * d), e.timeOuts.push(d)) : e.pullSlices(!0));\n    },\n    pullSlice: function (f, e, h) {\n      var g = this.pullOutDuration;\n      !0 === h && (g = 0);\n      if (h = f.wedge) {\n        0 < g ? (h.animate({\n          translate: e * f.pullX + \",\" + e * f.pullY\n        }, g, this.pullOutEffect), f.labelSet && f.labelSet.animate({\n          translate: e * f.pullX + \",\" + e * f.pullY\n        }, g, this.pullOutEffect)) : (f.labelSet && f.labelSet.translate(e * f.pullX, e * f.pullY), h.translate(e * f.pullX, e * f.pullY));\n      }\n      1 == e ? (f.pulled = !0, this.pullOutOnlyOne && this.pullInAll(f.index), f = {\n        type: \"pullOutSlice\",\n        dataItem: f,\n        chart: this\n      }) : (f.pulled = !1, f = {\n        type: \"pullInSlice\",\n        dataItem: f,\n        chart: this\n      });\n      this.fire(f);\n    },\n    pullInAll: function (e) {\n      var d = this.chartData,\n        f;\n      for (f = 0; f < this.chartData.length; f++) {\n        f != e && d[f].pulled && this.pullSlice(d[f], 0);\n      }\n    },\n    pullOutAll: function () {\n      var d = this.chartData,\n        c;\n      for (c = 0; c < d.length; c++) {\n        d[c].pulled || this.pullSlice(d[c], 1);\n      }\n    },\n    parseData: function () {\n      var j = [];\n      this.chartData = j;\n      var i = this.dataProvider;\n      isNaN(this.pieAlpha) || (this.alpha = this.pieAlpha);\n      if (void 0 !== i) {\n        var p = i.length,\n          o = 0,\n          l,\n          m,\n          k;\n        for (l = 0; l < p; l++) {\n          m = {};\n          var n = i[l];\n          m.dataContext = n;\n          null !== n[this.valueField] && (m.value = Number(n[this.valueField]));\n          (k = n[this.titleField]) || (k = \"\");\n          m.title = k;\n          m.pulled = a.toBoolean(n[this.pulledField], !1);\n          (k = n[this.descriptionField]) || (k = \"\");\n          m.description = k;\n          m.labelRadius = Number(n[this.labelRadiusField]);\n          m.switchable = !0;\n          m.className = n[this.classNameField];\n          m.url = n[this.urlField];\n          k = n[this.patternField];\n          !k && this.patterns && (k = this.patterns[l]);\n          m.pattern = k;\n          m.visibleInLegend = a.toBoolean(n[this.visibleInLegendField], !0);\n          k = n[this.alphaField];\n          m.alpha = void 0 !== k ? Number(k) : this.alpha;\n          k = n[this.colorField];\n          void 0 !== k && (m.color = k);\n          m.labelColor = a.toColor(n[this.labelColorField]);\n          o += m.value;\n          m.hidden = !1;\n          j[l] = m;\n        }\n        for (l = i = 0; l < p; l++) {\n          m = j[l], m.percents = m.value / o * 100, m.percents < this.groupPercent && i++;\n        }\n        1 < i && (this.groupValue = 0, this.removeSmallSlices(), j.push({\n          title: this.groupedTitle,\n          value: this.groupValue,\n          percents: this.groupValue / o * 100,\n          pulled: this.groupedPulled,\n          color: this.groupedColor,\n          url: this.groupedUrl,\n          description: this.groupedDescription,\n          alpha: this.groupedAlpha,\n          pattern: this.groupedPattern,\n          className: this.groupedClassName,\n          dataContext: {}\n        }));\n        p = this.baseColor;\n        p || (p = this.pieBaseColor);\n        o = this.brightnessStep;\n        o || (o = this.pieBrightnessStep);\n        for (l = 0; l < j.length; l++) {\n          p ? k = a.adjustLuminosity(p, l * o / 100) : (k = this.colors[l], void 0 === k && (k = a.randomColor())), void 0 === j[l].color && (j[l].color = k);\n        }\n        this.recalculatePercents();\n      }\n    },\n    recalculatePercents: function () {\n      var f = this.chartData,\n        e = 0,\n        h,\n        g;\n      for (h = 0; h < f.length; h++) {\n        g = f[h], !g.hidden && 0 < g.value && (e += g.value);\n      }\n      for (h = 0; h < f.length; h++) {\n        g = this.chartData[h], g.percents = !g.hidden && 0 < g.value ? 100 * g.value / e : 0;\n      }\n    },\n    removeSmallSlices: function () {\n      var d = this.chartData,\n        c;\n      for (c = d.length - 1; 0 <= c; c--) {\n        d[c].percents < this.groupPercent && (this.groupValue += d[c].value, d.splice(c, 1));\n      }\n    },\n    animateAgain: function () {\n      var f = this;\n      f.startSlices();\n      for (var e = 0; e < f.chartData.length; e++) {\n        var h = f.chartData[e];\n        h.started = !1;\n        var g = h.wedge;\n        g && (g.setAttr(\"opacity\", f.startAlpha), g.translate(h.startX, h.startY));\n        if (g = h.labelSet) {\n          g.setAttr(\"opacity\", f.startAlpha), g.translate(h.startX, h.startY);\n        }\n      }\n      e = f.startDuration;\n      0 < e ? (e = setTimeout(function () {\n        f.pullSlices.call(f);\n      }, 1200 * e), f.timeOuts.push(e)) : f.pullSlices();\n    },\n    measureMaxLabel: function () {\n      var h = this.chartData,\n        e = 0,\n        l;\n      for (l = 0; l < h.length; l++) {\n        var k = h[l],\n          i = this.formatString(this.labelText, k),\n          j = this.labelFunction;\n        j && (i = j(k, i));\n        k = a.text(this.container, i, this.color, this.fontFamily, this.fontSize);\n        i = k.getBBox().width;\n        i > e && (e = i);\n        k.remove();\n      }\n      return e;\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmPieChart = a.Class({\n    inherits: a.AmSlicedChart,\n    construct: function (b) {\n      this.type = \"pie\";\n      a.AmPieChart.base.construct.call(this, b);\n      this.cname = \"AmPieChart\";\n      this.pieBrightnessStep = 30;\n      this.minRadius = 10;\n      this.depth3D = 0;\n      this.startAngle = 90;\n      this.angle = this.innerRadius = 0;\n      this.startRadius = \"500%\";\n      this.pullOutRadius = \"20%\";\n      this.labelRadius = 20;\n      this.labelText = \"[[title]]: [[percents]]%\";\n      this.balloonText = \"[[title]]: [[percents]]% ([[value]])\\n[[description]]\";\n      this.previousScale = 1;\n      this.adjustPrecision = !1;\n      this.gradientType = \"radial\";\n      a.applyTheme(this, b, this.cname);\n    },\n    drawChart: function () {\n      a.AmPieChart.base.drawChart.call(this);\n      var Z = this.chartData;\n      if (a.ifArray(Z)) {\n        if (0 < this.realWidth && 0 < this.realHeight) {\n          a.VML && (this.startAlpha = 1);\n          var Y = this.startDuration,\n            X = this.container,\n            W = this.updateWidth();\n          this.realWidth = W;\n          var T = this.updateHeight();\n          this.realHeight = T;\n          var U = a.toCoordinate,\n            S = U(this.marginLeft, W),\n            V = U(this.marginRight, W),\n            i = U(this.marginTop, T) + this.getTitleHeight(),\n            P = U(this.marginBottom, T) + this.depth3D,\n            O,\n            L,\n            Q,\n            o = a.toNumber(this.labelRadius),\n            M = this.measureMaxLabel();\n          M > this.maxLabelWidth && (M = this.maxLabelWidth);\n          this.labelText && this.labelsEnabled || (o = M = 0);\n          O = void 0 === this.pieX ? (W - S - V) / 2 + S : U(this.pieX, this.realWidth);\n          L = void 0 === this.pieY ? (T - i - P) / 2 + i : U(this.pieY, T);\n          Q = U(this.radius, W, T);\n          Q || (W = 0 <= o ? W - S - V - 2 * M : W - S - V, T = T - i - P, Q = Math.min(W, T), T < W && (Q /= 1 - this.angle / 90, Q > W && (Q = W)), T = a.toCoordinate(this.pullOutRadius, Q), Q = (0 <= o ? Q - 1.8 * (o + T) : Q - 1.8 * T) / 2);\n          Q < this.minRadius && (Q = this.minRadius);\n          T = U(this.pullOutRadius, Q);\n          i = a.toCoordinate(this.startRadius, Q);\n          U = U(this.innerRadius, Q);\n          U >= Q && (U = Q - 1);\n          P = a.fitToBounds(this.startAngle, 0, 360);\n          0 < this.depth3D && (P = 270 <= P ? 270 : 90);\n          P -= 90;\n          360 < P && (P -= 360);\n          W = Q - Q * this.angle / 90;\n          for (S = M = 0; S < Z.length; S++) {\n            V = Z[S], !0 !== V.hidden && (M += a.roundTo(V.percents, this.pf.precision));\n          }\n          M = a.roundTo(M, this.pf.precision);\n          this.tempPrec = NaN;\n          this.adjustPrecision && 100 != M && (this.tempPrec = this.pf.precision + 1);\n          for (var H, S = 0; S < Z.length; S++) {\n            if (V = Z[S], !0 !== V.hidden && (this.showZeroSlices || 0 !== V.percents)) {\n              var K = 360 * V.percents / 100,\n                M = Math.sin((P + K / 2) / 180 * Math.PI),\n                J = W / Q * -Math.cos((P + K / 2) / 180 * Math.PI),\n                N = this.outlineColor;\n              N || (N = V.color);\n              var F = this.alpha;\n              isNaN(V.alpha) || (F = V.alpha);\n              N = {\n                fill: V.color,\n                stroke: N,\n                \"stroke-width\": this.outlineThickness,\n                \"stroke-opacity\": this.outlineAlpha,\n                \"fill-opacity\": F\n              };\n              V.url && (N.cursor = \"pointer\");\n              N = a.wedge(X, O, L, P, K, Q, W, U, this.depth3D, N, this.gradientRatio, V.pattern, this.path, this.gradientType);\n              a.setCN(this, N, \"pie-item\");\n              a.setCN(this, N.wedge, \"pie-slice\");\n              a.setCN(this, N, V.className, !0);\n              this.addEventListeners(N, V);\n              V.startAngle = P;\n              Z[S].wedge = N;\n              0 < Y && (this.chartCreated || N.setAttr(\"opacity\", this.startAlpha));\n              V.ix = M;\n              V.iy = J;\n              V.wedge = N;\n              V.index = S;\n              V.label = null;\n              F = X.set();\n              if (this.labelsEnabled && this.labelText && V.percents >= this.hideLabelsPercent) {\n                var R = P + K / 2;\n                0 > R && (R += 360);\n                360 < R && (R -= 360);\n                var G = o;\n                isNaN(V.labelRadius) || (G = V.labelRadius, 0 > G && (V.skipTick = !0));\n                var K = O + M * (Q + G),\n                  I = L + J * (Q + G),\n                  k,\n                  s = 0;\n                isNaN(H) && 350 < R && 1 < Z.length - S && (H = S - 1 + Math.floor((Z.length - S) / 2));\n                if (0 <= G) {\n                  var j;\n                  90 >= R && 0 <= R ? (j = 0, k = \"start\", s = 8) : 90 <= R && 180 > R ? (j = 1, k = \"start\", s = 8) : 180 <= R && 270 > R ? (j = 2, k = \"end\", s = -8) : 270 <= R && 354 >= R ? (j = 3, k = \"end\", s = -8) : 354 <= R && (S > H ? (j = 0, k = \"start\", s = 8) : (j = 3, k = \"end\", s = -8));\n                  V.labelQuarter = j;\n                } else {\n                  k = \"middle\";\n                }\n                R = this.formatString(this.labelText, V);\n                (G = this.labelFunction) && (R = G(V, R));\n                G = V.labelColor;\n                G || (G = this.color);\n                \"\" !== R && (R = a.wrappedText(X, R, G, this.fontFamily, this.fontSize, k, !1, this.maxLabelWidth), a.setCN(this, R, \"pie-label\"), a.setCN(this, R, V.className, !0), R.translate(K + 1.5 * s, I), 0 > o && (R.node.style.pointerEvents = \"none\"), R.node.style.cursor = \"default\", V.ty = I, V.textX = K + 1.5 * s, F.push(R), this.axesSet.push(F), V.labelSet = F, V.label = R, this.addEventListeners(F, V));\n                V.tx = K;\n                V.tx2 = K + s;\n                V.tx0 = O + M * Q;\n                V.ty0 = L + J * Q;\n              }\n              K = U + (Q - U) / 2;\n              V.pulled && (K += T);\n              this.accessible && this.accessibleLabel && (I = this.formatString(this.accessibleLabel, V), this.makeAccessible(N, I));\n              void 0 !== this.tabIndex && N.setAttr(\"tabindex\", this.tabIndex);\n              V.balloonX = M * K + O;\n              V.balloonY = J * K + L;\n              V.startX = Math.round(M * i);\n              V.startY = Math.round(J * i);\n              V.pullX = Math.round(M * T);\n              V.pullY = Math.round(J * T);\n              this.graphsSet.push(N);\n              if (0 === V.alpha || 0 < Y && !this.chartCreated) {\n                N.hide(), F && F.hide();\n              }\n              P += 360 * V.percents / 100;\n              360 < P && (P -= 360);\n            }\n          }\n          0 < o && this.arrangeLabels();\n          this.pieXReal = O;\n          this.pieYReal = L;\n          this.radiusReal = Q;\n          this.innerRadiusReal = U;\n          0 < o && this.drawTicks();\n          this.initialStart();\n          this.setDepths();\n        }\n        (Z = this.legend) && Z.invalidateSize();\n      } else {\n        this.cleanChart();\n      }\n      this.dispDUpd();\n    },\n    setDepths: function () {\n      var f = this.chartData,\n        e;\n      for (e = 0; e < f.length; e++) {\n        var h = f[e],\n          g = h.wedge,\n          h = h.startAngle;\n        0 <= h && 180 > h ? g.toFront() : 180 <= h && g.toBack();\n      }\n    },\n    arrangeLabels: function () {\n      var f = this.chartData,\n        e = f.length,\n        h,\n        g;\n      for (g = e - 1; 0 <= g; g--) {\n        h = f[g], 0 !== h.labelQuarter || h.hidden || this.checkOverlapping(g, h, 0, !0, 0);\n      }\n      for (g = 0; g < e; g++) {\n        h = f[g], 1 != h.labelQuarter || h.hidden || this.checkOverlapping(g, h, 1, !1, 0);\n      }\n      for (g = e - 1; 0 <= g; g--) {\n        h = f[g], 2 != h.labelQuarter || h.hidden || this.checkOverlapping(g, h, 2, !0, 0);\n      }\n      for (g = 0; g < e; g++) {\n        h = f[g], 3 != h.labelQuarter || h.hidden || this.checkOverlapping(g, h, 3, !1, 0);\n      }\n    },\n    checkOverlapping: function (t, s, r, q, m) {\n      var o,\n        l,\n        p = this.chartData,\n        j = p.length,\n        i = s.label;\n      if (i) {\n        if (!0 === q) {\n          for (l = t + 1; l < j; l++) {\n            p[l].labelQuarter == r && (o = this.checkOverlappingReal(s, p[l], r)) && (l = j);\n          }\n        } else {\n          for (l = t - 1; 0 <= l; l--) {\n            p[l].labelQuarter == r && (o = this.checkOverlappingReal(s, p[l], r)) && (l = 0);\n          }\n        }\n        !0 === o && 200 > m && isNaN(s.labelRadius) && (o = s.ty + 3 * s.iy, s.ty = o, i.translate(s.textX, o), this.checkOverlapping(t, s, r, q, m + 1));\n      }\n    },\n    checkOverlappingReal: function (h, e, l) {\n      var k = !1,\n        i = h.label,\n        j = e.label;\n      h.labelQuarter != l || h.hidden || e.hidden || !j || (i = i.getBBox(), l = {}, l.width = i.width, l.height = i.height, l.y = h.ty, l.x = h.tx, h = j.getBBox(), j = {}, j.width = h.width, j.height = h.height, j.y = e.ty, j.x = e.tx, a.hitTest(l, j) && (k = !0));\n      return k;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}