{"ast":null,"code":"(function () {\n  var a;\n  window.AmCharts ? a = window.AmCharts : (a = {}, window.AmCharts = a, a.themes = {}, a.maps = {}, a.inheriting = {}, a.charts = [], a.onReadyArray = [], a.useUTC = !1, a.updateRate = 60, a.uid = 0, a.lang = {}, a.translations = {}, a.mapTranslations = {}, a.windows = {}, a.initHandlers = [], a.amString = \"am\", a.pmString = \"pm\");\n  a.Class = function (e) {\n    var d = function () {\n      arguments[0] !== a.inheriting && (this.events = {}, this.construct.apply(this, arguments));\n    };\n    e.inherits ? (d.prototype = new e.inherits(a.inheriting), d.base = e.inherits.prototype, delete e.inherits) : (d.prototype.createEvents = function () {\n      for (var b = 0; b < arguments.length; b++) {\n        this.events[arguments[b]] = [];\n      }\n    }, d.prototype.listenTo = function (h, g, i) {\n      this.removeListener(h, g, i);\n      h.events[g].push({\n        handler: i,\n        scope: this\n      });\n    }, d.prototype.addListener = function (h, g, i) {\n      this.removeListener(this, h, g);\n      h && this.events[h] && this.events[h].push({\n        handler: g,\n        scope: i\n      });\n    }, d.prototype.removeListener = function (h, g, i) {\n      if (h && h.events && (h = h.events[g])) {\n        for (g = h.length - 1; 0 <= g; g--) {\n          h[g].handler === i && h.splice(g, 1);\n        }\n      }\n    }, d.prototype.fire = function (h) {\n      for (var g = this.events[h.type], j = 0; j < g.length; j++) {\n        var i = g[j];\n        i.handler.call(i.scope, h);\n      }\n    });\n    for (var f in e) {\n      d.prototype[f] = e[f];\n    }\n    return d;\n  };\n  a.addChart = function (b) {\n    window.requestAnimationFrame ? a.animationRequested || (a.animationRequested = !0, window.requestAnimationFrame(a.update)) : a.updateInt || (a.updateInt = setInterval(function () {\n      a.update();\n    }, Math.round(1000 / a.updateRate)));\n    a.charts.push(b);\n  };\n  a.removeChart = function (e) {\n    for (var d = a.charts, f = d.length - 1; 0 <= f; f--) {\n      d[f] == e && d.splice(f, 1);\n    }\n    0 === d.length && (a.requestAnimation && (window.cancelAnimationFrame(a.requestAnimation), a.animationRequested = !1), a.updateInt && (clearInterval(a.updateInt), a.updateInt = NaN));\n  };\n  a.isModern = !0;\n  a.getIEVersion = function () {\n    var e = 0,\n      d,\n      f;\n    \"Microsoft Internet Explorer\" == navigator.appName && (d = navigator.userAgent, f = /MSIE ([0-9]{1,}[.0-9]{0,})/, null !== f.exec(d) && (e = parseFloat(RegExp.$1)));\n    return e;\n  };\n  a.applyLang = function (e, d) {\n    var f = a.translations;\n    d.dayNames = a.extend({}, a.dayNames);\n    d.shortDayNames = a.extend({}, a.shortDayNames);\n    d.monthNames = a.extend({}, a.monthNames);\n    d.shortMonthNames = a.extend({}, a.shortMonthNames);\n    d.amString = \"am\";\n    d.pmString = \"pm\";\n    f && (f = f[e]) && (a.lang = f, d.langObj = f, f.monthNames && (d.dayNames = a.extend({}, f.dayNames), d.shortDayNames = a.extend({}, f.shortDayNames), d.monthNames = a.extend({}, f.monthNames), d.shortMonthNames = a.extend({}, f.shortMonthNames)), f.am && (d.amString = f.am), f.pm && (d.pmString = f.pm));\n    a.amString = d.amString;\n    a.pmString = d.pmString;\n  };\n  a.IEversion = a.getIEVersion();\n  9 > a.IEversion && 0 < a.IEversion && (a.isModern = !1, a.isIE = !0);\n  a.dx = 0;\n  a.dy = 0;\n  if (document.addEventListener || window.opera) {\n    a.isNN = !0, a.isIE = !1, a.dx = 0.5, a.dy = 0.5;\n  }\n  document.attachEvent && (a.isNN = !1, a.isIE = !0, a.isModern || (a.dx = 0, a.dy = 0));\n  window.chrome && (a.chrome = !0);\n  a.handleMouseUp = function (f) {\n    for (var d = a.charts, h = 0; h < d.length; h++) {\n      var g = d[h];\n      g && g.handleReleaseOutside && g.handleReleaseOutside(f);\n    }\n  };\n  a.handleMouseMove = function (f) {\n    for (var d = a.charts, h = 0; h < d.length; h++) {\n      var g = d[h];\n      g && g.handleMouseMove && g.handleMouseMove(f);\n    }\n  };\n  a.handleWheel = function (f) {\n    for (var d = a.charts, h = 0; h < d.length; h++) {\n      var g = d[h];\n      if (g && g.mouseIsOver) {\n        (g.mouseWheelScrollEnabled || g.mouseWheelZoomEnabled) && g.handleWheel && g.handleWheel(f);\n        break;\n      }\n    }\n  };\n  a.resetMouseOver = function () {\n    for (var e = a.charts, d = 0; d < e.length; d++) {\n      var f = e[d];\n      f && (f.mouseIsOver = !1);\n    }\n  };\n  a.ready = function (b) {\n    a.onReadyArray.push(b);\n  };\n  a.handleLoad = function () {\n    a.isReady = !0;\n    for (var e = a.onReadyArray, d = 0; d < e.length; d++) {\n      var f = e[d];\n      isNaN(a.processDelay) ? f() : setTimeout(f, a.processDelay * d);\n    }\n    a.onReadyArray = [];\n  };\n  a.addInitHandler = function (d, c) {\n    a.initHandlers.push({\n      method: d,\n      types: c\n    });\n  };\n  a.callInitHandler = function (f) {\n    var d = a.initHandlers;\n    if (a.initHandlers) {\n      for (var h = 0; h < d.length; h++) {\n        var g = d[h];\n        g.types ? a.isInArray(g.types, f.type) && g.method(f) : g.method(f);\n      }\n    }\n  };\n  a.getUniqueId = function () {\n    a.uid++;\n    return \"AmChartsEl-\" + a.uid;\n  };\n  a.isNN && (document.addEventListener(\"mousemove\", a.handleMouseMove), document.addEventListener(\"mouseup\", a.handleMouseUp, !0), window.addEventListener(\"load\", a.handleLoad, !0));\n  a.isIE && (document.attachEvent(\"onmousemove\", a.handleMouseMove), document.attachEvent(\"onmouseup\", a.handleMouseUp), window.attachEvent(\"onload\", a.handleLoad));\n  a.addWheelListeners = function () {\n    a.wheelIsListened || (a.isNN && (window.addEventListener(\"DOMMouseScroll\", a.handleWheel, !0), document.addEventListener(\"mousewheel\", a.handleWheel, !0)), a.isIE && document.attachEvent(\"onmousewheel\", a.handleWheel));\n    a.wheelIsListened = !0;\n  };\n  a.clear = function () {\n    var d = a.charts;\n    if (d) {\n      for (var c = d.length - 1; 0 <= c; c--) {\n        d[c].clear();\n      }\n    }\n    a.updateInt && clearInterval(a.updateInt);\n    a.requestAnimation && window.cancelAnimationFrame(a.requestAnimation);\n    a.charts = [];\n    a.isNN && (document.removeEventListener(\"mousemove\", a.handleMouseMove, !0), document.removeEventListener(\"mouseup\", a.handleMouseUp, !0), window.removeEventListener(\"load\", a.handleLoad, !0), window.removeEventListener(\"DOMMouseScroll\", a.handleWheel, !0), document.removeEventListener(\"mousewheel\", a.handleWheel, !0));\n    a.isIE && (document.detachEvent(\"onmousemove\", a.handleMouseMove), document.detachEvent(\"onmouseup\", a.handleMouseUp), window.detachEvent(\"onload\", a.handleLoad));\n  };\n  a.makeChart = function (h, d, l) {\n    var k = d.type,\n      j = d.theme;\n    a.isString(j) && (j = a.themes[j], d.theme = j);\n    var i;\n    switch (k) {\n      case \"serial\":\n        i = new a.AmSerialChart(j);\n        break;\n      case \"xy\":\n        i = new a.AmXYChart(j);\n        break;\n      case \"pie\":\n        i = new a.AmPieChart(j);\n        break;\n      case \"radar\":\n        i = new a.AmRadarChart(j);\n        break;\n      case \"gauge\":\n        i = new a.AmAngularGauge(j);\n        break;\n      case \"funnel\":\n        i = new a.AmFunnelChart(j);\n        break;\n      case \"map\":\n        i = new a.AmMap(j);\n        break;\n      case \"stock\":\n        i = new a.AmStockChart(j);\n        break;\n      case \"gantt\":\n        i = new a.AmGanttChart(j);\n    }\n    a.extend(i, d);\n    a.isReady ? isNaN(l) ? i.write(h) : setTimeout(function () {\n      a.realWrite(i, h);\n    }, l) : a.ready(function () {\n      isNaN(l) ? i.write(h) : setTimeout(function () {\n        a.realWrite(i, h);\n      }, l);\n    });\n    return i;\n  };\n  a.realWrite = function (d, c) {\n    d.write(c);\n  };\n  a.updateCount = 0;\n  a.validateAt = Math.round(a.updateRate / 10);\n  a.update = function () {\n    var e = a.charts;\n    a.updateCount++;\n    var d = !1;\n    a.updateCount == a.validateAt && (d = !0, a.updateCount = 0);\n    if (e) {\n      for (var f = e.length - 1; 0 <= f; f--) {\n        e[f].update && e[f].update(), d && (e[f].autoResize ? e[f].validateSize && e[f].validateSize() : e[f].premeasure && e[f].premeasure());\n      }\n    }\n    window.requestAnimationFrame && (a.requestAnimation = window.requestAnimationFrame(a.update));\n  };\n  \"complete\" == document.readyState && a.handleLoad();\n})();\n(function () {\n  var a = window.AmCharts;\n  a.toBoolean = function (d, c) {\n    if (void 0 === d) {\n      return c;\n    }\n    switch (String(d).toLowerCase()) {\n      case \"true\":\n      case \"yes\":\n      case \"1\":\n        return !0;\n      case \"false\":\n      case \"no\":\n      case \"0\":\n      case null:\n        return !1;\n      default:\n        return !!d;\n    }\n  };\n  a.removeFromArray = function (e, d) {\n    var f;\n    if (void 0 !== d && void 0 !== e) {\n      for (f = e.length - 1; 0 <= f; f--) {\n        e[f] == d && e.splice(f, 1);\n      }\n    }\n  };\n  a.getPath = function () {\n    var e = document.getElementsByTagName(\"script\");\n    if (e) {\n      for (var d = 0; d < e.length; d++) {\n        var f = e[d].src;\n        if (-1 !== f.search(/\\/(amcharts|ammap)\\.js/)) {\n          return f.replace(/\\/(amcharts|ammap)\\.js.*/, \"/\");\n        }\n      }\n    }\n  };\n  a.normalizeUrl = function (b) {\n    return \"\" !== b && -1 === b.search(/\\/$/) ? b + \"/\" : b;\n  };\n  a.isAbsolute = function (b) {\n    return 0 === b.search(/^http[s]?:|^\\//);\n  };\n  a.isInArray = function (e, d) {\n    for (var f = 0; f < e.length; f++) {\n      if (e[f] == d) {\n        return !0;\n      }\n    }\n    return !1;\n  };\n  a.getDecimals = function (d) {\n    var c = 0;\n    isNaN(d) || (d = String(d), -1 != d.indexOf(\"e-\") ? c = Number(d.split(\"-\")[1]) : -1 != d.indexOf(\".\") && (c = d.split(\".\")[1].length));\n    return c;\n  };\n  a.wordwrap = function (i, d, p, o) {\n    var n, m, l, j;\n    i += \"\";\n    if (1 > d) {\n      return i;\n    }\n    n = -1;\n    for (i = (j = i.split(/\\r\\n|\\n|\\r/)).length; ++n < i; j[n] += l) {\n      l = j[n];\n      for (j[n] = \"\"; l.length > d; j[n] += a.trim(l.slice(0, m)) + ((l = l.slice(m)).length ? p : \"\")) {\n        m = 2 == o || (m = l.slice(0, d + 1).match(/\\S*(\\s)?$/))[1] ? d : m.input.length - m[0].length || 1 == o && d || m.input.length + (m = l.slice(d).match(/^\\S*/))[0].length;\n      }\n      l = a.trim(l);\n    }\n    return j.join(p);\n  };\n  a.trim = function (b) {\n    return b.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  };\n  a.wrappedText = function (v, u, t, s, r, q, p, o) {\n    var j = a.text(v, u, t, s, r, q, p);\n    if (j) {\n      var i = j.getBBox();\n      if (i.width > o) {\n        var d = \"\\n\";\n        a.isModern || (d = \"<br>\");\n        o = Math.floor(o / (i.width / u.length));\n        2 < o && (o -= 2);\n        u = a.wordwrap(u, o, d, !0);\n        j.remove();\n        j = a.text(v, u, t, s, r, q, p);\n      }\n    }\n    return j;\n  };\n  a.getStyle = function (f, d) {\n    var h = \"\";\n    if (document.defaultView && document.defaultView.getComputedStyle) {\n      try {\n        h = document.defaultView.getComputedStyle(f, \"\").getPropertyValue(d);\n      } catch (g) {}\n    } else {\n      f.currentStyle && (d = d.replace(/\\-(\\w)/g, function (e, c) {\n        return c.toUpperCase();\n      }), h = f.currentStyle[d]);\n    }\n    return h;\n  };\n  a.removePx = function (b) {\n    if (void 0 !== b) {\n      return Number(b.substring(0, b.length - 2));\n    }\n  };\n  a.getURL = function (e, d) {\n    if (e) {\n      if (\"_self\" != d && d) {\n        if (\"_top\" == d && window.top) {\n          window.top.location.href = e;\n        } else {\n          if (\"_parent\" == d && window.parent) {\n            window.parent.location.href = e;\n          } else {\n            if (\"_blank\" == d) {\n              window.open(e);\n            } else {\n              var f = document.getElementsByName(d)[0];\n              f ? f.src = e : (f = a.windows[d]) ? f.opener && !f.opener.closed ? f.location.href = e : a.windows[d] = window.open(e) : a.windows[d] = window.open(e);\n            }\n          }\n        }\n      } else {\n        window.location.href = e;\n      }\n    }\n  };\n  a.ifArray = function (b) {\n    return b && \"object\" == typeof b && 0 < b.length ? !0 : !1;\n  };\n  a.callMethod = function (i, f) {\n    var n;\n    for (n = 0; n < f.length; n++) {\n      var l = f[n];\n      if (l) {\n        if (l[i]) {\n          l[i]();\n        }\n        var m = l.length;\n        if (0 < m) {\n          var k;\n          for (k = 0; k < m; k++) {\n            var j = l[k];\n            if (j && j[i]) {\n              j[i]();\n            }\n          }\n        }\n      }\n    }\n  };\n  a.toNumber = function (b) {\n    return \"number\" == typeof b ? b : Number(String(b).replace(/[^0-9\\-.]+/g, \"\"));\n  };\n  a.toColor = function (e) {\n    if (\"\" !== e && void 0 !== e) {\n      if (-1 != e.indexOf(\",\")) {\n        e = e.split(\",\");\n        var d;\n        for (d = 0; d < e.length; d++) {\n          var f = e[d].substring(e[d].length - 6, e[d].length);\n          e[d] = \"#\" + f;\n        }\n      } else {\n        e = e.substring(e.length - 6, e.length), e = \"#\" + e;\n      }\n    }\n    return e;\n  };\n  a.toCoordinate = function (f, d, h) {\n    var g;\n    void 0 !== f && (f = String(f), h && h < d && (d = h), g = Number(f), -1 != f.indexOf(\"!\") && (g = d - Number(f.substr(1))), -1 != f.indexOf(\"%\") && (g = d * Number(f.substr(0, f.length - 1)) / 100));\n    return g;\n  };\n  a.fitToBounds = function (e, d, f) {\n    e < d && (e = d);\n    e > f && (e = f);\n    return e;\n  };\n  a.isDefined = function (b) {\n    return void 0 === b ? !1 : !0;\n  };\n  a.stripNumbers = function (b) {\n    return b.replace(/[0-9]+/g, \"\");\n  };\n  a.roundTo = function (e, d) {\n    if (0 > d) {\n      return e;\n    }\n    var f = Math.pow(10, d);\n    return Math.round(e * f) / f;\n  };\n  a.toFixed = function (h, f) {\n    var l = !1;\n    0 > h && (l = !0, h = Math.abs(h));\n    var j = String(Math.round(h * Math.pow(10, f)));\n    if (0 < f) {\n      var k = j.length;\n      if (k < f) {\n        var i;\n        for (i = 0; i < f - k; i++) {\n          j = \"0\" + j;\n        }\n      }\n      k = j.substring(0, j.length - f);\n      \"\" === k && (k = 0);\n      j = k + \".\" + j.substring(j.length - f, j.length);\n      return l ? \"-\" + j : j;\n    }\n    return String(j);\n  };\n  a.formatDuration = function (r, q, p, o, n, m) {\n    var j = a.intervals,\n      i = m.decimalSeparator;\n    if (r >= j[q].contains) {\n      var d = r - Math.floor(r / j[q].contains) * j[q].contains;\n      \"ss\" == q ? (d = a.formatNumber(d, m), 1 == d.split(i)[0].length && (d = \"0\" + d)) : d = a.roundTo(d, m.precision);\n      (\"mm\" == q || \"hh\" == q) && 10 > d && (d = \"0\" + d);\n      p = d + \"\" + o[q] + \"\" + p;\n      r = Math.floor(r / j[q].contains);\n      q = j[q].nextInterval;\n      return a.formatDuration(r, q, p, o, n, m);\n    }\n    \"ss\" == q && (r = a.formatNumber(r, m), 1 == r.split(i)[0].length && (r = \"0\" + r));\n    (\"mm\" == q || \"hh\" == q) && 10 > r && (r = \"0\" + r);\n    p = r + \"\" + o[q] + \"\" + p;\n    if (j[n].count > j[q].count) {\n      for (r = j[q].count; r < j[n].count; r++) {\n        q = j[q].nextInterval, \"ss\" == q || \"mm\" == q || \"hh\" == q ? p = \"00\" + o[q] + \"\" + p : \"DD\" == q && (p = \"0\" + o[q] + \"\" + p);\n      }\n    }\n    \":\" == p.charAt(p.length - 1) && (p = p.substring(0, p.length - 1));\n    return p;\n  };\n  a.formatNumber = function (v, u, t, s, r) {\n    v = a.roundTo(v, u.precision);\n    isNaN(t) && (t = u.precision);\n    var q = u.decimalSeparator;\n    u = u.thousandsSeparator;\n    var p;\n    p = 0 > v ? \"-\" : \"\";\n    v = Math.abs(v);\n    var o = String(v),\n      j = !1;\n    -1 != o.indexOf(\"e\") && (j = !0);\n    0 <= t && !j && (o = a.toFixed(v, t));\n    var i = \"\";\n    if (j) {\n      i = o;\n    } else {\n      var o = o.split(\".\"),\n        j = String(o[0]),\n        d;\n      for (d = j.length; 0 <= d; d -= 3) {\n        i = d != j.length ? 0 !== d ? j.substring(d - 3, d) + u + i : j.substring(d - 3, d) + i : j.substring(d - 3, d);\n      }\n      void 0 !== o[1] && (i = i + q + o[1]);\n      void 0 !== t && 0 < t && \"0\" != i && (i = a.addZeroes(i, q, t));\n    }\n    i = p + i;\n    \"\" === p && !0 === s && 0 !== v && (i = \"+\" + i);\n    !0 === r && (i += \"%\");\n    return i;\n  };\n  a.addZeroes = function (e, d, f) {\n    e = e.split(d);\n    void 0 === e[1] && 0 < f && (e[1] = \"0\");\n    return e[1].length < f ? (e[1] += \"0\", a.addZeroes(e[0] + d + e[1], d, f)) : void 0 !== e[1] ? e[0] + d + e[1] : e[0];\n  };\n  a.scientificToNormal = function (f) {\n    var d;\n    f = String(f).split(\"e\");\n    var h;\n    if (\"-\" == f[1].substr(0, 1)) {\n      d = \"0.\";\n      for (h = 0; h < Math.abs(Number(f[1])) - 1; h++) {\n        d += \"0\";\n      }\n      d += f[0].split(\".\").join(\"\");\n    } else {\n      var g = 0;\n      d = f[0].split(\".\");\n      d[1] && (g = d[1].length);\n      d = f[0].split(\".\").join(\"\");\n      for (h = 0; h < Math.abs(Number(f[1])) - g; h++) {\n        d += \"0\";\n      }\n    }\n    return d;\n  };\n  a.toScientific = function (f, d) {\n    if (0 === f) {\n      return \"0\";\n    }\n    var h = Math.floor(Math.log(Math.abs(f)) * Math.LOG10E),\n      g = String(g).split(\".\").join(d);\n    return String(g) + \"e\" + h;\n  };\n  a.randomColor = function () {\n    return \"#\" + (\"00000\" + (16777216 * Math.random() << 0).toString(16)).substr(-6);\n  };\n  a.hitTest = function (r, q, p) {\n    var o = !1,\n      n = r.x,\n      m = r.x + r.width,\n      j = r.y,\n      i = r.y + r.height,\n      d = a.isInRectangle;\n    o || (o = d(n, j, q));\n    o || (o = d(n, i, q));\n    o || (o = d(m, j, q));\n    o || (o = d(m, i, q));\n    o || !0 === p || (o = a.hitTest(q, r, !0));\n    return o;\n  };\n  a.isInRectangle = function (e, d, f) {\n    return e >= f.x - 5 && e <= f.x + f.width + 5 && d >= f.y - 5 && d <= f.y + f.height + 5 ? !0 : !1;\n  };\n  a.isPercents = function (b) {\n    if (-1 != String(b).indexOf(\"%\")) {\n      return !0;\n    }\n  };\n  a.formatValue = function (v, u, t, s, r, q, p, o) {\n    if (u) {\n      void 0 === r && (r = \"\");\n      var j;\n      for (j = 0; j < t.length; j++) {\n        var i = t[j],\n          d = u[i];\n        void 0 !== d && (d = q ? a.addPrefix(d, o, p, s) : a.formatNumber(d, s), v = v.replace(new RegExp(\"\\\\[\\\\[\" + r + \"\" + i + \"\\\\]\\\\]\", \"g\"), d));\n      }\n    }\n    return v;\n  };\n  a.formatDataContextValue = function (g, f) {\n    if (g) {\n      var j = g.match(/\\[\\[.*?\\]\\]/g),\n        h;\n      for (h = 0; h < j.length; h++) {\n        var i = j[h],\n          i = i.substr(2, i.length - 4);\n        void 0 !== f[i] && (g = g.replace(new RegExp(\"\\\\[\\\\[\" + i + \"\\\\]\\\\]\", \"g\"), f[i]));\n      }\n    }\n    return g;\n  };\n  a.massReplace = function (f, d) {\n    for (var h in d) {\n      if (d.hasOwnProperty(h)) {\n        var g = d[h];\n        void 0 === g && (g = \"\");\n        f = f.replace(h, g);\n      }\n    }\n    return f;\n  };\n  a.cleanFromEmpty = function (b) {\n    return b.replace(/\\[\\[[^\\]]*\\]\\]/g, \"\");\n  };\n  a.addPrefix = function (t, s, r, q, p) {\n    var o = a.formatNumber(t, q),\n      n = \"\",\n      j,\n      i,\n      d;\n    if (0 === t) {\n      return \"0\";\n    }\n    0 > t && (n = \"-\");\n    t = Math.abs(t);\n    if (1 < t) {\n      for (j = s.length - 1; -1 < j; j--) {\n        if (t >= s[j].number && (i = t / s[j].number, d = Number(q.precision), 1 > d && (d = 1), r = a.roundTo(i, d), d = a.formatNumber(r, {\n          precision: -1,\n          decimalSeparator: q.decimalSeparator,\n          thousandsSeparator: q.thousandsSeparator\n        }), !p || i == r)) {\n          o = n + \"\" + d + \"\" + s[j].prefix;\n          break;\n        }\n      }\n    } else {\n      for (j = 0; j < r.length; j++) {\n        if (t <= r[j].number) {\n          i = t / r[j].number;\n          d = Math.abs(Math.floor(Math.log(i) * Math.LOG10E));\n          i = a.roundTo(i, d);\n          o = n + \"\" + i + \"\" + r[j].prefix;\n          break;\n        }\n      }\n    }\n    return o;\n  };\n  a.remove = function (b) {\n    b && b.remove();\n  };\n  a.getEffect = function (b) {\n    \">\" == b && (b = \"easeOutSine\");\n    \"<\" == b && (b = \"easeInSine\");\n    \"elastic\" == b && (b = \"easeOutElastic\");\n    return b;\n  };\n  a.getObjById = function (g, f) {\n    var j, h;\n    for (h = 0; h < g.length; h++) {\n      var i = g[h];\n      if (i.id == f) {\n        j = i;\n        break;\n      }\n    }\n    return j;\n  };\n  a.applyTheme = function (f, d, h) {\n    d || (d = a.theme);\n    try {\n      d = JSON.parse(JSON.stringify(d));\n    } catch (g) {}\n    d && d[h] && a.extend(f, d[h]);\n  };\n  a.isString = function (b) {\n    return \"string\" == typeof b ? !0 : !1;\n  };\n  a.extend = function (f, d, h) {\n    var g;\n    f || (f = {});\n    for (g in d) {\n      h ? f.hasOwnProperty(g) || (f[g] = d[g]) : f[g] = d[g];\n    }\n    return f;\n  };\n  a.copyProperties = function (e, d) {\n    for (var f in e) {\n      e.hasOwnProperty(f) && \"events\" != f && void 0 !== e[f] && \"function\" != typeof e[f] && \"cname\" != f && (d[f] = e[f]);\n    }\n  };\n  a.processObject = function (g, d, j, i) {\n    if (!1 === g instanceof d && (g = i ? a.extend(new d(j), g) : a.extend(g, new d(j), !0), g.listeners)) {\n      for (var h in g.listeners) {\n        d = g.listeners[h], g.addListener(d.event, d.method);\n      }\n    }\n    return g;\n  };\n  a.fixNewLines = function (d) {\n    var c = RegExp(\"\\\\n\", \"g\");\n    d && (d = d.replace(c, \"<br />\"));\n    return d;\n  };\n  a.fixBrakes = function (d) {\n    if (a.isModern) {\n      var c = RegExp(\"<br>\", \"g\");\n      d && (d = d.replace(c, \"\\n\"));\n    } else {\n      d = a.fixNewLines(d);\n    }\n    return d;\n  };\n  a.deleteObject = function (f, d) {\n    if (f) {\n      if (void 0 === d || null === d) {\n        d = 20;\n      }\n      if (0 !== d) {\n        if (\"[object Array]\" === Object.prototype.toString.call(f)) {\n          for (var h = 0; h < f.length; h++) {\n            a.deleteObject(f[h], d - 1), f[h] = null;\n          }\n        } else {\n          if (f && !f.tagName) {\n            try {\n              for (h in f.theme = null, f) {\n                f[h] && (\"object\" == typeof f[h] && a.deleteObject(f[h], d - 1), \"function\" != typeof f[h] && (f[h] = null));\n              }\n            } catch (g) {}\n          }\n        }\n      }\n    }\n  };\n  a.bounce = function (g, f, j, h, i) {\n    return (f /= i) < 1 / 2.75 ? 7.5625 * h * f * f + j : f < 2 / 2.75 ? h * (7.5625 * (f -= 1.5 / 2.75) * f + 0.75) + j : f < 2.5 / 2.75 ? h * (7.5625 * (f -= 2.25 / 2.75) * f + 0.9375) + j : h * (7.5625 * (f -= 2.625 / 2.75) * f + 0.984375) + j;\n  };\n  a.easeInOutQuad = function (g, f, j, h, i) {\n    f /= i / 2;\n    if (1 > f) {\n      return h / 2 * f * f + j;\n    }\n    f--;\n    return -h / 2 * (f * (f - 2) - 1) + j;\n  };\n  a.easeInSine = function (g, f, j, h, i) {\n    return -h * Math.cos(f / i * (Math.PI / 2)) + h + j;\n  };\n  a.easeOutSine = function (g, f, j, h, i) {\n    return h * Math.sin(f / i * (Math.PI / 2)) + j;\n  };\n  a.easeOutElastic = function (i, f, n, l, m) {\n    i = 1.70158;\n    var k = 0,\n      j = l;\n    if (0 === f) {\n      return n;\n    }\n    if (1 == (f /= m)) {\n      return n + l;\n    }\n    k || (k = 0.3 * m);\n    j < Math.abs(l) ? (j = l, i = k / 4) : i = k / (2 * Math.PI) * Math.asin(l / j);\n    return j * Math.pow(2, -10 * f) * Math.sin(2 * (f * m - i) * Math.PI / k) + l + n;\n  };\n  a.fixStepE = function (d) {\n    d = d.toExponential(0).split(\"e\");\n    var c = Number(d[1]);\n    9 == Number(d[0]) && c++;\n    return a.generateNumber(1, c);\n  };\n  a.generateNumber = function (g, f) {\n    var j = \"\",\n      h;\n    h = 0 > f ? Math.abs(f) - 1 : Math.abs(f);\n    var i;\n    for (i = 0; i < h; i++) {\n      j += \"0\";\n    }\n    return 0 > f ? Number(\"0.\" + j + String(g)) : Number(String(g) + j);\n  };\n  a.setCN = function (g, f, j, h) {\n    if (g.addClassNames && f && (f = f.node) && j) {\n      var i = f.getAttribute(\"class\");\n      g = g.classNamePrefix + \"-\";\n      h && (g = \"\");\n      i ? f.setAttribute(\"class\", i + \" \" + g + j) : f.setAttribute(\"class\", g + j);\n    }\n  };\n  a.removeCN = function (e, d, f) {\n    d && (d = d.node) && f && (d = d.classList) && d.remove(e.classNamePrefix + \"-\" + f);\n  };\n  a.parseDefs = function (g, d) {\n    for (var j in g) {\n      var i = typeof g[j];\n      if (0 < g[j].length && \"object\" == i) {\n        for (var h = 0; h < g[j].length; h++) {\n          i = document.createElementNS(a.SVG_NS, j), d.appendChild(i), a.parseDefs(g[j][h], i);\n        }\n      } else {\n        \"object\" == i ? (i = document.createElementNS(a.SVG_NS, j), d.appendChild(i), a.parseDefs(g[j], i)) : d.setAttribute(j, g[j]);\n      }\n    }\n  };\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmDraw = a.Class({\n    construct: function (f, d, h, g) {\n      a.SVG_NS = \"http://www.w3.org/2000/svg\";\n      a.SVG_XLINK = \"http://www.w3.org/1999/xlink\";\n      a.hasSVG = !!document.createElementNS && !!document.createElementNS(a.SVG_NS, \"svg\").createSVGRect;\n      1 > d && (d = 10);\n      1 > h && (h = 10);\n      this.div = f;\n      this.width = d;\n      this.height = h;\n      this.rBin = document.createElement(\"div\");\n      a.hasSVG ? (a.SVG = !0, d = this.createSvgElement(\"svg\"), f.appendChild(d), this.container = d, this.addDefs(g), this.R = new a.SVGRenderer(this)) : a.isIE && a.VMLRenderer && (a.VML = !0, a.vmlStyleSheet || (document.namespaces.add(\"amvml\", \"urn:schemas-microsoft-com:vml\"), 31 > document.styleSheets.length ? (d = document.createStyleSheet(), d.addRule(\".amvml\", \"behavior:url(#default#VML); display:inline-block; antialias:true\"), a.vmlStyleSheet = d) : document.styleSheets[0].addRule(\".amvml\", \"behavior:url(#default#VML); display:inline-block; antialias:true\")), this.container = f, this.R = new a.VMLRenderer(this, g), this.R.disableSelection(f));\n    },\n    createSvgElement: function (b) {\n      return document.createElementNS(a.SVG_NS, b);\n    },\n    circle: function (g, d, j, i) {\n      var h = new a.AmDObject(\"circle\", this);\n      h.attr({\n        r: j,\n        cx: g,\n        cy: d\n      });\n      this.addToContainer(h.node, i);\n      return h;\n    },\n    ellipse: function (h, d, l, k, j) {\n      var i = new a.AmDObject(\"ellipse\", this);\n      i.attr({\n        rx: l,\n        ry: k,\n        cx: h,\n        cy: d\n      });\n      this.addToContainer(i.node, j);\n      return i;\n    },\n    setSize: function (d, c) {\n      0 < d && 0 < c && (this.container.style.width = d + \"px\", this.container.style.height = c + \"px\");\n    },\n    rect: function (i, d, p, o, n, m, l) {\n      var j = new a.AmDObject(\"rect\", this);\n      a.VML && (n = Math.round(100 * n / Math.min(p, o)), p += 2 * m, o += 2 * m, j.bw = m, j.node.style.marginLeft = -m, j.node.style.marginTop = -m);\n      1 > p && (p = 1);\n      1 > o && (o = 1);\n      j.attr({\n        x: i,\n        y: d,\n        width: p,\n        height: o,\n        rx: n,\n        ry: n,\n        \"stroke-width\": m\n      });\n      this.addToContainer(j.node, l);\n      return j;\n    },\n    image: function (i, d, n, m, l, k) {\n      var j = new a.AmDObject(\"image\", this);\n      j.attr({\n        x: d,\n        y: n,\n        width: m,\n        height: l\n      });\n      this.R.path(j, i);\n      this.addToContainer(j.node, k);\n      return j;\n    },\n    addToContainer: function (d, c) {\n      c || (c = this.container);\n      c.appendChild(d);\n    },\n    text: function (e, d, f) {\n      return this.R.text(e, d, f);\n    },\n    path: function (g, d, j, i) {\n      var h = new a.AmDObject(\"path\", this);\n      i || (i = \"100,100\");\n      h.attr({\n        cs: i\n      });\n      j ? h.attr({\n        dd: g\n      }) : h.attr({\n        d: g\n      });\n      this.addToContainer(h.node, d);\n      return h;\n    },\n    set: function (b) {\n      return this.R.set(b);\n    },\n    remove: function (d) {\n      if (d) {\n        var c = this.rBin;\n        c.appendChild(d);\n        c.innerHTML = \"\";\n      }\n    },\n    renderFix: function () {\n      var h = this.container,\n        f = h.style;\n      f.top = \"0px\";\n      f.left = \"0px\";\n      try {\n        var l = h.getBoundingClientRect(),\n          j = l.left - Math.round(l.left),\n          k = l.top - Math.round(l.top);\n        j && (f.left = j + \"px\");\n        k && (f.top = k + \"px\");\n      } catch (i) {}\n    },\n    update: function () {\n      this.R.update();\n    },\n    addDefs: function (f) {\n      if (a.hasSVG) {\n        var d = this.createSvgElement(\"desc\"),\n          h = this.container;\n        h.setAttribute(\"version\", \"1.1\");\n        h.style.position = \"absolute\";\n        this.setSize(this.width, this.height);\n        if (f.accessibleTitle) {\n          var g = this.createSvgElement(\"text\");\n          h.appendChild(g);\n          g.innerHTML = f.accessibleTitle;\n          g.style.opacity = 0;\n        }\n        a.rtl && (h.setAttribute(\"direction\", \"rtl\"), h.style.left = \"auto\", h.style.right = \"0px\");\n        f && (f.addCodeCredits && d.appendChild(document.createTextNode(\"JavaScript chart by amCharts \" + f.version)), h.appendChild(d), f.defs && (d = this.createSvgElement(\"defs\"), h.appendChild(d), a.parseDefs(f.defs, d), this.defs = d));\n      }\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmDObject = a.Class({\n    construct: function (d, c) {\n      this.D = c;\n      this.R = c.R;\n      this.node = this.R.create(this, d);\n      this.y = this.x = 0;\n      this.scale = 1;\n    },\n    attr: function (b) {\n      this.R.attr(this, b);\n      return this;\n    },\n    getAttr: function (b) {\n      return this.node.getAttribute(b);\n    },\n    setAttr: function (d, c) {\n      this.R.setAttr(this, d, c);\n      return this;\n    },\n    clipRect: function (f, d, h, g) {\n      this.R.clipRect(this, f, d, h, g);\n    },\n    translate: function (f, d, h, g) {\n      g || (f = Math.round(f), d = Math.round(d));\n      this.R.move(this, f, d, h);\n      this.x = f;\n      this.y = d;\n      this.scale = h;\n      this.angle && this.rotate(this.angle);\n    },\n    rotate: function (d, c) {\n      this.R.rotate(this, d, c);\n      this.angle = d;\n    },\n    animate: function (h, d, l) {\n      for (var k in h) {\n        if (h.hasOwnProperty(k)) {\n          var j = k,\n            i = h[k];\n          l = a.getEffect(l);\n          this.R.animate(this, j, i, d, l);\n        }\n      }\n    },\n    push: function (e) {\n      if (e) {\n        var d = this.node;\n        d.appendChild(e.node);\n        var f = e.clipPath;\n        f && d.appendChild(f);\n        (e = e.grad) && d.appendChild(e);\n      }\n    },\n    text: function (b) {\n      this.R.setText(this, b);\n    },\n    remove: function () {\n      this.stop();\n      this.R.remove(this);\n    },\n    clear: function () {\n      var b = this.node;\n      if (b.hasChildNodes()) {\n        for (; 1 <= b.childNodes.length;) {\n          b.removeChild(b.firstChild);\n        }\n      }\n    },\n    hide: function () {\n      this.setAttr(\"visibility\", \"hidden\");\n    },\n    show: function () {\n      this.setAttr(\"visibility\", \"visible\");\n    },\n    getBBox: function () {\n      return this.R.getBBox(this);\n    },\n    toFront: function () {\n      var d = this.node;\n      if (d) {\n        this.prevNextNode = d.nextSibling;\n        var c = d.parentNode;\n        c && c.appendChild(d);\n      }\n    },\n    toPrevious: function () {\n      var b = this.node;\n      b && this.prevNextNode && (b = b.parentNode) && b.insertBefore(this.prevNextNode, null);\n    },\n    toBack: function () {\n      var e = this.node;\n      if (e) {\n        this.prevNextNode = e.nextSibling;\n        var d = e.parentNode;\n        if (d) {\n          var f = d.firstChild;\n          f && d.insertBefore(e, f);\n        }\n      }\n    },\n    mouseover: function (b) {\n      this.R.addListener(this, \"mouseover\", b);\n      return this;\n    },\n    mouseout: function (b) {\n      this.R.addListener(this, \"mouseout\", b);\n      return this;\n    },\n    click: function (b) {\n      this.R.addListener(this, \"click\", b);\n      return this;\n    },\n    dblclick: function (b) {\n      this.R.addListener(this, \"dblclick\", b);\n      return this;\n    },\n    mousedown: function (b) {\n      this.R.addListener(this, \"mousedown\", b);\n      return this;\n    },\n    mouseup: function (b) {\n      this.R.addListener(this, \"mouseup\", b);\n      return this;\n    },\n    touchmove: function (b) {\n      this.R.addListener(this, \"touchmove\", b);\n      return this;\n    },\n    touchstart: function (b) {\n      this.R.addListener(this, \"touchstart\", b);\n      return this;\n    },\n    touchend: function (b) {\n      this.R.addListener(this, \"touchend\", b);\n      return this;\n    },\n    keyup: function (b) {\n      this.R.addListener(this, \"keyup\", b);\n      return this;\n    },\n    focus: function (b) {\n      this.R.addListener(this, \"focus\", b);\n      return this;\n    },\n    blur: function (b) {\n      this.R.addListener(this, \"blur\", b);\n      return this;\n    },\n    contextmenu: function (b) {\n      this.node.addEventListener ? this.node.addEventListener(\"contextmenu\", b, !0) : this.R.addListener(this, \"contextmenu\", b);\n      return this;\n    },\n    stop: function () {\n      a.removeFromArray(this.R.animations, this.an_translate);\n      a.removeFromArray(this.R.animations, this.an_y);\n      a.removeFromArray(this.R.animations, this.an_x);\n    },\n    length: function () {\n      return this.node.childNodes.length;\n    },\n    gradient: function (e, d, f) {\n      this.R.gradient(this, e, d, f);\n    },\n    pattern: function (e, d, f) {\n      e && this.R.pattern(this, e, d, f);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.SVGRenderer = a.Class({\n    construct: function (b) {\n      this.D = b;\n      this.animations = [];\n    },\n    create: function (d, c) {\n      return document.createElementNS(a.SVG_NS, c);\n    },\n    attr: function (e, d) {\n      for (var f in d) {\n        d.hasOwnProperty(f) && this.setAttr(e, f, d[f]);\n      }\n    },\n    setAttr: function (e, d, f) {\n      void 0 !== f && e.node.setAttribute(d, f);\n    },\n    animate: function (h, d, l, k, j) {\n      h.animationFinished = !1;\n      var i = h.node;\n      h[\"an_\" + d] && a.removeFromArray(this.animations, h[\"an_\" + d]);\n      \"translate\" == d ? (i = (i = i.getAttribute(\"transform\")) ? String(i).substring(10, i.length - 1) : \"0,0\", i = i.split(\", \").join(\" \"), i = i.split(\" \").join(\",\"), 0 === i && (i = \"0,0\")) : i = Number(i.getAttribute(d));\n      l = {\n        obj: h,\n        frame: 0,\n        attribute: d,\n        from: i,\n        to: l,\n        time: k,\n        effect: j\n      };\n      this.animations.push(l);\n      h[\"an_\" + d] = l;\n    },\n    update: function () {\n      var t,\n        s = this.animations;\n      for (t = s.length - 1; 0 <= t; t--) {\n        var r = s[t],\n          q = r.time * a.updateRate,\n          p = r.frame + 1,\n          o = r.obj,\n          n = r.attribute,\n          j,\n          i,\n          d;\n        if (p <= q) {\n          r.frame++;\n          if (\"translate\" == n) {\n            j = r.from.split(\",\");\n            n = Number(j[0]);\n            j = Number(j[1]);\n            isNaN(j) && (j = 0);\n            i = r.to.split(\",\");\n            d = Number(i[0]);\n            i = Number(i[1]);\n            d = 0 === d - n ? d : Math.round(a[r.effect](0, p, n, d - n, q));\n            r = 0 === i - j ? i : Math.round(a[r.effect](0, p, j, i - j, q));\n            n = \"transform\";\n            if (isNaN(d) || isNaN(r)) {\n              continue;\n            }\n            r = \"translate(\" + d + \",\" + r + \")\";\n          } else {\n            i = Number(r.from), j = Number(r.to), d = j - i, r = a[r.effect](0, p, i, d, q), isNaN(r) && (r = j), 0 === d && this.animations.splice(t, 1);\n          }\n          this.setAttr(o, n, r);\n        } else {\n          \"translate\" == n ? (i = r.to.split(\",\"), d = Number(i[0]), i = Number(i[1]), o.translate(d, i)) : (j = Number(r.to), this.setAttr(o, n, j)), o.animationFinished = !0, this.animations.splice(t, 1);\n        }\n      }\n    },\n    getBBox: function (d) {\n      if (d = d.node) {\n        try {\n          return d.getBBox();\n        } catch (c) {}\n      }\n      return {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n    },\n    path: function (d, c) {\n      d.node.setAttributeNS(a.SVG_XLINK, \"xlink:href\", c);\n    },\n    clipRect: function (i, d, p, o, n) {\n      var m = i.node,\n        l = i.clipPath;\n      l && this.D.remove(l);\n      var j = m.parentNode;\n      j && (m = document.createElementNS(a.SVG_NS, \"clipPath\"), l = a.getUniqueId(), m.setAttribute(\"id\", l), this.D.rect(d, p, o, n, 0, 0, m), j.appendChild(m), d = \"#\", a.baseHref && !a.isIE && (d = this.removeTarget(window.location.href) + d), this.setAttr(i, \"clip-path\", \"url(\" + d + l + \")\"), this.clipPathC++, i.clipPath = m);\n    },\n    text: function (i, d, n) {\n      var m = new a.AmDObject(\"text\", this.D);\n      i = String(i).split(\"\\n\");\n      var l = a.removePx(d[\"font-size\"]),\n        k;\n      for (k = 0; k < i.length; k++) {\n        var j = this.create(null, \"tspan\");\n        j.appendChild(document.createTextNode(i[k]));\n        j.setAttribute(\"y\", (l + 2) * k + Math.round(l / 2));\n        j.setAttribute(\"x\", 0);\n        m.node.appendChild(j);\n      }\n      m.node.setAttribute(\"y\", Math.round(l / 2));\n      this.attr(m, d);\n      this.D.addToContainer(m.node, n);\n      return m;\n    },\n    setText: function (e, d) {\n      var f = e.node;\n      f && (f.removeChild(f.firstChild), f.appendChild(document.createTextNode(d)));\n    },\n    move: function (f, d, h, g) {\n      isNaN(d) && (d = 0);\n      isNaN(h) && (h = 0);\n      d = \"translate(\" + d + \",\" + h + \")\";\n      g && (d = d + \" scale(\" + g + \")\");\n      this.setAttr(f, \"transform\", d);\n    },\n    rotate: function (f, d) {\n      var h = f.node.getAttribute(\"transform\"),\n        g = \"rotate(\" + d + \")\";\n      h && (g = h + \" \" + g);\n      this.setAttr(f, \"transform\", g);\n    },\n    set: function (e) {\n      var d = new a.AmDObject(\"g\", this.D);\n      this.D.container.appendChild(d.node);\n      if (e) {\n        var f;\n        for (f = 0; f < e.length; f++) {\n          d.push(e[f]);\n        }\n      }\n      return d;\n    },\n    addListener: function (e, d, f) {\n      e.node[\"on\" + d] = f;\n    },\n    gradient: function (t, s, r, q) {\n      var p = t.node,\n        o = t.grad;\n      o && this.D.remove(o);\n      s = document.createElementNS(a.SVG_NS, s);\n      o = a.getUniqueId();\n      s.setAttribute(\"id\", o);\n      if (!isNaN(q)) {\n        var n = 0,\n          j = 0,\n          i = 0,\n          d = 0;\n        90 == q ? i = 100 : 270 == q ? d = 100 : 180 == q ? n = 100 : 0 === q && (j = 100);\n        s.setAttribute(\"x1\", n + \"%\");\n        s.setAttribute(\"x2\", j + \"%\");\n        s.setAttribute(\"y1\", i + \"%\");\n        s.setAttribute(\"y2\", d + \"%\");\n      }\n      for (q = 0; q < r.length; q++) {\n        n = document.createElementNS(a.SVG_NS, \"stop\"), j = 100 * q / (r.length - 1), 0 === q && (j = 0), n.setAttribute(\"offset\", j + \"%\"), n.setAttribute(\"stop-color\", r[q]), s.appendChild(n);\n      }\n      p.parentNode.appendChild(s);\n      r = \"#\";\n      a.baseHref && !a.isIE && (r = this.removeTarget(window.location.href) + r);\n      p.setAttribute(\"fill\", \"url(\" + r + o + \")\");\n      t.grad = s;\n    },\n    removeTarget: function (b) {\n      return b.split(\"#\")[0];\n    },\n    pattern: function (v, u, t, s) {\n      var r = v.node;\n      isNaN(t) && (t = 1);\n      var q = v.patternNode;\n      q && this.D.remove(q);\n      var q = document.createElementNS(a.SVG_NS, \"pattern\"),\n        p = a.getUniqueId(),\n        o = u;\n      u.url && (o = u.url);\n      a.isAbsolute(o) || -1 != o.indexOf(\"data:image\") || (o = s + o);\n      s = Number(u.width);\n      isNaN(s) && (s = 4);\n      var j = Number(u.height);\n      isNaN(j) && (j = 4);\n      s /= t;\n      j /= t;\n      t = u.x;\n      isNaN(t) && (t = 0);\n      var i = -Math.random() * Number(u.randomX);\n      isNaN(i) || (t = i);\n      i = u.y;\n      isNaN(i) && (i = 0);\n      var d = -Math.random() * Number(u.randomY);\n      isNaN(d) || (i = d);\n      q.setAttribute(\"id\", p);\n      q.setAttribute(\"width\", s);\n      q.setAttribute(\"height\", j);\n      q.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n      q.setAttribute(\"xlink:href\", o);\n      u.color && (d = document.createElementNS(a.SVG_NS, \"rect\"), d.setAttributeNS(null, \"height\", s), d.setAttributeNS(null, \"width\", j), d.setAttributeNS(null, \"fill\", u.color), q.appendChild(d));\n      this.D.image(o, 0, 0, s, j, q).translate(t, i);\n      o = \"#\";\n      a.baseHref && !a.isIE && (o = this.removeTarget(window.location.href) + o);\n      r.setAttribute(\"fill\", \"url(\" + o + p + \")\");\n      v.patternNode = q;\n      r.parentNode.appendChild(q);\n    },\n    remove: function (b) {\n      b.clipPath && this.D.remove(b.clipPath);\n      b.grad && this.D.remove(b.grad);\n      b.patternNode && this.D.remove(b.patternNode);\n      this.D.remove(b.node);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmChart = a.Class({\n    construct: function (e) {\n      this.svgIcons = this.tapToActivate = !0;\n      this.theme = e;\n      this.classNamePrefix = \"amcharts\";\n      this.addClassNames = !1;\n      this.version = \"3.21.5\";\n      a.addChart(this);\n      this.createEvents(\"buildStarted\", \"dataUpdated\", \"init\", \"rendered\", \"drawn\", \"failed\", \"resized\", \"animationFinished\");\n      this.height = this.width = \"100%\";\n      this.dataChanged = !0;\n      this.chartCreated = !1;\n      this.previousWidth = this.previousHeight = 0;\n      this.backgroundColor = \"#FFFFFF\";\n      this.borderAlpha = this.backgroundAlpha = 0;\n      this.color = this.borderColor = \"#000000\";\n      this.fontFamily = \"Verdana\";\n      this.fontSize = 11;\n      this.usePrefixes = !1;\n      this.autoResize = !0;\n      this.autoDisplay = !1;\n      this.addCodeCredits = this.accessible = !0;\n      this.touchStartTime = this.touchClickDuration = 0;\n      this.precision = -1;\n      this.percentPrecision = 2;\n      this.decimalSeparator = \".\";\n      this.thousandsSeparator = \",\";\n      this.labels = [];\n      this.allLabels = [];\n      this.titles = [];\n      this.marginRight = this.marginLeft = this.autoMarginOffset = 0;\n      this.timeOuts = [];\n      this.creditsPosition = \"top-left\";\n      var d = document.createElement(\"div\"),\n        f = d.style;\n      f.overflow = \"hidden\";\n      f.position = \"relative\";\n      f.textAlign = \"left\";\n      this.chartDiv = d;\n      d = document.createElement(\"div\");\n      f = d.style;\n      f.overflow = \"hidden\";\n      f.position = \"relative\";\n      f.textAlign = \"left\";\n      this.legendDiv = d;\n      this.titleHeight = 0;\n      this.hideBalloonTime = 150;\n      this.handDrawScatter = 2;\n      this.cssScale = this.handDrawThickness = 1;\n      this.cssAngle = 0;\n      this.prefixesOfBigNumbers = [{\n        number: 1000,\n        prefix: \"k\"\n      }, {\n        number: 1000000,\n        prefix: \"M\"\n      }, {\n        number: 1000000000,\n        prefix: \"G\"\n      }, {\n        number: 1000000000000,\n        prefix: \"T\"\n      }, {\n        number: 1000000000000000,\n        prefix: \"P\"\n      }, {\n        number: 1000000000000000000,\n        prefix: \"E\"\n      }, {\n        number: 1e21,\n        prefix: \"Z\"\n      }, {\n        number: 1e24,\n        prefix: \"Y\"\n      }];\n      this.prefixesOfSmallNumbers = [{\n        number: 1e-24,\n        prefix: \"y\"\n      }, {\n        number: 1e-21,\n        prefix: \"z\"\n      }, {\n        number: 1e-18,\n        prefix: \"a\"\n      }, {\n        number: 1e-15,\n        prefix: \"f\"\n      }, {\n        number: 1e-12,\n        prefix: \"p\"\n      }, {\n        number: 1e-9,\n        prefix: \"n\"\n      }, {\n        number: 0.000001,\n        prefix: \"\\u03bc\"\n      }, {\n        number: 0.001,\n        prefix: \"m\"\n      }];\n      this.panEventsEnabled = !0;\n      this.product = \"amcharts\";\n      this.animations = [];\n      this.balloon = new a.AmBalloon(this.theme);\n      this.balloon.chart = this;\n      this.processTimeout = 0;\n      this.processCount = 1000;\n      this.animatable = [];\n      this.langObj = {};\n      a.applyTheme(this, e, \"AmChart\");\n    },\n    drawChart: function () {\n      0 < this.realWidth && 0 < this.realHeight && (this.drawBackground(), this.redrawLabels(), this.drawTitles(), this.brr(), this.renderFix(), this.chartDiv && (this.boundingRect = this.chartDiv.getBoundingClientRect()));\n    },\n    makeAccessible: function (e, d, f) {\n      this.accessible && e && (f && e.setAttr(\"role\", f), e.setAttr(\"aria-label\", d));\n    },\n    drawBackground: function () {\n      a.remove(this.background);\n      var h = this.container,\n        d = this.backgroundColor,\n        l = this.backgroundAlpha,\n        k = this.set;\n      a.isModern || 0 !== l || (l = 0.001);\n      var j = this.updateWidth();\n      this.realWidth = j;\n      var i = this.updateHeight();\n      this.realHeight = i;\n      d = a.polygon(h, [0, j - 1, j - 1, 0], [0, 0, i - 1, i - 1], d, l, 1, this.borderColor, this.borderAlpha);\n      a.setCN(this, d, \"bg\");\n      this.background = d;\n      k.push(d);\n      if (d = this.backgroundImage) {\n        h = h.image(d, 0, 0, j, i), a.setCN(this, d, \"bg-image\"), this.bgImg = h, k.push(h);\n      }\n    },\n    drawTitles: function (r) {\n      var q = this.titles;\n      this.titleHeight = 0;\n      if (a.ifArray(q)) {\n        var p = 20,\n          o;\n        for (o = 0; o < q.length; o++) {\n          var n = q[o],\n            n = a.processObject(n, a.Title, this.theme);\n          if (!1 !== n.enabled) {\n            var m = n.color;\n            void 0 === m && (m = this.color);\n            var j = n.size;\n            isNaN(j) && (j = this.fontSize + 2);\n            isNaN(n.alpha);\n            var i = this.marginLeft,\n              d = !0;\n            void 0 !== n.bold && (d = n.bold);\n            m = a.wrappedText(this.container, n.text, m, this.fontFamily, j, \"middle\", d, this.realWidth - 35 - this.marginRight - i);\n            m.translate(i + (this.realWidth - this.marginRight - i) / 2, p);\n            m.node.style.pointerEvents = \"none\";\n            n.sprite = m;\n            void 0 !== n.tabIndex && m.setAttr(\"tabindex\", n.tabIndex);\n            a.setCN(this, m, \"title\");\n            n.id && a.setCN(this, m, \"title-\" + n.id);\n            m.attr({\n              opacity: n.alpha\n            });\n            p += m.getBBox().height + 5;\n            r ? m.remove() : this.freeLabelsSet.push(m);\n          }\n        }\n        this.titleHeight = p - 10;\n      }\n    },\n    write: function (f) {\n      var d = this;\n      if (d.listeners) {\n        for (var h = 0; h < d.listeners.length; h++) {\n          var g = d.listeners[h];\n          d.addListener(g.event, g.method);\n        }\n      }\n      d.fire({\n        type: \"buildStarted\",\n        chart: d\n      });\n      d.afterWriteTO && clearTimeout(d.afterWriteTO);\n      0 < d.processTimeout ? d.afterWriteTO = setTimeout(function () {\n        d.afterWrite.call(d, f);\n      }, d.processTimeout) : d.afterWrite(f);\n    },\n    afterWrite: function (i) {\n      var d;\n      if (d = \"object\" != typeof i ? document.getElementById(i) : i) {\n        for (; d.firstChild;) {\n          d.removeChild(d.firstChild);\n        }\n        this.div = d;\n        d.style.overflow = \"hidden\";\n        d.style.textAlign = \"left\";\n        i = this.chartDiv;\n        var p = this.legendDiv,\n          o = this.legend,\n          n = p.style,\n          m = i.style;\n        this.measure();\n        this.previousHeight = this.divRealHeight;\n        this.previousWidth = this.divRealWidth;\n        var l,\n          j = document.createElement(\"div\");\n        l = j.style;\n        l.position = \"relative\";\n        this.containerDiv = j;\n        j.className = this.classNamePrefix + \"-main-div\";\n        i.className = this.classNamePrefix + \"-chart-div\";\n        d.appendChild(j);\n        (d = this.exportConfig) && a.AmExport && !this.AmExport && (this.AmExport = new a.AmExport(this, d));\n        this.amExport && a.AmExport && (this.AmExport = a.extend(this.amExport, new a.AmExport(this), !0));\n        this.AmExport && this.AmExport.init && this.AmExport.init();\n        if (o) {\n          o = this.addLegend(o, o.divId);\n          if (o.enabled) {\n            switch (n.left = null, n.top = null, n.right = null, m.left = null, m.right = null, m.top = null, n.position = \"relative\", m.position = \"relative\", l.width = \"100%\", l.height = \"100%\", o.position) {\n              case \"bottom\":\n                j.appendChild(i);\n                j.appendChild(p);\n                break;\n              case \"top\":\n                j.appendChild(p);\n                j.appendChild(i);\n                break;\n              case \"absolute\":\n                n.position = \"absolute\";\n                m.position = \"absolute\";\n                void 0 !== o.left && (n.left = o.left + \"px\");\n                void 0 !== o.right && (n.right = o.right + \"px\");\n                void 0 !== o.top && (n.top = o.top + \"px\");\n                void 0 !== o.bottom && (n.bottom = o.bottom + \"px\");\n                o.marginLeft = 0;\n                o.marginRight = 0;\n                j.appendChild(i);\n                j.appendChild(p);\n                break;\n              case \"right\":\n                n.position = \"relative\";\n                m.position = \"absolute\";\n                j.appendChild(i);\n                j.appendChild(p);\n                break;\n              case \"left\":\n                n.position = \"absolute\";\n                m.position = \"relative\";\n                j.appendChild(i);\n                j.appendChild(p);\n                break;\n              case \"outside\":\n                j.appendChild(i);\n            }\n          } else {\n            j.appendChild(i);\n          }\n          this.prevLegendPosition = o.position;\n        } else {\n          j.appendChild(i);\n        }\n        this.listenersAdded || (this.addListeners(), this.listenersAdded = !0);\n        (this.mouseWheelScrollEnabled || this.mouseWheelZoomEnabled) && a.addWheelListeners();\n        this.initChart();\n      }\n    },\n    createLabelsSet: function () {\n      a.remove(this.labelsSet);\n      this.labelsSet = this.container.set();\n      this.freeLabelsSet.push(this.labelsSet);\n    },\n    initChart: function () {\n      this.balloon = a.processObject(this.balloon, a.AmBalloon, this.theme);\n      window.AmCharts_path && (this.path = window.AmCharts_path);\n      void 0 === this.path && (this.path = a.getPath());\n      void 0 === this.path && (this.path = \"amcharts/\");\n      this.path = a.normalizeUrl(this.path);\n      void 0 === this.pathToImages && (this.pathToImages = this.path + \"images/\");\n      this.initHC || (a.callInitHandler(this), this.initHC = !0);\n      a.applyLang(this.language, this);\n      var b = this.numberFormatter;\n      b && (isNaN(b.precision) || (this.precision = b.precision), void 0 !== b.thousandsSeparator && (this.thousandsSeparator = b.thousandsSeparator), void 0 !== b.decimalSeparator && (this.decimalSeparator = b.decimalSeparator));\n      (b = this.percentFormatter) && !isNaN(b.precision) && (this.percentPrecision = b.precision);\n      this.nf = {\n        precision: this.precision,\n        thousandsSeparator: this.thousandsSeparator,\n        decimalSeparator: this.decimalSeparator\n      };\n      this.pf = {\n        precision: this.percentPrecision,\n        thousandsSeparator: this.thousandsSeparator,\n        decimalSeparator: this.decimalSeparator\n      };\n      this.destroy();\n      (b = this.container) ? (b.container.innerHTML = \"\", b.width = this.realWidth, b.height = this.realHeight, b.addDefs(this), this.chartDiv.appendChild(b.container)) : b = new a.AmDraw(this.chartDiv, this.realWidth, this.realHeight, this);\n      this.container = b;\n      this.extension = \".png\";\n      this.svgIcons && a.SVG && (this.extension = \".svg\");\n      this.checkDisplay();\n      this.checkTransform(this.div);\n      b.chart = this;\n      a.VML || a.SVG ? (b.handDrawn = this.handDrawn, b.handDrawScatter = this.handDrawScatter, b.handDrawThickness = this.handDrawThickness, a.remove(this.set), this.set = b.set(), a.remove(this.gridSet), this.gridSet = b.set(), a.remove(this.cursorLineSet), this.cursorLineSet = b.set(), a.remove(this.graphsBehindSet), this.graphsBehindSet = b.set(), a.remove(this.bulletBehindSet), this.bulletBehindSet = b.set(), a.remove(this.columnSet), this.columnSet = b.set(), a.remove(this.graphsSet), this.graphsSet = b.set(), a.remove(this.trendLinesSet), this.trendLinesSet = b.set(), a.remove(this.axesSet), this.axesSet = b.set(), a.remove(this.cursorSet), this.cursorSet = b.set(), a.remove(this.scrollbarsSet), this.scrollbarsSet = b.set(), a.remove(this.bulletSet), this.bulletSet = b.set(), a.remove(this.freeLabelsSet), this.freeLabelsSet = b.set(), a.remove(this.axesLabelsSet), this.axesLabelsSet = b.set(), a.remove(this.balloonsSet), this.balloonsSet = b.set(), a.remove(this.plotBalloonsSet), this.plotBalloonsSet = b.set(), a.remove(this.zoomButtonSet), this.zoomButtonSet = b.set(), a.remove(this.zbSet), this.zbSet = null, a.remove(this.linkSet), this.linkSet = b.set()) : this.fire({\n        type: \"failed\",\n        chart: this\n      });\n    },\n    premeasure: function () {\n      var f = this.div;\n      if (f) {\n        try {\n          this.boundingRect = this.chartDiv.getBoundingClientRect();\n        } catch (g) {}\n        var d = f.offsetWidth,\n          h = f.offsetHeight;\n        f.clientHeight && (d = f.clientWidth, h = f.clientHeight);\n        if (d != this.mw || h != this.mh) {\n          this.mw = d, this.mh = h, this.measure();\n        }\n      }\n    },\n    measure: function () {\n      var h = this.div;\n      if (h) {\n        var d = this.chartDiv,\n          l = h.offsetWidth,\n          k = h.offsetHeight,\n          j = this.container;\n        h.clientHeight && (l = h.clientWidth, k = h.clientHeight);\n        var k = Math.round(k),\n          l = Math.round(l),\n          h = Math.round(a.toCoordinate(this.width, l)),\n          i = Math.round(a.toCoordinate(this.height, k));\n        (l != this.previousWidth || k != this.previousHeight) && 0 < h && 0 < i && (d.style.width = h + \"px\", d.style.height = i + \"px\", d.style.padding = 0, j && j.setSize(h, i), this.balloon = a.processObject(this.balloon, a.AmBalloon, this.theme));\n        this.balloon && this.balloon.setBounds && this.balloon.setBounds(2, 2, h - 2, i);\n        this.updateWidth();\n        this.balloon.chart = this;\n        this.realWidth = h;\n        this.realHeight = i;\n        this.divRealWidth = l;\n        this.divRealHeight = k;\n      }\n    },\n    checkDisplay: function () {\n      if (this.autoDisplay && this.container) {\n        var d = a.rect(this.container, 10, 10),\n          c = d.getBBox();\n        0 === c.width && 0 === c.height && (this.divRealHeight = this.divRealWidth = this.realHeight = this.realWidth = 0, this.previousWidth = this.previousHeight = NaN);\n        d.remove();\n      }\n    },\n    checkTransform: function (e) {\n      if (this.autoTransform && window.getComputedStyle && e) {\n        if (e.style) {\n          var d = window.getComputedStyle(e, null);\n          if (d && (d = d.getPropertyValue(\"-webkit-transform\") || d.getPropertyValue(\"-moz-transform\") || d.getPropertyValue(\"-ms-transform\") || d.getPropertyValue(\"-o-transform\") || d.getPropertyValue(\"transform\")) && \"none\" !== d) {\n            var f = d.split(\"(\")[1].split(\")\")[0].split(\",\"),\n              d = f[0],\n              f = f[1],\n              d = Math.sqrt(d * d + f * f);\n            isNaN(d) || (this.cssScale *= d);\n          }\n        }\n        e.parentNode && this.checkTransform(e.parentNode);\n      }\n    },\n    destroy: function () {\n      this.chartDiv.innerHTML = \"\";\n      this.clearTimeOuts();\n      this.legend && this.legend.destroy();\n    },\n    clearTimeOuts: function () {\n      var d = this.timeOuts;\n      if (d) {\n        var c;\n        for (c = 0; c < d.length; c++) {\n          clearTimeout(d[c]);\n        }\n      }\n      this.timeOuts = [];\n    },\n    clear: function (d) {\n      try {\n        document.removeEventListener(\"touchstart\", this.docfn1, !0), document.removeEventListener(\"touchend\", this.docfn2, !0);\n      } catch (c) {}\n      a.callMethod(\"clear\", [this.chartScrollbar, this.scrollbarV, this.scrollbarH, this.chartCursor]);\n      this.chartCursor = this.scrollbarH = this.scrollbarV = this.chartScrollbar = null;\n      this.clearTimeOuts();\n      this.container && (this.container.remove(this.chartDiv), this.container.remove(this.legendDiv));\n      d || a.removeChart(this);\n      if (d = this.div) {\n        for (; d.firstChild;) {\n          d.removeChild(d.firstChild);\n        }\n      }\n      this.legend && this.legend.destroy();\n      this.AmExport && this.AmExport.clear && this.AmExport.clear();\n    },\n    setMouseCursor: function (b) {\n      \"auto\" == b && a.isNN && (b = \"default\");\n      this.chartDiv.style.cursor = b;\n      this.legendDiv.style.cursor = b;\n    },\n    redrawLabels: function () {\n      this.labels = [];\n      var d = this.allLabels;\n      this.createLabelsSet();\n      var c;\n      for (c = 0; c < d.length; c++) {\n        this.drawLabel(d[c]);\n      }\n    },\n    drawLabel: function (v) {\n      var u = this;\n      if (u.container && !1 !== v.enabled) {\n        v = a.processObject(v, a.Label, u.theme);\n        var t = v.y,\n          s = v.text,\n          r = v.align,\n          q = v.size,\n          p = v.color,\n          o = v.rotation,\n          j = v.alpha,\n          i = v.bold,\n          d = a.toCoordinate(v.x, u.realWidth),\n          t = a.toCoordinate(t, u.realHeight);\n        d || (d = 0);\n        t || (t = 0);\n        void 0 === p && (p = u.color);\n        isNaN(q) && (q = u.fontSize);\n        r || (r = \"start\");\n        \"left\" == r && (r = \"start\");\n        \"right\" == r && (r = \"end\");\n        \"center\" == r && (r = \"middle\", o ? t = u.realHeight - t + t / 2 : d = u.realWidth / 2 - d);\n        void 0 === j && (j = 1);\n        void 0 === o && (o = 0);\n        t += q / 2;\n        s = a.text(u.container, s, p, u.fontFamily, q, r, i, j);\n        s.translate(d, t);\n        void 0 !== v.tabIndex && s.setAttr(\"tabindex\", v.tabIndex);\n        a.setCN(u, s, \"label\");\n        v.id && a.setCN(u, s, \"label-\" + v.id);\n        0 !== o && s.rotate(o);\n        v.url ? (s.setAttr(\"cursor\", \"pointer\"), s.click(function () {\n          a.getURL(v.url, u.urlTarget);\n        })) : s.node.style.pointerEvents = \"none\";\n        u.labelsSet.push(s);\n        u.labels.push(s);\n      }\n    },\n    addLabel: function (t, s, r, p, q, o, n, j, i, f) {\n      t = {\n        x: t,\n        y: s,\n        text: r,\n        align: p,\n        size: q,\n        color: o,\n        alpha: j,\n        rotation: n,\n        bold: i,\n        url: f,\n        enabled: !0\n      };\n      this.container && this.drawLabel(t);\n      this.allLabels.push(t);\n    },\n    clearLabels: function () {\n      var d = this.labels,\n        c;\n      for (c = d.length - 1; 0 <= c; c--) {\n        d[c].remove();\n      }\n      this.labels = [];\n      this.allLabels = [];\n    },\n    updateHeight: function () {\n      var e = this.divRealHeight,\n        d = this.legend;\n      if (d) {\n        var f = this.legendDiv.offsetHeight,\n          d = d.position;\n        if (\"top\" == d || \"bottom\" == d) {\n          e -= f;\n          if (0 > e || isNaN(e)) {\n            e = 0;\n          }\n          this.chartDiv.style.height = e + \"px\";\n        }\n      }\n      return e;\n    },\n    updateWidth: function () {\n      var i = this.divRealWidth,\n        f = this.divRealHeight,\n        p = this.legend;\n      if (p) {\n        var n = this.legendDiv,\n          o = n.offsetWidth;\n        isNaN(p.width) || (o = p.width);\n        p.ieW && (o = p.ieW);\n        var m = n.offsetHeight,\n          n = n.style,\n          l = this.chartDiv.style,\n          j = p.position;\n        if ((\"right\" == j || \"left\" == j) && void 0 === p.divId) {\n          i -= o;\n          if (0 > i || isNaN(i)) {\n            i = 0;\n          }\n          l.width = i + \"px\";\n          this.balloon && this.balloon.setBounds && this.balloon.setBounds(2, 2, i - 2, this.realHeight);\n          \"left\" == j ? (l.left = o + \"px\", n.left = \"0px\") : (l.left = \"0px\", n.left = i + \"px\");\n          f > m && (n.top = (f - m) / 2 + \"px\");\n        }\n      }\n      return i;\n    },\n    getTitleHeight: function () {\n      this.drawTitles(!0);\n      return this.titleHeight;\n    },\n    addTitle: function (g, f, j, h, i) {\n      isNaN(f) && (f = this.fontSize + 2);\n      g = {\n        text: g,\n        size: f,\n        color: j,\n        alpha: h,\n        bold: i,\n        enabled: !0\n      };\n      this.titles.push(g);\n      return g;\n    },\n    handleWheel: function (d) {\n      var c = 0;\n      d || (d = window.event);\n      d.wheelDelta ? c = d.wheelDelta / 120 : d.detail && (c = -d.detail / 3);\n      c && this.handleWheelReal(c, d.shiftKey);\n      d.preventDefault && d.preventDefault();\n    },\n    handleWheelReal: function () {},\n    handleDocTouchStart: function () {\n      this.handleMouseMove();\n      this.tmx = this.mouseX;\n      this.tmy = this.mouseY;\n      this.touchStartTime = new Date().getTime();\n    },\n    handleDocTouchEnd: function () {\n      -0.5 < this.tmx && this.tmx < this.divRealWidth + 1 && 0 < this.tmy && this.tmy < this.divRealHeight ? (this.handleMouseMove(), 4 > Math.abs(this.mouseX - this.tmx) && 4 > Math.abs(this.mouseY - this.tmy) ? (this.tapped = !0, this.panRequired && this.panEventsEnabled && this.chartDiv && (this.chartDiv.style.msTouchAction = \"none\", this.chartDiv.style.touchAction = \"none\")) : this.mouseIsOver || this.resetTouchStyle()) : (this.tapped = !1, this.resetTouchStyle());\n    },\n    resetTouchStyle: function () {\n      this.panEventsEnabled && this.chartDiv && (this.chartDiv.style.msTouchAction = \"auto\", this.chartDiv.style.touchAction = \"auto\");\n    },\n    checkTouchDuration: function (e) {\n      var d = this,\n        f = new Date().getTime();\n      if (e) {\n        if (e.touches) {\n          d.isTouchEvent = !0;\n        } else {\n          if (!d.isTouchEvent) {\n            return !0;\n          }\n        }\n      }\n      if (f - d.touchStartTime > d.touchClickDuration) {\n        return !0;\n      }\n      setTimeout(function () {\n        d.resetTouchDuration();\n      }, 300);\n    },\n    resetTouchDuration: function () {\n      this.isTouchEvent = !1;\n    },\n    checkTouchMoved: function () {\n      if (4 < Math.abs(this.mouseX - this.tmx) || 4 < Math.abs(this.mouseY - this.tmy)) {\n        return !0;\n      }\n    },\n    addListeners: function () {\n      var d = this,\n        c = d.chartDiv;\n      document.addEventListener ? (\"ontouchstart\" in document.documentElement && (c.addEventListener(\"touchstart\", function (e) {\n        d.handleTouchStart.call(d, e);\n      }, !0), c.addEventListener(\"touchmove\", function (e) {\n        d.handleMouseMove.call(d, e);\n      }, !0), c.addEventListener(\"touchend\", function (e) {\n        d.handleTouchEnd.call(d, e);\n      }, !0), d.docfn1 = function (e) {\n        d.handleDocTouchStart.call(d, e);\n      }, d.docfn2 = function (e) {\n        d.handleDocTouchEnd.call(d, e);\n      }, document.addEventListener(\"touchstart\", d.docfn1, !0), document.addEventListener(\"touchend\", d.docfn2, !0)), c.addEventListener(\"mousedown\", function (e) {\n        d.mouseIsOver = !0;\n        d.handleMouseMove.call(d, e);\n        d.handleMouseDown.call(d, e);\n        d.handleDocTouchStart.call(d, e);\n      }, !0), c.addEventListener(\"mouseover\", function (e) {\n        d.handleMouseOver.call(d, e);\n      }, !0), c.addEventListener(\"mouseout\", function (e) {\n        d.handleMouseOut.call(d, e);\n      }, !0), c.addEventListener(\"mouseup\", function (e) {\n        d.handleDocTouchEnd.call(d, e);\n      }, !0)) : (c.attachEvent(\"onmousedown\", function (e) {\n        d.handleMouseDown.call(d, e);\n      }), c.attachEvent(\"onmouseover\", function (e) {\n        d.handleMouseOver.call(d, e);\n      }), c.attachEvent(\"onmouseout\", function (e) {\n        d.handleMouseOut.call(d, e);\n      }));\n    },\n    dispDUpd: function () {\n      this.skipEvents || (this.dispatchDataUpdated && (this.dispatchDataUpdated = !1, this.fire({\n        type: \"dataUpdated\",\n        chart: this\n      })), this.chartCreated || (this.chartCreated = !0, this.fire({\n        type: \"init\",\n        chart: this\n      })), this.chartRendered || (this.fire({\n        type: \"rendered\",\n        chart: this\n      }), this.chartRendered = !0), this.fire({\n        type: \"drawn\",\n        chart: this\n      }));\n      this.skipEvents = !1;\n    },\n    validateSize: function () {\n      var e = this;\n      e.premeasure();\n      e.checkDisplay();\n      e.cssScale = 1;\n      e.cssAngle = 0;\n      e.checkTransform(e.div);\n      if (e.divRealWidth != e.previousWidth || e.divRealHeight != e.previousHeight) {\n        var d = e.legend;\n        if (0 < e.realWidth && 0 < e.realHeight) {\n          e.sizeChanged = !0;\n          if (d) {\n            e.legendInitTO && clearTimeout(e.legendInitTO);\n            var f = setTimeout(function () {\n              d.invalidateSize();\n            }, 10);\n            e.timeOuts.push(f);\n            e.legendInitTO = f;\n          }\n          e.marginsUpdated = !1;\n          clearTimeout(e.initTO);\n          f = setTimeout(function () {\n            e.initChart();\n          }, 10);\n          e.timeOuts.push(f);\n          e.initTO = f;\n        }\n        e.renderFix();\n        d && d.renderFix && d.renderFix();\n        clearTimeout(e.resizedTO);\n        e.resizedTO = setTimeout(function () {\n          e.fire({\n            type: \"resized\",\n            chart: e\n          });\n        }, 10);\n        e.previousHeight = e.divRealHeight;\n        e.previousWidth = e.divRealWidth;\n      }\n    },\n    invalidateSize: function () {\n      this.previousHeight = this.previousWidth = NaN;\n      this.invalidateSizeReal();\n    },\n    invalidateSizeReal: function () {\n      var d = this;\n      d.marginsUpdated = !1;\n      clearTimeout(d.validateTO);\n      var c = setTimeout(function () {\n        d.validateSize();\n      }, 5);\n      d.timeOuts.push(c);\n      d.validateTO = c;\n    },\n    validateData: function (b) {\n      this.chartCreated && (this.dataChanged = !0, this.marginsUpdated = !1, this.initChart(b));\n    },\n    validateNow: function (e, d) {\n      this.initTO && clearTimeout(this.initTO);\n      e && (this.dataChanged = !0, this.marginsUpdated = !1);\n      this.skipEvents = d;\n      this.chartRendered = !1;\n      var f = this.legend;\n      f && f.position != this.prevLegendPosition && (this.previousWidth = this.mw = 0, f.invalidateSize && (f.invalidateSize(), this.validateSize()));\n      this.write(this.div);\n    },\n    showItem: function (b) {\n      b.hidden = !1;\n      this.initChart();\n    },\n    hideItem: function (b) {\n      b.hidden = !0;\n      this.initChart();\n    },\n    hideBalloon: function () {\n      var b = this;\n      clearTimeout(b.hoverInt);\n      clearTimeout(b.balloonTO);\n      b.hoverInt = setTimeout(function () {\n        b.hideBalloonReal.call(b);\n      }, b.hideBalloonTime);\n    },\n    cleanChart: function () {},\n    hideBalloonReal: function () {\n      var b = this.balloon;\n      b && b.hide && b.hide();\n    },\n    showBalloon: function (h, f, l, j, k) {\n      var i = this;\n      clearTimeout(i.balloonTO);\n      clearTimeout(i.hoverInt);\n      i.balloonTO = setTimeout(function () {\n        i.showBalloonReal.call(i, h, f, l, j, k);\n      }, 1);\n    },\n    showBalloonReal: function (h, f, l, j, k) {\n      this.handleMouseMove();\n      var i = this.balloon;\n      i.enabled && (i.followCursor(!1), i.changeColor(f), !l || i.fixedPosition ? (i.setPosition(j, k), isNaN(j) || isNaN(k) ? i.followCursor(!0) : i.followCursor(!1)) : i.followCursor(!0), h && i.showBalloon(h));\n    },\n    handleMouseOver: function () {\n      this.outTO && clearTimeout(this.outTO);\n      a.resetMouseOver();\n      this.mouseIsOver = !0;\n    },\n    handleMouseOut: function () {\n      var b = this;\n      a.resetMouseOver();\n      b.outTO && clearTimeout(b.outTO);\n      b.outTO = setTimeout(function () {\n        b.handleMouseOutReal();\n      }, 10);\n    },\n    handleMouseOutReal: function () {\n      this.mouseIsOver = !1;\n    },\n    handleMouseMove: function (h) {\n      h || (h = window.event);\n      this.mouse2Y = this.mouse2X = NaN;\n      var f, l, j, k;\n      if (h) {\n        if (h.touches) {\n          var i = h.touches.item(1);\n          i && this.panEventsEnabled && this.boundingRect && (j = i.clientX - this.boundingRect.left, k = i.clientY - this.boundingRect.top);\n          h = h.touches.item(0);\n          if (!h) {\n            return;\n          }\n        } else {\n          this.wasTouched = !1;\n        }\n        this.boundingRect && h.clientX && (f = h.clientX - this.boundingRect.left, l = h.clientY - this.boundingRect.top);\n        isNaN(j) ? this.mouseX = f : (this.mouseX = Math.min(f, j), this.mouse2X = Math.max(f, j));\n        isNaN(k) ? this.mouseY = l : (this.mouseY = Math.min(l, k), this.mouse2Y = Math.max(l, k));\n        this.autoTransform && (this.mouseX /= this.cssScale, this.mouseY /= this.cssScale);\n      }\n    },\n    handleTouchStart: function (b) {\n      this.hideBalloonReal();\n      b && (b.touches && this.tapToActivate && !this.tapped || !this.panRequired) || (this.handleMouseMove(b), this.handleMouseDown(b));\n    },\n    handleTouchEnd: function (b) {\n      this.wasTouched = !0;\n      this.handleMouseMove(b);\n      a.resetMouseOver();\n      this.handleReleaseOutside(b);\n    },\n    handleReleaseOutside: function () {\n      this.handleDocTouchEnd.call(this);\n    },\n    handleMouseDown: function (b) {\n      a.resetMouseOver();\n      this.mouseIsOver = !0;\n      b && b.preventDefault && (this.panEventsEnabled ? b.preventDefault() : b.touches || b.preventDefault());\n    },\n    addLegend: function (e, d) {\n      e = a.processObject(e, a.AmLegend, this.theme);\n      e.divId = d;\n      e.ieW = 0;\n      var f;\n      f = \"object\" != typeof d && d ? document.getElementById(d) : d;\n      this.legend = e;\n      e.chart = this;\n      f ? (e.div = f, e.position = \"outside\", e.autoMargins = !1) : e.div = this.legendDiv;\n      return e;\n    },\n    removeLegend: function () {\n      this.legend = void 0;\n      this.previousWidth = 0;\n      this.legendDiv.innerHTML = \"\";\n    },\n    handleResize: function () {\n      (a.isPercents(this.width) || a.isPercents(this.height)) && this.invalidateSizeReal();\n      this.renderFix();\n    },\n    renderFix: function () {\n      if (!a.VML) {\n        var b = this.container;\n        b && b.renderFix();\n      }\n    },\n    getSVG: function () {\n      if (a.hasSVG) {\n        return this.container;\n      }\n    },\n    animate: function (i, d, n, m, l, k, j) {\n      i[\"an_\" + d] && a.removeFromArray(this.animations, i[\"an_\" + d]);\n      n = {\n        obj: i,\n        frame: 0,\n        attribute: d,\n        from: n,\n        to: m,\n        time: l,\n        effect: k,\n        suffix: j\n      };\n      i[\"an_\" + d] = n;\n      this.animations.push(n);\n      return n;\n    },\n    setLegendData: function (d) {\n      var c = this.legend;\n      c && c.setData(d);\n    },\n    stopAnim: function (b) {\n      a.removeFromArray(this.animations, b);\n    },\n    updateAnimations: function () {\n      var i;\n      this.container && this.container.update();\n      if (this.animations) {\n        for (i = this.animations.length - 1; 0 <= i; i--) {\n          var d = this.animations[i],\n            p = a.updateRate * d.time,\n            o = d.frame + 1,\n            n = d.obj,\n            m = d.attribute;\n          if (o <= p) {\n            d.frame++;\n            var l = Number(d.from),\n              j = Number(d.to) - l,\n              p = a[d.effect](0, o, l, j, p);\n            0 === j ? (this.animations.splice(i, 1), n.node.style[m] = Number(d.to) + d.suffix) : n.node.style[m] = p + d.suffix;\n          } else {\n            n.node.style[m] = Number(d.to) + d.suffix, n.animationFinished = !0, this.animations.splice(i, 1);\n          }\n        }\n      }\n    },\n    update: function () {\n      this.updateAnimations();\n      var f = this.animatable;\n      if (0 < f.length) {\n        for (var d = !0, h = f.length - 1; 0 <= h; h--) {\n          var g = f[h];\n          g && (g.animationFinished ? f.splice(h, 1) : d = !1);\n        }\n        d && (this.fire({\n          type: \"animationFinished\",\n          chart: this\n        }), this.animatable = []);\n      }\n    },\n    inIframe: function () {\n      try {\n        return window.self !== window.top;\n      } catch (b) {\n        return !0;\n      }\n    },\n    brr: function () {\n      if (!this.hideCredits) {\n        var t = \"amcharts.com\",\n          s = window.location.hostname.split(\".\"),\n          r;\n        2 <= s.length && (r = s[s.length - 2] + \".\" + s[s.length - 1]);\n        this.amLink && (s = this.amLink.parentNode) && s.removeChild(this.amLink);\n        s = this.creditsPosition;\n        if (r != t || !0 === this.inIframe()) {\n          var t = \"http://www.\" + t,\n            p = r = 0,\n            q = this.realWidth,\n            o = this.realHeight,\n            n = this.type;\n          if (\"serial\" == n || \"xy\" == n || \"gantt\" == n) {\n            r = this.marginLeftReal, p = this.marginTopReal, q = r + this.plotAreaWidth, o = p + this.plotAreaHeight;\n          }\n          var n = t + \"/javascript-charts/\",\n            j = \"JavaScript charts\",\n            i = \"JS chart by amCharts\";\n          \"ammap\" == this.product && (n = t + \"/javascript-maps/\", j = \"Interactive JavaScript maps\", i = \"JS map by amCharts\");\n          t = document.createElement(\"a\");\n          i = document.createTextNode(i);\n          t.setAttribute(\"href\", n);\n          t.setAttribute(\"title\", j);\n          this.urlTarget && t.setAttribute(\"target\", this.urlTarget);\n          t.appendChild(i);\n          this.chartDiv.appendChild(t);\n          this.amLink = t;\n          n = t.style;\n          n.position = \"absolute\";\n          n.textDecoration = \"none\";\n          n.color = this.color;\n          n.fontFamily = this.fontFamily;\n          n.fontSize = \"11px\";\n          n.opacity = 0.7;\n          n.display = \"block\";\n          var j = t.offsetWidth,\n            t = t.offsetHeight,\n            i = 5 + r,\n            f = p + 5;\n          \"bottom-left\" == s && (i = 5 + r, f = o - t - 3);\n          \"bottom-right\" == s && (i = q - j - 5, f = o - t - 3);\n          \"top-right\" == s && (i = q - j - 5, f = p + 5);\n          n.left = i + \"px\";\n          n.top = f + \"px\";\n        }\n      }\n    }\n  });\n  a.Slice = a.Class({\n    construct: function () {}\n  });\n  a.SerialDataItem = a.Class({\n    construct: function () {}\n  });\n  a.GraphDataItem = a.Class({\n    construct: function () {}\n  });\n  a.Guide = a.Class({\n    construct: function (b) {\n      this.cname = \"Guide\";\n      a.applyTheme(this, b, this.cname);\n    }\n  });\n  a.Title = a.Class({\n    construct: function (b) {\n      this.cname = \"Title\";\n      a.applyTheme(this, b, this.cname);\n    }\n  });\n  a.Label = a.Class({\n    construct: function (b) {\n      this.cname = \"Label\";\n      a.applyTheme(this, b, this.cname);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmBalloon = a.Class({\n    construct: function (b) {\n      this.cname = \"AmBalloon\";\n      this.enabled = !0;\n      this.fillColor = \"#FFFFFF\";\n      this.fillAlpha = 0.8;\n      this.borderThickness = 2;\n      this.borderColor = \"#FFFFFF\";\n      this.borderAlpha = 1;\n      this.cornerRadius = 0;\n      this.maxWidth = 220;\n      this.horizontalPadding = 8;\n      this.verticalPadding = 4;\n      this.pointerWidth = 6;\n      this.pointerOrientation = \"V\";\n      this.color = \"#000000\";\n      this.adjustBorderColor = !0;\n      this.show = this.follow = this.showBullet = !1;\n      this.bulletSize = 3;\n      this.shadowAlpha = 0.4;\n      this.shadowColor = \"#000000\";\n      this.fadeOutDuration = this.animationDuration = 0.3;\n      this.fixedPosition = !0;\n      this.offsetY = 6;\n      this.offsetX = 1;\n      this.textAlign = \"center\";\n      this.disableMouseEvents = !0;\n      this.deltaSignX = this.deltaSignY = 1;\n      a.isModern || (this.offsetY *= 1.5);\n      this.sdy = this.sdx = 0;\n      a.applyTheme(this, b, this.cname);\n    },\n    draw: function () {\n      var al = this.pointToX,\n        ak = this.pointToY;\n      a.isModern || (this.drop = !1);\n      var aj = this.chart;\n      a.VML && (this.fadeOutDuration = 0);\n      this.xAnim && aj.stopAnim(this.xAnim);\n      this.yAnim && aj.stopAnim(this.yAnim);\n      this.sdy = this.sdx = 0;\n      if (!isNaN(al)) {\n        var ai = this.follow,\n          ah = aj.container,\n          ag = this.set;\n        a.remove(ag);\n        this.removeDiv();\n        ag = ah.set();\n        ag.node.style.pointerEvents = \"none\";\n        this.set = ag;\n        this.mainSet ? (this.mainSet.push(this.set), this.sdx = this.mainSet.x, this.sdy = this.mainSet.y) : aj.balloonsSet.push(ag);\n        if (this.show) {\n          var af = this.l,\n            ae = this.t,\n            ad = this.r,\n            ac = this.b,\n            ab = this.balloonColor,\n            aa = this.fillColor,\n            T = this.borderColor,\n            W = aa;\n          void 0 != ab && (this.adjustBorderColor ? W = T = ab : aa = ab);\n          var Y = this.horizontalPadding,\n            s = this.verticalPadding,\n            X = this.pointerWidth,\n            R = this.pointerOrientation,\n            N = this.cornerRadius,\n            P = aj.fontFamily,\n            Z = this.fontSize;\n          void 0 == Z && (Z = aj.fontSize);\n          var ab = document.createElement(\"div\"),\n            V = aj.classNamePrefix;\n          ab.className = V + \"-balloon-div\";\n          this.className && (ab.className = ab.className + \" \" + V + \"-balloon-div-\" + this.className);\n          V = ab.style;\n          this.disableMouseEvents && (V.pointerEvents = \"none\");\n          V.position = \"absolute\";\n          var I = this.minWidth,\n            j = document.createElement(\"div\");\n          ab.appendChild(j);\n          var Q = j.style;\n          isNaN(I) || (Q.minWidth = I - 2 * Y + \"px\");\n          Q.textAlign = this.textAlign;\n          Q.maxWidth = this.maxWidth + \"px\";\n          Q.fontSize = Z + \"px\";\n          Q.color = this.color;\n          Q.fontFamily = P;\n          j.innerHTML = this.text;\n          aj.chartDiv.appendChild(ab);\n          this.textDiv = ab;\n          var Q = ab.offsetWidth,\n            S = ab.offsetHeight;\n          ab.clientHeight && (Q = ab.clientWidth, S = ab.clientHeight);\n          P = S + 2 * s;\n          j = Q + 2 * Y;\n          !isNaN(I) && j < I && (j = I);\n          window.opera && (P += 2);\n          var M = !1,\n            Z = this.offsetY;\n          aj.handDrawn && (Z += aj.handDrawScatter + 2);\n          \"H\" != R ? (I = al - j / 2, ak < ae + P + 10 && \"down\" != R ? (M = !0, ai && (ak += Z), Z = ak + X, this.deltaSignY = -1) : (ai && (ak -= Z), Z = ak - P - X, this.deltaSignY = 1)) : (2 * X > P && (X = P / 2), Z = ak - P / 2, al < af + (ad - af) / 2 ? (I = al + X, this.deltaSignX = -1) : (I = al - j - X, this.deltaSignX = 1));\n          Z + P >= ac && (Z = ac - P);\n          Z < ae && (Z = ae);\n          I < af && (I = af);\n          I + j > ad && (I = ad - j);\n          var ae = Z + s,\n            ac = I + Y,\n            O = this.shadowAlpha,\n            U = this.shadowColor,\n            Y = this.borderThickness,\n            i = this.bulletSize,\n            o,\n            s = this.fillAlpha,\n            d = this.borderAlpha;\n          this.showBullet && (o = a.circle(ah, i, W, s), ag.push(o));\n          this.drop ? (af = j / 1.6, ad = 0, \"V\" == R && (R = \"down\"), \"H\" == R && (R = \"left\"), \"down\" == R && (I = al + 1, Z = ak - af - af / 3), \"up\" == R && (ad = 180, I = al + 1, Z = ak + af + af / 3), \"left\" == R && (ad = 270, I = al + af + af / 3 + 2, Z = ak), \"right\" == R && (ad = 90, I = al - af - af / 3 + 2, Z = ak), ae = Z - S / 2 + 1, ac = I - Q / 2 - 1, aa = a.drop(ah, af, ad, aa, s, Y, T, d)) : 0 < N || 0 === X ? (0 < O && (al = a.rect(ah, j, P, aa, 0, Y + 1, U, O, N), a.isModern ? al.translate(1, 1) : al.translate(4, 4), ag.push(al)), aa = a.rect(ah, j, P, aa, s, Y, T, d, N)) : (W = [], N = [], \"H\" != R ? (af = al - I, af > j - X && (af = j - X), af < X && (af = X), W = [0, af - X, al - I, af + X, j, j, 0, 0], N = M ? [0, 0, ak - Z, 0, 0, P, P, 0] : [P, P, ak - Z, P, P, 0, 0, P]) : (R = ak - Z, R > P - X && (R = P - X), R < X && (R = X), N = [0, R - X, ak - Z, R + X, P, P, 0, 0], W = al < af + (ad - af) / 2 ? [0, 0, I < al ? 0 : al - I, 0, 0, j, j, 0] : [j, j, I + j > al ? j : al - I, j, j, 0, 0, j]), 0 < O && (al = a.polygon(ah, W, N, aa, 0, Y, U, O), al.translate(1, 1), ag.push(al)), aa = a.polygon(ah, W, N, aa, s, Y, T, d));\n          this.bg = aa;\n          ag.push(aa);\n          aa.toFront();\n          a.setCN(aj, aa, \"balloon-bg\");\n          this.className && a.setCN(aj, aa, \"balloon-bg-\" + this.className);\n          ah = 1 * this.deltaSignX;\n          ac += this.sdx;\n          ae += this.sdy;\n          V.left = ac + \"px\";\n          V.top = ae + \"px\";\n          ag.translate(I - ah, Z, 1, !0);\n          aa = aa.getBBox();\n          this.bottom = Z + P + 1;\n          this.yPos = aa.y + Z;\n          o && o.translate(this.pointToX - I + ah, ak - Z);\n          ak = this.animationDuration;\n          0 < this.animationDuration && !ai && !isNaN(this.prevX) && (ag.translate(this.prevX, this.prevY, NaN, !0), ag.animate({\n            translate: I - ah + \",\" + Z\n          }, ak, \"easeOutSine\"), ab && (V.left = this.prevTX + \"px\", V.top = this.prevTY + \"px\", this.xAnim = aj.animate({\n            node: ab\n          }, \"left\", this.prevTX, ac, ak, \"easeOutSine\", \"px\"), this.yAnim = aj.animate({\n            node: ab\n          }, \"top\", this.prevTY, ae, ak, \"easeOutSine\", \"px\")));\n          this.prevX = I - ah;\n          this.prevY = Z;\n          this.prevTX = ac;\n          this.prevTY = ae;\n        }\n      }\n    },\n    fixPrevious: function () {\n      this.rPrevX = this.prevX;\n      this.rPrevY = this.prevY;\n      this.rPrevTX = this.prevTX;\n      this.rPrevTY = this.prevTY;\n    },\n    restorePrevious: function () {\n      this.prevX = this.rPrevX;\n      this.prevY = this.rPrevY;\n      this.prevTX = this.rPrevTX;\n      this.prevTY = this.rPrevTY;\n    },\n    followMouse: function () {\n      if (this.follow && this.show) {\n        var g = this.chart.mouseX - this.offsetX * this.deltaSignX - this.sdx,\n          f = this.chart.mouseY - this.sdy;\n        this.pointToX = g;\n        this.pointToY = f;\n        if (g != this.previousX || f != this.previousY) {\n          if (this.previousX = g, this.previousY = f, 0 === this.cornerRadius) {\n            this.draw();\n          } else {\n            var j = this.set;\n            if (j) {\n              var h = j.getBBox(),\n                g = g - h.width / 2,\n                i = f - h.height - 10;\n              g < this.l && (g = this.l);\n              g > this.r - h.width && (g = this.r - h.width);\n              i < this.t && (i = f + 10);\n              j.translate(g, i);\n              f = this.textDiv.style;\n              f.left = g + this.horizontalPadding + \"px\";\n              f.top = i + this.verticalPadding + \"px\";\n            }\n          }\n        }\n      }\n    },\n    changeColor: function (b) {\n      this.balloonColor = b;\n    },\n    setBounds: function (f, d, h, g) {\n      this.l = f;\n      this.t = d;\n      this.r = h;\n      this.b = g;\n      this.destroyTO && clearTimeout(this.destroyTO);\n    },\n    showBalloon: function (b) {\n      if (this.text != b || this.positionChanged) {\n        this.text = b, this.isHiding = !1, this.show = !0, this.destroyTO && clearTimeout(this.destroyTO), b = this.chart, this.fadeAnim1 && b.stopAnim(this.fadeAnim1), this.fadeAnim2 && b.stopAnim(this.fadeAnim2), this.draw(), this.positionChanged = !1;\n      }\n    },\n    hide: function (f) {\n      var d = this;\n      d.text = void 0;\n      isNaN(f) && (f = d.fadeOutDuration);\n      var h = d.chart;\n      if (0 < f && !d.isHiding) {\n        d.isHiding = !0;\n        d.destroyTO && clearTimeout(d.destroyTO);\n        d.destroyTO = setTimeout(function () {\n          d.destroy.call(d);\n        }, 1000 * f);\n        d.follow = !1;\n        d.show = !1;\n        var g = d.set;\n        g && (g.setAttr(\"opacity\", d.fillAlpha), d.fadeAnim1 = g.animate({\n          opacity: 0\n        }, f, \"easeInSine\"));\n        d.textDiv && (d.fadeAnim2 = h.animate({\n          node: d.textDiv\n        }, \"opacity\", 1, 0, f, \"easeInSine\", \"\"));\n      } else {\n        d.show = !1, d.follow = !1, d.destroy();\n      }\n    },\n    setPosition: function (d, c) {\n      if (d != this.pointToX || c != this.pointToY) {\n        this.previousX = this.pointToX, this.previousY = this.pointToY, this.pointToX = d, this.pointToY = c, this.positionChanged = !0;\n      }\n    },\n    followCursor: function (f) {\n      var d = this;\n      d.follow = f;\n      clearInterval(d.interval);\n      var h = d.chart.mouseX - d.sdx,\n        g = d.chart.mouseY - d.sdy;\n      !isNaN(h) && f && (d.pointToX = h - d.offsetX * d.deltaSignX, d.pointToY = g, d.followMouse(), d.interval = setInterval(function () {\n        d.followMouse.call(d);\n      }, 40));\n    },\n    removeDiv: function () {\n      if (this.textDiv) {\n        var b = this.textDiv.parentNode;\n        b && b.removeChild(this.textDiv);\n      }\n    },\n    destroy: function () {\n      clearInterval(this.interval);\n      a.remove(this.set);\n      this.removeDiv();\n      this.set = null;\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.circle = function (r, q, p, o, n, m, j, i, d) {\n    0 >= q && (q = 0.001);\n    if (void 0 == n || 0 === n) {\n      n = 0.01;\n    }\n    void 0 === m && (m = \"#000000\");\n    void 0 === j && (j = 0);\n    o = {\n      fill: p,\n      stroke: m,\n      \"fill-opacity\": o,\n      \"stroke-width\": n,\n      \"stroke-opacity\": j\n    };\n    r = isNaN(d) ? r.circle(0, 0, q).attr(o) : r.ellipse(0, 0, q, d).attr(o);\n    i && r.gradient(\"radialGradient\", [p, a.adjustLuminosity(p, -0.6)]);\n    return r;\n  };\n  a.text = function (i, d, p, o, n, m, l, j) {\n    m || (m = \"middle\");\n    \"right\" == m && (m = \"end\");\n    \"left\" == m && (m = \"start\");\n    isNaN(j) && (j = 1);\n    void 0 !== d && (d = String(d), a.isIE && !a.isModern && (d = d.replace(\"&amp;\", \"&\"), d = d.replace(\"&\", \"&amp;\")));\n    p = {\n      fill: p,\n      \"font-family\": o,\n      \"font-size\": n + \"px\",\n      opacity: j\n    };\n    !0 === l && (p[\"font-weight\"] = \"bold\");\n    p[\"text-anchor\"] = m;\n    return i.text(d, p);\n  };\n  a.polygon = function (A, z, y, x, w, v, u, s, q, o, j) {\n    isNaN(v) && (v = 0.01);\n    isNaN(s) && (s = w);\n    var i = x,\n      B = !1;\n    \"object\" == typeof i && 1 < i.length && (B = !0, i = i[0]);\n    void 0 === u && (u = i);\n    w = {\n      fill: i,\n      stroke: u,\n      \"fill-opacity\": w,\n      \"stroke-width\": v,\n      \"stroke-opacity\": s\n    };\n    void 0 !== j && 0 < j && (w[\"stroke-dasharray\"] = j);\n    j = a.dx;\n    v = a.dy;\n    A.handDrawn && (y = a.makeHD(z, y, A.handDrawScatter), z = y[0], y = y[1]);\n    u = Math.round;\n    o && (z[d] = a.roundTo(z[d], 5), y[d] = a.roundTo(y[d], 5), u = Number);\n    s = \"M\" + (u(z[0]) + j) + \",\" + (u(y[0]) + v);\n    for (var d = 1; d < z.length; d++) {\n      o && (z[d] = a.roundTo(z[d], 5), y[d] = a.roundTo(y[d], 5)), s += \" L\" + (u(z[d]) + j) + \",\" + (u(y[d]) + v);\n    }\n    A = A.path(s + \" Z\").attr(w);\n    B && A.gradient(\"linearGradient\", x, q);\n    return A;\n  };\n  a.rect = function (C, B, A, z, y, x, w, v, u, s, o) {\n    if (isNaN(B) || isNaN(A)) {\n      return C.set();\n    }\n    isNaN(x) && (x = 0);\n    void 0 === u && (u = 0);\n    void 0 === s && (s = 270);\n    isNaN(y) && (y = 0);\n    var j = z,\n      D = !1;\n    \"object\" == typeof j && (j = j[0], D = !0);\n    void 0 === w && (w = j);\n    void 0 === v && (v = y);\n    B = Math.round(B);\n    A = Math.round(A);\n    var d = 0,\n      i = 0;\n    0 > B && (B = Math.abs(B), d = -B);\n    0 > A && (A = Math.abs(A), i = -A);\n    d += a.dx;\n    i += a.dy;\n    y = {\n      fill: j,\n      stroke: w,\n      \"fill-opacity\": y,\n      \"stroke-opacity\": v\n    };\n    void 0 !== o && 0 < o && (y[\"stroke-dasharray\"] = o);\n    C = C.rect(d, i, B, A, u, x).attr(y);\n    D && C.gradient(\"linearGradient\", z, s);\n    return C;\n  };\n  a.bullet = function (A, z, y, x, w, v, u, s, q, o, j, i, B) {\n    var d;\n    \"circle\" == z && (z = \"round\");\n    switch (z) {\n      case \"round\":\n        d = a.circle(A, y / 2, x, w, v, u, s);\n        break;\n      case \"square\":\n        d = a.polygon(A, [-y / 2, y / 2, y / 2, -y / 2], [y / 2, y / 2, -y / 2, -y / 2], x, w, v, u, s, o - 180, void 0, B);\n        break;\n      case \"rectangle\":\n        d = a.polygon(A, [-y, y, y, -y], [y / 2, y / 2, -y / 2, -y / 2], x, w, v, u, s, o - 180, void 0, B);\n        break;\n      case \"diamond\":\n        d = a.polygon(A, [-y / 2, 0, y / 2, 0], [0, -y / 2, 0, y / 2], x, w, v, u, s);\n        break;\n      case \"triangleUp\":\n        d = a.triangle(A, y, 0, x, w, v, u, s);\n        break;\n      case \"triangleDown\":\n        d = a.triangle(A, y, 180, x, w, v, u, s);\n        break;\n      case \"triangleLeft\":\n        d = a.triangle(A, y, 270, x, w, v, u, s);\n        break;\n      case \"triangleRight\":\n        d = a.triangle(A, y, 90, x, w, v, u, s);\n        break;\n      case \"bubble\":\n        d = a.circle(A, y / 2, x, w, v, u, s, !0);\n        break;\n      case \"line\":\n        d = a.line(A, [-y / 2, y / 2], [0, 0], x, w, v, u, s);\n        break;\n      case \"yError\":\n        d = A.set();\n        d.push(a.line(A, [0, 0], [-y / 2, y / 2], x, w, v));\n        d.push(a.line(A, [-q, q], [-y / 2, -y / 2], x, w, v));\n        d.push(a.line(A, [-q, q], [y / 2, y / 2], x, w, v));\n        break;\n      case \"xError\":\n        d = A.set(), d.push(a.line(A, [-y / 2, y / 2], [0, 0], x, w, v)), d.push(a.line(A, [-y / 2, -y / 2], [-q, q], x, w, v)), d.push(a.line(A, [y / 2, y / 2], [-q, q], x, w, v));\n    }\n    d && d.pattern(j, NaN, i);\n    return d;\n  };\n  a.triangle = function (r, q, p, n, o, m, j, i) {\n    if (void 0 === m || 0 === m) {\n      m = 1;\n    }\n    void 0 === j && (j = \"#000\");\n    void 0 === i && (i = 0);\n    n = {\n      fill: n,\n      stroke: j,\n      \"fill-opacity\": o,\n      \"stroke-width\": m,\n      \"stroke-opacity\": i\n    };\n    q /= 2;\n    var f;\n    0 === p && (f = \" M\" + -q + \",\" + q + \" L0,\" + -q + \" L\" + q + \",\" + q + \" Z\");\n    180 == p && (f = \" M\" + -q + \",\" + -q + \" L0,\" + q + \" L\" + q + \",\" + -q + \" Z\");\n    90 == p && (f = \" M\" + -q + \",\" + -q + \" L\" + q + \",0 L\" + -q + \",\" + q + \" Z\");\n    270 == p && (f = \" M\" + -q + \",0 L\" + q + \",\" + q + \" L\" + q + \",\" + -q + \" Z\");\n    return r.path(f).attr(n);\n  };\n  a.line = function (v, u, t, s, r, q, p, o, j, i, d) {\n    if (v.handDrawn && !d) {\n      return a.handDrawnLine(v, u, t, s, r, q, p, o, j, i, d);\n    }\n    q = {\n      fill: \"none\",\n      \"stroke-width\": q\n    };\n    void 0 !== p && 0 < p && (q[\"stroke-dasharray\"] = p);\n    isNaN(r) || (q[\"stroke-opacity\"] = r);\n    s && (q.stroke = s);\n    s = Math.round;\n    i && (s = Number, u[0] = a.roundTo(u[0], 5), t[0] = a.roundTo(t[0], 5));\n    i = a.dx;\n    r = a.dy;\n    p = \"M\" + (s(u[0]) + i) + \",\" + (s(t[0]) + r);\n    for (o = 1; o < u.length; o++) {\n      u[o] = a.roundTo(u[o], 5), t[o] = a.roundTo(t[o], 5), p += \" L\" + (s(u[o]) + i) + \",\" + (s(t[o]) + r);\n    }\n    if (a.VML) {\n      return v.path(p, void 0, !0).attr(q);\n    }\n    j && (p += \" M0,0 L0,0\");\n    return v.path(p).attr(q);\n  };\n  a.makeHD = function (y, x, w) {\n    for (var u = [], v = [], s = 1; s < y.length; s++) {\n      for (var r = Number(y[s - 1]), q = Number(x[s - 1]), o = Number(y[s]), j = Number(x[s]), i = Math.round(Math.sqrt(Math.pow(o - r, 2) + Math.pow(j - q, 2)) / 50) + 1, o = (o - r) / i, j = (j - q) / i, f = 0; f <= i; f++) {\n        var z = q + f * j + Math.random() * w;\n        u.push(r + f * o + Math.random() * w);\n        v.push(z);\n      }\n    }\n    return [u, v];\n  };\n  a.handDrawnLine = function (C, B, A, z, y, x, w, v, u, s) {\n    var o,\n      j = C.set();\n    for (o = 1; o < B.length; o++) {\n      for (var D = [B[o - 1], B[o]], d = [A[o - 1], A[o]], d = a.makeHD(D, d, C.handDrawScatter), D = d[0], d = d[1], i = 1; i < D.length; i++) {\n        j.push(a.line(C, [D[i - 1], D[i]], [d[i - 1], d[i]], z, y, x + Math.random() * C.handDrawThickness - C.handDrawThickness / 2, w, v, u, s, !0));\n      }\n    }\n    return j;\n  };\n  a.doNothing = function (b) {\n    return b;\n  };\n  a.drop = function (G, F, D, A, C, z, x, w) {\n    var v = 1 / 180 * Math.PI,\n      u = D - 20,\n      s = Math.sin(u * v) * F,\n      o = Math.cos(u * v) * F,\n      H = Math.sin((u + 40) * v) * F,\n      f = Math.cos((u + 40) * v) * F,\n      i = 0.8 * F,\n      E = -F / 3,\n      j = F / 3;\n    0 === D && (E = -E, j = 0);\n    180 == D && (j = 0);\n    90 == D && (E = 0);\n    270 == D && (E = 0, j = -j);\n    D = {\n      fill: A,\n      stroke: x,\n      \"stroke-width\": z,\n      \"stroke-opacity\": w,\n      \"fill-opacity\": C\n    };\n    F = \"M\" + s + \",\" + o + \" A\" + F + \",\" + F + \",0,1,1,\" + H + \",\" + f + (\" A\" + i + \",\" + i + \",0,0,0,\" + (Math.sin((u + 20) * v) * F + j) + \",\" + (Math.cos((u + 20) * v) * F + E));\n    F += \" A\" + i + \",\" + i + \",0,0,0,\" + s + \",\" + o;\n    return G.path(F, void 0, void 0, \"1000,1000\").attr(D);\n  };\n  a.wedge = function (al, ak, aj, ai, ah, ag, af, ae, ad, ac, ab, aa, T, W) {\n    var Y = Math.round;\n    ag = Y(ag);\n    af = Y(af);\n    ae = Y(ae);\n    var s = Y(af / ag * ae),\n      X = a.VML,\n      R = 359.5 + ag / 100;\n    359.94 < R && (R = 359.94);\n    ah >= R && (ah = R);\n    var N = 1 / 180 * Math.PI,\n      R = ak + Math.sin(ai * N) * ae,\n      P = aj - Math.cos(ai * N) * s,\n      Z = ak + Math.sin(ai * N) * ag,\n      V = aj - Math.cos(ai * N) * af,\n      I = ak + Math.sin((ai + ah) * N) * ag,\n      j = aj - Math.cos((ai + ah) * N) * af,\n      Q = ak + Math.sin((ai + ah) * N) * ae,\n      N = aj - Math.cos((ai + ah) * N) * s,\n      S = {\n        fill: a.adjustLuminosity(ac.fill, -0.2),\n        \"stroke-opacity\": 0,\n        \"fill-opacity\": ac[\"fill-opacity\"]\n      },\n      M = 0;\n    180 < Math.abs(ah) && (M = 1);\n    ai = al.set();\n    var O;\n    X && (R = Y(10 * R), Z = Y(10 * Z), I = Y(10 * I), Q = Y(10 * Q), P = Y(10 * P), V = Y(10 * V), j = Y(10 * j), N = Y(10 * N), ak = Y(10 * ak), ad = Y(10 * ad), aj = Y(10 * aj), ag *= 10, af *= 10, ae *= 10, s *= 10, 1 > Math.abs(ah) && 1 >= Math.abs(I - Z) && 1 >= Math.abs(j - V) && (O = !0));\n    ah = \"\";\n    var U;\n    aa && (S[\"fill-opacity\"] = 0, S[\"stroke-opacity\"] = ac[\"stroke-opacity\"] / 2, S.stroke = ac.stroke);\n    if (0 < ad) {\n      U = \" M\" + R + \",\" + (P + ad) + \" L\" + Z + \",\" + (V + ad);\n      X ? (O || (U += \" A\" + (ak - ag) + \",\" + (ad + aj - af) + \",\" + (ak + ag) + \",\" + (ad + aj + af) + \",\" + Z + \",\" + (V + ad) + \",\" + I + \",\" + (j + ad)), U += \" L\" + Q + \",\" + (N + ad), 0 < ae && (O || (U += \" B\" + (ak - ae) + \",\" + (ad + aj - s) + \",\" + (ak + ae) + \",\" + (ad + aj + s) + \",\" + Q + \",\" + (ad + N) + \",\" + R + \",\" + (ad + P)))) : (U += \" A\" + ag + \",\" + af + \",0,\" + M + \",1,\" + I + \",\" + (j + ad) + \" L\" + Q + \",\" + (N + ad), 0 < ae && (U += \" A\" + ae + \",\" + s + \",0,\" + M + \",0,\" + R + \",\" + (P + ad)));\n      U += \" Z\";\n      var i = ad;\n      X && (i /= 10);\n      for (var o = 0; o < i; o += 10) {\n        var d = al.path(U, void 0, void 0, \"1000,1000\").attr(S);\n        ai.push(d);\n        d.translate(0, -o);\n      }\n      U = al.path(\" M\" + R + \",\" + P + \" L\" + R + \",\" + (P + ad) + \" L\" + Z + \",\" + (V + ad) + \" L\" + Z + \",\" + V + \" L\" + R + \",\" + P + \" Z\", void 0, void 0, \"1000,1000\").attr(S);\n      ad = al.path(\" M\" + I + \",\" + j + \" L\" + I + \",\" + (j + ad) + \" L\" + Q + \",\" + (N + ad) + \" L\" + Q + \",\" + N + \" L\" + I + \",\" + j + \" Z\", void 0, void 0, \"1000,1000\").attr(S);\n      ai.push(U);\n      ai.push(ad);\n    }\n    X ? (O || (ah = \" A\" + Y(ak - ag) + \",\" + Y(aj - af) + \",\" + Y(ak + ag) + \",\" + Y(aj + af) + \",\" + Y(Z) + \",\" + Y(V) + \",\" + Y(I) + \",\" + Y(j)), af = \" M\" + Y(R) + \",\" + Y(P) + \" L\" + Y(Z) + \",\" + Y(V) + ah + \" L\" + Y(Q) + \",\" + Y(N)) : af = \" M\" + R + \",\" + P + \" L\" + Z + \",\" + V + (\" A\" + ag + \",\" + af + \",0,\" + M + \",1,\" + I + \",\" + j) + \" L\" + Q + \",\" + N;\n    0 < ae && (X ? O || (af += \" B\" + (ak - ae) + \",\" + (aj - s) + \",\" + (ak + ae) + \",\" + (aj + s) + \",\" + Q + \",\" + N + \",\" + R + \",\" + P) : af += \" A\" + ae + \",\" + s + \",0,\" + M + \",0,\" + R + \",\" + P);\n    al.handDrawn && (ae = a.line(al, [R, Z], [P, V], ac.stroke, ac.thickness * Math.random() * al.handDrawThickness, ac[\"stroke-opacity\"]), ai.push(ae));\n    al = al.path(af + \" Z\", void 0, void 0, \"1000,1000\").attr(ac);\n    if (ab) {\n      ae = [];\n      for (s = 0; s < ab.length; s++) {\n        ae.push(a.adjustLuminosity(ac.fill, ab[s]));\n      }\n      \"radial\" != W || a.isModern || (ae = []);\n      0 < ae.length && al.gradient(W + \"Gradient\", ae);\n    }\n    a.isModern && \"radial\" == W && al.grad && (al.grad.setAttribute(\"gradientUnits\", \"userSpaceOnUse\"), al.grad.setAttribute(\"r\", ag), al.grad.setAttribute(\"cx\", ak), al.grad.setAttribute(\"cy\", aj));\n    al.pattern(aa, NaN, T);\n    ai.wedge = al;\n    ai.push(al);\n    return ai;\n  };\n  a.rgb2hex = function (b) {\n    return (b = b.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i)) && 4 === b.length ? \"#\" + (\"0\" + parseInt(b[1], 10).toString(16)).slice(-2) + (\"0\" + parseInt(b[2], 10).toString(16)).slice(-2) + (\"0\" + parseInt(b[3], 10).toString(16)).slice(-2) : \"\";\n  };\n  a.adjustLuminosity = function (g, d) {\n    g && -1 != g.indexOf(\"rgb\") && (g = a.rgb2hex(g));\n    g = String(g).replace(/[^0-9a-f]/gi, \"\");\n    6 > g.length && (g = String(g[0]) + String(g[0]) + String(g[1]) + String(g[1]) + String(g[2]) + String(g[2]));\n    d = d || 0;\n    var j = \"#\",\n      i,\n      h;\n    for (h = 0; 3 > h; h++) {\n      i = parseInt(g.substr(2 * h, 2), 16), i = Math.round(Math.min(Math.max(0, i + i * d), 255)).toString(16), j += (\"00\" + i).substr(i.length);\n    }\n    return j;\n  };\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmLegend = a.Class({\n    construct: function (b) {\n      this.enabled = !0;\n      this.cname = \"AmLegend\";\n      this.createEvents(\"rollOverMarker\", \"rollOverItem\", \"rollOutMarker\", \"rollOutItem\", \"showItem\", \"hideItem\", \"clickMarker\", \"clickLabel\");\n      this.position = \"bottom\";\n      this.borderColor = this.color = \"#000000\";\n      this.borderAlpha = 0;\n      this.markerLabelGap = 5;\n      this.verticalGap = 10;\n      this.align = \"left\";\n      this.horizontalGap = 0;\n      this.spacing = 10;\n      this.markerDisabledColor = \"#AAB3B3\";\n      this.markerType = \"square\";\n      this.markerSize = 16;\n      this.markerBorderThickness = this.markerBorderAlpha = 1;\n      this.marginBottom = this.marginTop = 0;\n      this.marginLeft = this.marginRight = 20;\n      this.autoMargins = !0;\n      this.valueWidth = 50;\n      this.switchable = !0;\n      this.switchType = \"x\";\n      this.switchColor = \"#FFFFFF\";\n      this.rollOverColor = \"#CC0000\";\n      this.reversedOrder = !1;\n      this.labelText = \"[[title]]\";\n      this.valueText = \"[[value]]\";\n      this.accessibleLabel = \"[[title]]\";\n      this.useMarkerColorForLabels = !1;\n      this.rollOverGraphAlpha = 1;\n      this.textClickEnabled = !1;\n      this.equalWidths = !0;\n      this.backgroundColor = \"#FFFFFF\";\n      this.backgroundAlpha = 0;\n      this.useGraphSettings = !1;\n      this.showEntries = !0;\n      this.labelDx = 0;\n      a.applyTheme(this, b, this.cname);\n    },\n    setData: function (b) {\n      this.legendData = b;\n      this.invalidateSize();\n    },\n    invalidateSize: function () {\n      this.destroy();\n      this.entries = [];\n      this.valueLabels = [];\n      var b = this.legendData;\n      this.enabled && (a.ifArray(b) || a.ifArray(this.data)) && this.drawLegend();\n    },\n    drawLegend: function () {\n      var i = this.chart,\n        d = this.position,\n        p = this.width,\n        o = i.divRealWidth,\n        n = i.divRealHeight,\n        m = this.div,\n        l = this.legendData;\n      this.data && (l = this.combineLegend ? this.legendData.concat(this.data) : this.data);\n      isNaN(this.fontSize) && (this.fontSize = i.fontSize);\n      this.maxColumnsReal = this.maxColumns;\n      if (\"right\" == d || \"left\" == d) {\n        this.maxColumnsReal = 1, this.autoMargins && (this.marginLeft = this.marginRight = 10);\n      } else {\n        if (this.autoMargins) {\n          this.marginRight = i.marginRight;\n          this.marginLeft = i.marginLeft;\n          var j = i.autoMarginOffset;\n          \"bottom\" == d ? (this.marginBottom = j, this.marginTop = 0) : (this.marginTop = j, this.marginBottom = 0);\n        }\n      }\n      p = void 0 !== p ? a.toCoordinate(p, o) : \"right\" != d && \"left\" != d ? i.realWidth : 0 < this.ieW ? this.ieW : i.realWidth;\n      \"outside\" == d ? (p = m.offsetWidth, n = m.offsetHeight, m.clientHeight && (p = m.clientWidth, n = m.clientHeight)) : (isNaN(p) || (m.style.width = p + \"px\"), m.className = \"amChartsLegend \" + i.classNamePrefix + \"-legend-div\");\n      this.divWidth = p;\n      (d = this.container) ? (d.container.innerHTML = \"\", m.appendChild(d.container), d.width = p, d.height = n, d.setSize(p, n), d.addDefs(i)) : d = new a.AmDraw(m, p, n, i);\n      this.container = d;\n      this.lx = 0;\n      this.ly = 8;\n      n = this.markerSize;\n      n > this.fontSize && (this.ly = n / 2 - 1);\n      0 < n && (this.lx += n + this.markerLabelGap);\n      this.titleWidth = 0;\n      if (n = this.title) {\n        n = a.text(this.container, n, this.color, i.fontFamily, this.fontSize, \"start\", !0), a.setCN(i, n, \"legend-title\"), n.translate(this.marginLeft, this.marginTop + this.verticalGap + this.ly + 1), i = n.getBBox(), this.titleWidth = i.width + 15, this.titleHeight = i.height + 6;\n      }\n      this.index = this.maxLabelWidth = 0;\n      if (this.showEntries) {\n        for (i = 0; i < l.length; i++) {\n          this.createEntry(l[i]);\n        }\n        for (i = this.index = 0; i < l.length; i++) {\n          this.createValue(l[i]);\n        }\n      }\n      this.arrangeEntries();\n      this.updateValues();\n    },\n    arrangeEntries: function () {\n      var Z = this.position,\n        Y = this.marginLeft + this.titleWidth,\n        X = this.marginRight,\n        W = this.marginTop,\n        V = this.marginBottom,\n        U = this.horizontalGap,\n        T = this.div,\n        S = this.divWidth,\n        R = this.maxColumnsReal,\n        Q = this.verticalGap,\n        P = this.spacing,\n        O = S - X - Y,\n        I = 0,\n        K = 0,\n        M = this.container;\n      this.set && this.set.remove();\n      var i = M.set();\n      this.set = i;\n      var L = M.set();\n      i.push(L);\n      var G = this.entries,\n        o,\n        s;\n      for (s = 0; s < G.length; s++) {\n        o = G[s].getBBox();\n        var N = o.width;\n        N > I && (I = N);\n        o = o.height;\n        o > K && (K = o);\n      }\n      var N = K = 0,\n        J = U,\n        j = 0,\n        d = 0;\n      for (s = 0; s < G.length; s++) {\n        var D = G[s];\n        this.reversedOrder && (D = G[G.length - s - 1]);\n        o = D.getBBox();\n        var H;\n        this.equalWidths ? H = N * (I + P + this.markerLabelGap) : (H = J, J = J + o.width + U + P);\n        H + o.width > O && 0 < s && 0 !== N && (K++, H = N = 0, J = H + o.width + U + P, j = j + d + Q, d = 0);\n        o.height > d && (d = o.height);\n        D.translate(H, j);\n        N++;\n        !isNaN(R) && N >= R && (N = 0, K++, j = j + d + Q, J = U, d = 0);\n        L.push(D);\n      }\n      o = L.getBBox();\n      R = o.height + 2 * Q - 1;\n      \"left\" == Z || \"right\" == Z ? (P = o.width + 2 * U, S = P + Y + X, T.style.width = S + \"px\", this.ieW = S) : P = S - Y - X - 1;\n      X = a.polygon(this.container, [0, P, P, 0], [0, 0, R, R], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);\n      a.setCN(this.chart, X, \"legend-bg\");\n      i.push(X);\n      i.translate(Y, W);\n      X.toBack();\n      Y = U;\n      if (\"top\" == Z || \"bottom\" == Z || \"absolute\" == Z || \"outside\" == Z) {\n        \"center\" == this.align ? Y = U + (P - o.width) / 2 : \"right\" == this.align && (Y = U + P - o.width);\n      }\n      L.translate(Y, Q + 1);\n      this.titleHeight > R && (R = this.titleHeight);\n      W = R + W + V + 1;\n      0 > W && (W = 0);\n      \"absolute\" != Z && \"outside\" != Z && W > this.chart.divRealHeight && (T.style.top = \"0px\");\n      T.style.height = Math.round(W) + \"px\";\n      M.setSize(this.divWidth, W);\n    },\n    createEntry: function (L) {\n      if (!1 !== L.visibleInLegend && !L.hideFromLegend) {\n        var K = this,\n          J = K.chart,\n          I = K.useGraphSettings,\n          H = L.markerType;\n        H && (I = !1);\n        L.legendEntryWidth = K.markerSize;\n        H || (H = K.markerType);\n        var G = L.color,\n          F = L.alpha;\n        L.legendKeyColor && (G = L.legendKeyColor());\n        L.legendKeyAlpha && (F = L.legendKeyAlpha());\n        var E;\n        !0 === L.hidden && (E = G = K.markerDisabledColor);\n        var D = L.pattern,\n          C,\n          A = L.customMarker;\n        A || (A = K.customMarker);\n        var z = K.container,\n          o = K.markerSize,\n          s = 0,\n          x = 0,\n          d = o / 2;\n        if (I) {\n          I = L.type;\n          K.switchType = void 0;\n          if (\"line\" == I || \"step\" == I || \"smoothedLine\" == I || \"ohlc\" == I) {\n            C = z.set(), L.hidden || (G = L.lineColorR, E = L.bulletBorderColorR), s = a.line(z, [0, 2 * o], [o / 2, o / 2], G, L.lineAlpha, L.lineThickness, L.dashLength), a.setCN(J, s, \"graph-stroke\"), C.push(s), L.bullet && (L.hidden || (G = L.bulletColorR), s = a.bullet(z, L.bullet, L.bulletSize, G, L.bulletAlpha, L.bulletBorderThickness, E, L.bulletBorderAlpha)) && (a.setCN(J, s, \"graph-bullet\"), s.translate(o + 1, o / 2), C.push(s)), d = 0, s = o, x = o / 3;\n          } else {\n            L.getGradRotation && (C = L.getGradRotation(), 0 === C && (C = 180));\n            s = L.fillColorsR;\n            !0 === L.hidden && (s = G);\n            if (C = K.createMarker(\"rectangle\", s, L.fillAlphas, L.lineThickness, G, L.lineAlpha, C, D, L.dashLength)) {\n              d = o, C.translate(d, o / 2);\n            }\n            s = o;\n          }\n          a.setCN(J, C, \"graph-\" + I);\n          a.setCN(J, C, \"graph-\" + L.id);\n        } else {\n          if (A) {\n            C = z.image(A, 0, 0, o, o);\n          } else {\n            var v;\n            isNaN(K.gradientRotation) || (v = 180 + K.gradientRotation);\n            (C = K.createMarker(H, G, F, void 0, void 0, void 0, v, D)) && C.translate(o / 2, o / 2);\n          }\n        }\n        a.setCN(J, C, \"legend-marker\");\n        K.addListeners(C, L);\n        z = z.set([C]);\n        K.switchable && L.switchable && z.setAttr(\"cursor\", \"pointer\");\n        void 0 !== L.id && a.setCN(J, z, \"legend-item-\" + L.id);\n        a.setCN(J, z, L.className, !0);\n        E = K.switchType;\n        var j;\n        E && \"none\" != E && 0 < o && (\"x\" == E ? (j = K.createX(), j.translate(o / 2, o / 2)) : j = K.createV(), j.dItem = L, !0 !== L.hidden ? \"x\" == E ? j.hide() : j.show() : \"x\" != E && j.hide(), K.switchable || j.hide(), K.addListeners(j, L), L.legendSwitch = j, z.push(j), a.setCN(J, j, \"legend-switch\"));\n        E = K.color;\n        L.showBalloon && K.textClickEnabled && void 0 !== K.selectedColor && (E = K.selectedColor);\n        K.useMarkerColorForLabels && !D && (E = G);\n        !0 === L.hidden && (E = K.markerDisabledColor);\n        G = a.massReplace(K.labelText, {\n          \"[[title]]\": L.title\n        });\n        void 0 !== K.tabIndex && (z.setAttr(\"tabindex\", K.tabIndex), z.setAttr(\"role\", \"menuitem\"), z.keyup(function (b) {\n          13 == b.keyCode && K.clickMarker(L, b);\n        }));\n        J.accessible && K.accessibleLabel && (D = a.massReplace(K.accessibleLabel, {\n          \"[[title]]\": L.title\n        }), J.makeAccessible(z, D));\n        D = K.fontSize;\n        C && (o <= D && (o = o / 2 + K.ly - D / 2 + (D + 2 - o) / 2 - x, C.translate(d, o), j && j.translate(j.x, o)), L.legendEntryWidth = C.getBBox().width);\n        var i;\n        G && (G = a.fixBrakes(G), L.legendTextReal = G, i = K.labelWidth, i = isNaN(i) ? a.text(K.container, G, E, J.fontFamily, D, \"start\") : a.wrappedText(K.container, G, E, J.fontFamily, D, \"start\", !1, i, 0), a.setCN(J, i, \"legend-label\"), i.translate(K.lx + s, K.ly), z.push(i), K.labelDx = s, J = i.getBBox().width, K.maxLabelWidth < J && (K.maxLabelWidth = J));\n        K.entries[K.index] = z;\n        L.legendEntry = K.entries[K.index];\n        L.legendMarker = C;\n        L.legendLabel = i;\n        K.index++;\n      }\n    },\n    addListeners: function (e, d) {\n      var f = this;\n      e && e.mouseover(function (b) {\n        f.rollOverMarker(d, b);\n      }).mouseout(function (b) {\n        f.rollOutMarker(d, b);\n      }).click(function (b) {\n        f.clickMarker(d, b);\n      });\n    },\n    rollOverMarker: function (d, c) {\n      this.switchable && this.dispatch(\"rollOverMarker\", d, c);\n      this.dispatch(\"rollOverItem\", d, c);\n    },\n    rollOutMarker: function (d, c) {\n      this.switchable && this.dispatch(\"rollOutMarker\", d, c);\n      this.dispatch(\"rollOutItem\", d, c);\n    },\n    clickMarker: function (d, c) {\n      this.switchable && (!0 === d.hidden ? this.dispatch(\"showItem\", d, c) : this.dispatch(\"hideItem\", d, c));\n      this.dispatch(\"clickMarker\", d, c);\n    },\n    rollOverLabel: function (d, c) {\n      d.hidden || this.textClickEnabled && d.legendLabel && d.legendLabel.attr({\n        fill: this.rollOverColor\n      });\n      this.dispatch(\"rollOverItem\", d, c);\n    },\n    rollOutLabel: function (e, d) {\n      if (!e.hidden && this.textClickEnabled && e.legendLabel) {\n        var f = this.color;\n        void 0 !== this.selectedColor && e.showBalloon && (f = this.selectedColor);\n        this.useMarkerColorForLabels && (f = e.lineColor, void 0 === f && (f = e.color));\n        e.legendLabel.attr({\n          fill: f\n        });\n      }\n      this.dispatch(\"rollOutItem\", e, d);\n    },\n    clickLabel: function (d, c) {\n      this.textClickEnabled ? d.hidden || this.dispatch(\"clickLabel\", d, c) : this.switchable && (!0 === d.hidden ? this.dispatch(\"showItem\", d, c) : this.dispatch(\"hideItem\", d, c));\n    },\n    dispatch: function (e, d, f) {\n      e = {\n        type: e,\n        dataItem: d,\n        target: this,\n        event: f,\n        chart: this.chart\n      };\n      this.chart && this.chart.handleLegendEvent(e);\n      this.fire(e);\n    },\n    createValue: function (r) {\n      var q = this,\n        p = q.fontSize,\n        o = q.chart;\n      if (!1 !== r.visibleInLegend && !r.hideFromLegend) {\n        var n = q.maxLabelWidth;\n        q.forceWidth && (n = q.labelWidth);\n        q.equalWidths || (q.valueAlign = \"left\");\n        \"left\" == q.valueAlign && r.legendLabel && (n = r.legendLabel.getBBox().width);\n        var m = n;\n        if (q.valueText && 0 < q.valueWidth) {\n          var j = q.color;\n          q.useMarkerColorForValues && (j = r.color, r.legendKeyColor && (j = r.legendKeyColor()));\n          !0 === r.hidden && (j = q.markerDisabledColor);\n          var i = q.valueText,\n            n = n + q.lx + q.labelDx + q.markerLabelGap + q.valueWidth,\n            d = \"end\";\n          \"left\" == q.valueAlign && (n -= q.valueWidth, d = \"start\");\n          j = a.text(q.container, i, j, q.chart.fontFamily, p, d);\n          a.setCN(o, j, \"legend-value\");\n          j.translate(n, q.ly);\n          q.entries[q.index].push(j);\n          m += q.valueWidth + 2 * q.markerLabelGap;\n          j.dItem = r;\n          q.valueLabels.push(j);\n        }\n        q.index++;\n        o = q.markerSize;\n        o < p + 7 && (o = p + 7, a.VML && (o += 3));\n        p = q.container.rect(r.legendEntryWidth, 0, m, o, 0, 0).attr({\n          stroke: \"none\",\n          fill: \"#fff\",\n          \"fill-opacity\": 0.005\n        });\n        p.dItem = r;\n        q.entries[q.index - 1].push(p);\n        p.mouseover(function (b) {\n          q.rollOverLabel(r, b);\n        }).mouseout(function (b) {\n          q.rollOutLabel(r, b);\n        }).click(function (b) {\n          q.clickLabel(r, b);\n        });\n      }\n    },\n    createV: function () {\n      var b = this.markerSize;\n      return a.polygon(this.container, [b / 5, b / 2, b - b / 5, b / 2], [b / 3, b - b / 5, b / 5, b / 1.7], this.switchColor);\n    },\n    createX: function () {\n      var f = (this.markerSize - 4) / 2,\n        d = {\n          stroke: this.switchColor,\n          \"stroke-width\": 3\n        },\n        h = this.container,\n        g = a.line(h, [-f, f], [-f, f]).attr(d),\n        f = a.line(h, [-f, f], [f, -f]).attr(d);\n      return this.container.set([g, f]);\n    },\n    createMarker: function (v, u, t, s, r, q, p, o, j) {\n      var i = this.markerSize,\n        d = this.container;\n      r || (r = this.markerBorderColor);\n      r || (r = u);\n      isNaN(s) && (s = this.markerBorderThickness);\n      isNaN(q) && (q = this.markerBorderAlpha);\n      return a.bullet(d, v, i, u, t, s, r, q, i, p, o, this.chart.path, j);\n    },\n    validateNow: function () {\n      this.invalidateSize();\n    },\n    updateValues: function () {\n      var v = this.valueLabels,\n        u = this.chart,\n        t,\n        s = this.data;\n      if (v) {\n        for (t = 0; t < v.length; t++) {\n          var r = v[t],\n            q = r.dItem;\n          q.periodDataItem = void 0;\n          q.periodPercentDataItem = void 0;\n          var p = \" \";\n          if (s) {\n            q.value ? r.text(q.value) : r.text(\"\");\n          } else {\n            var o = null;\n            if (void 0 !== q.type) {\n              var o = q.currentDataItem,\n                j = this.periodValueText;\n              q.legendPeriodValueText && (j = q.legendPeriodValueText);\n              q.legendPeriodValueTextR && (j = q.legendPeriodValueTextR);\n              o ? (p = this.valueText, q.legendValueText && (p = q.legendValueText), q.legendValueTextR && (p = q.legendValueTextR), p = u.formatString(p, o)) : j && u.formatPeriodString && (j = a.massReplace(j, {\n                \"[[title]]\": q.title\n              }), p = u.formatPeriodString(j, q));\n            } else {\n              p = u.formatString(this.valueText, q);\n            }\n            j = q;\n            o && (j = o);\n            var i = this.valueFunction;\n            i && (p = i(j, p, u.periodDataItem));\n            var d;\n            this.useMarkerColorForLabels && !o && q.lastDataItem && (o = q.lastDataItem);\n            o ? d = u.getBalloonColor(q, o) : q.legendKeyColor && (d = q.legendKeyColor());\n            q.legendColorFunction && (d = q.legendColorFunction(j, p, q.periodDataItem, q.periodPercentDataItem));\n            r.text(p);\n            if (!q.pattern && (this.useMarkerColorForValues && r.setAttr(\"fill\", d), this.useMarkerColorForLabels)) {\n              if (r = q.legendMarker) {\n                r.setAttr(\"fill\", d), r.setAttr(\"stroke\", d);\n              }\n              (q = q.legendLabel) && q.setAttr(\"fill\", d);\n            }\n          }\n        }\n      }\n    },\n    renderFix: function () {\n      if (!a.VML && this.enabled) {\n        var b = this.container;\n        b && b.renderFix();\n      }\n    },\n    destroy: function () {\n      this.div.innerHTML = \"\";\n      a.remove(this.set);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AmMap = a.Class({\n    inherits: a.AmChart,\n    construct: function (b) {\n      this.cname = \"AmMap\";\n      this.type = \"map\";\n      this.theme = b;\n      this.svgNotSupported = \"This browser doesn't support SVG. Use Chrome, Firefox, Internet Explorer 9 or later.\";\n      this.createEvents(\"rollOverMapObject\", \"rollOutMapObject\", \"clickMapObject\", \"mouseDownMapObject\", \"selectedObjectChanged\", \"homeButtonClicked\", \"zoomCompleted\", \"dragCompleted\", \"positionChanged\", \"writeDevInfo\", \"click\", \"descriptionClosed\");\n      this.zoomDuration = 0.6;\n      this.zoomControl = new a.ZoomControl(b);\n      this.fitMapToContainer = !0;\n      this.mouseWheelZoomEnabled = this.backgroundZoomsToTop = !1;\n      this.allowClickOnSelectedObject = this.useHandCursorOnClickableOjects = this.showBalloonOnSelectedObject = !0;\n      this.showObjectsAfterZoom = this.wheelBusy = !1;\n      this.zoomOnDoubleClick = this.useObjectColorForBalloon = !0;\n      this.allowMultipleDescriptionWindows = !1;\n      this.dragMap = this.centerMap = this.linesAboveImages = !0;\n      this.colorSteps = 5;\n      this.forceNormalize = !1;\n      this.showAreasInList = !0;\n      this.showLinesInList = this.showImagesInList = !1;\n      this.areasProcessor = new a.AreasProcessor(this);\n      this.areasSettings = new a.AreasSettings(b);\n      this.imagesProcessor = new a.ImagesProcessor(this);\n      this.imagesSettings = new a.ImagesSettings(b);\n      this.linesProcessor = new a.LinesProcessor(this);\n      this.linesSettings = new a.LinesSettings(b);\n      this.initialTouchZoom = 1;\n      this.showDescriptionOnHover = !1;\n      a.AmMap.base.construct.call(this, b);\n      this.creditsPosition = \"bottom-left\";\n      this.product = \"ammap\";\n      this.areasClasses = {};\n      this.updatableImages = [];\n      a.applyTheme(this, b, this.cname);\n    },\n    initChart: function () {\n      this.zoomInstantly = !0;\n      var d = this.container;\n      this.panRequired = !0;\n      if (this.sizeChanged && a.hasSVG && this.chartCreated) {\n        this.updatableImages = [];\n        this.freeLabelsSet && this.freeLabelsSet.remove();\n        this.freeLabelsSet = d.set();\n        this.container.setSize(this.realWidth, this.realHeight);\n        this.resizeMap();\n        this.drawBackground();\n        this.redrawLabels();\n        this.drawTitles();\n        this.processObjects(!0);\n        this.rescaleObjects();\n        this.zoomControl.init(this, d);\n        this.drawBg();\n        var c = this.smallMap;\n        c && c.init(this, d);\n        (c = this.valueLegend) && c.init(this, d);\n        this.sizeChanged = !1;\n        this.zoomToLongLat(this.zLevelTemp, this.zLongTemp, this.zLatTemp, !0);\n        this.previousWidth = this.realWidth;\n        this.previousHeight = this.realHeight;\n        this.updateSmallMap();\n        this.linkSet.toFront();\n        this.zoomControl.update && this.zoomControl.update();\n      } else {\n        (a.AmMap.base.initChart.call(this), a.hasSVG) ? (this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, d = this.legend) && (d.position = \"absolute\", d.invalidateSize()), this.createDescriptionsDiv(), this.svgAreas = [], this.svgAreasById = {}, this.drawChart()) : (this.chartDiv.style.textAlign = \"\", this.chartDiv.setAttribute(\"class\", \"ammapAlert\"), this.chartDiv.innerHTML = this.svgNotSupported, this.fire({\n          type: \"failed\",\n          chart: this\n        }));\n      }\n    },\n    storeTemp: function () {\n      if (a.hasSVG && 0 < this.realWidth && 0 < this.realHeight) {\n        var b = this.mapContainer.getBBox();\n        0 < b.width && 0 < b.height && (b = this.zoomLongitude(), isNaN(b) || (this.zLongTemp = b), b = this.zoomLatitude(), isNaN(b) || (this.zLatTemp = b), b = this.zoomLevel(), isNaN(b) || (this.zLevelTemp = b));\n      }\n    },\n    invalidateSize: function () {\n      this.storeTemp();\n      a.AmMap.base.invalidateSize.call(this);\n    },\n    validateSize: function () {\n      this.storeTemp();\n      a.AmMap.base.validateSize.call(this);\n    },\n    handleWheelReal: function (f) {\n      if (!this.wheelBusy) {\n        this.stopAnimation();\n        var d = this.zoomLevel(),\n          h = this.zoomControl,\n          g = h.zoomFactor;\n        this.wheelBusy = !0;\n        f = a.fitToBounds(0 < f ? d * g : d / g, h.minZoomLevel, h.maxZoomLevel);\n        g = this.mouseX / this.mapWidth;\n        h = this.mouseY / this.mapHeight;\n        g = (this.zoomX() - g) * (f / d) + g;\n        d = (this.zoomY() - h) * (f / d) + h;\n        this.zoomTo(f, g, d);\n      }\n    },\n    addLegend: function (d, c) {\n      d.position = \"absolute\";\n      d.autoMargins = !1;\n      d.valueWidth = 0;\n      d.switchable = !1;\n      a.AmMap.base.addLegend.call(this, d, c);\n      void 0 === d.enabled && (d.enabled = !0);\n      return d;\n    },\n    handleLegendEvent: function () {},\n    createDescriptionsDiv: function () {\n      if (!this.descriptionsDiv) {\n        var d = document.createElement(\"div\"),\n          c = d.style;\n        c.position = \"absolute\";\n        c.left = \"0px\";\n        c.top = \"0px\";\n        this.descriptionsDiv = d;\n      }\n      this.containerDiv.appendChild(this.descriptionsDiv);\n    },\n    drawChart: function () {\n      a.AmMap.base.drawChart.call(this);\n      var e = this.dataProvider;\n      this.dataProvider = e = a.extend(e, new a.MapData(), !0);\n      this.areasSettings = a.processObject(this.areasSettings, a.AreasSettings, this.theme);\n      this.imagesSettings = a.processObject(this.imagesSettings, a.ImagesSettings, this.theme);\n      this.linesSettings = a.processObject(this.linesSettings, a.LinesSettings, this.theme);\n      var d = this.container;\n      this.mapContainer && this.mapContainer.remove();\n      this.mapContainer = d.set();\n      this.graphsSet.push(this.mapContainer);\n      var f;\n      e.map && (f = a.maps[e.map]);\n      e.mapVar && (f = e.mapVar);\n      f ? (this.svgData = f.svg, this.getBounds(), this.buildEverything()) : (e = e.mapURL) && this.loadXml(e);\n      this.balloonsSet.toFront();\n    },\n    drawBg: function () {\n      var b = this;\n      b.background.click(function () {\n        b.handleBackgroundClick();\n      });\n      b.background.mouseover(function () {\n        b.rollOutMapObject(b.previouslyHovered);\n      });\n    },\n    buildEverything: function () {\n      if (0 < this.realWidth && 0 < this.realHeight) {\n        var e = this.container,\n          d = this.dataProvider;\n        this.projection || (this.projection = d.projection, this.projection || (this.projection = \"equirectangular\"));\n        this.updatableImages = [];\n        var f = this.projection;\n        f && (this.projectionFunction = a[f]);\n        this.projectionFunction || (this.projectionFunction = a.equirectangular);\n        this.dpProjectionFunction = a[d.projection];\n        this.dpProjectionFunction || (this.dpProjectionFunction = a.equirectangular);\n        this.zoomControl = a.processObject(this.zoomControl, a.ZoomControl, this.theme);\n        this.zoomControl.init(this, e);\n        this.drawBg();\n        this.buildSVGMap();\n        this.projectionFunction && f != d.projection || this.forceNormalize ? (this.normalizeMap(), this.changeProjection()) : this.fixMapPosition();\n        if (f = this.smallMap) {\n          f = a.processObject(f, a.SmallMap, this.theme), f.init(this, e), this.smallMap = f;\n        }\n        isNaN(d.zoomX) && isNaN(d.zoomY) && isNaN(d.zoomLatitude) && isNaN(d.zoomLongitude) && (this.centerMap ? (f = this.xyToCoordinates(this.mapWidth / 2, this.mapHeight / 2), d.zoomLongitudeC = f.longitude, d.zoomLatitudeC = f.latitude) : (d.zoomX = 0, d.zoomY = 0), this.zoomInstantly = !0);\n        this.selectObject(this.dataProvider);\n        this.processAreas();\n        if (d = this.valueLegend) {\n          this.valueLegend = d = a.processObject(d, a.ValueLegend, this.theme), d.init(this, e);\n        }\n        this.objectList && (e = this.objectList = a.processObject(this.objectList, a.ObjectList)) && (this.clearObjectList(), e.init(this));\n        this.dispDUpd();\n        this.updateSmallMap();\n        this.linkSet.toFront();\n      } else {\n        this.cleanChart();\n      }\n    },\n    hideGroup: function (b) {\n      this.showHideGroup(b, !1);\n    },\n    showGroup: function (b) {\n      this.showHideGroup(b, !0);\n    },\n    showHideGroup: function (d, c) {\n      this.showHideReal(this.imagesProcessor.allObjects, d, c);\n      this.showHideReal(this.areasProcessor.allObjects, d, c);\n      this.showHideReal(this.linesProcessor.allObjects, d, c);\n    },\n    showHideReal: function (h, f, l) {\n      var j;\n      for (j = 0; j < h.length; j++) {\n        var k = h[j];\n        if (k.groupId == f) {\n          var i = k.displayObject;\n          i && (l ? (k.hidden = !1, i.show()) : (k.hidden = !0, i.hide()));\n        }\n      }\n    },\n    makeObjectAccessible: function (d) {\n      if (d.accessibleLabel) {\n        var c = this.formatString(d.accessibleLabel, d);\n        d.displayObject && this.makeAccessible(d.displayObject, c, \"menuitem\");\n      }\n    },\n    update: function () {\n      if (a.hasSVG) {\n        a.AmMap.base.update.call(this);\n        this.zoomControl && this.zoomControl.update && this.zoomControl.update();\n        for (var d = 0, c = this.updatableImages.length; d < c; d++) {\n          this.updatableImages[d].update();\n        }\n      }\n    },\n    animateMap: function () {\n      var b = this;\n      b.totalFrames = b.zoomDuration * a.updateRate;\n      b.totalFrames += 1;\n      b.frame = 0;\n      b.tweenPercent = 0;\n      b.balloon.hide(0);\n      setTimeout(function () {\n        b.updateSize.call(b);\n      }, 1000 / a.updateRate);\n    },\n    updateSize: function () {\n      var d = this,\n        c = d.totalFrames;\n      d.preventHover = !0;\n      d.frame <= c ? (d.frame++, c = a.easeOutSine(0, d.frame, 0, 1, c), 1 <= c ? (c = 1, d.preventHover = !1, d.wheelBusy = !1) : window.requestAnimationFrame ? window.requestAnimationFrame(function () {\n        d.updateSize.call(d);\n      }) : setTimeout(function () {\n        d.updateSize.call(d);\n      }, 1000 / a.updateRate), 0.8 < c && (d.preventHover = !1)) : (c = 1, d.preventHover = !1, d.wheelBusy = !1);\n      d.tweenPercent = c;\n      d.rescaleMapAndObjects();\n    },\n    rescaleMapAndObjects: function () {\n      var h = this.initialScale,\n        f = this.initialX,\n        l = this.initialY,\n        j = this.tweenPercent,\n        h = h + (this.finalScale - h) * j;\n      this.mapContainer.translate(f + (this.finalX - f) * j, l + (this.finalY - l) * j, h, !0);\n      if (this.areasSettings.adjustOutlineThickness) {\n        for (var f = this.svgAreas, k = 0; k < f.length; k++) {\n          (l = f[k]) && l.setAttr(\"stroke-width\", this.areasSettings.outlineThickness / h / this.mapScale);\n        }\n        if (f = this.dataProvider.areas) {\n          for (k = 0; k < f.length; k++) {\n            var l = f[k],\n              i = l.displayObject;\n            i && i.setAttr(\"stroke-width\", l.outlineThicknessReal / h / this.mapScale);\n          }\n        }\n      }\n      this.rescaleObjects();\n      this.positionChanged();\n      this.updateSmallMap();\n      1 == j && this.fire({\n        type: \"zoomCompleted\",\n        chart: this\n      });\n    },\n    updateSmallMap: function () {\n      this.smallMap && this.smallMap.update();\n    },\n    rescaleObjects: function () {\n      var h = this.mapContainer.scale,\n        e = this.imagesProcessor.objectsToResize,\n        l;\n      for (l = 0; l < e.length; l++) {\n        var k = e[l].image,\n          j = e[l].scale,\n          i = e[l].mapImage;\n        isNaN(i.selectedScaleReal) || i != this.selectedObject || (i.tempScale = j, j *= i.selectedScaleReal);\n        k.translate(k.x, k.y, j / h, !0);\n      }\n      e = this.imagesProcessor.labelsToReposition;\n      for (l = 0; l < e.length; l++) {\n        k = e[l], k.imageLabel && this.imagesProcessor.positionLabel(k.imageLabel, k, k.labelPositionReal);\n      }\n      e = this.linesProcessor;\n      if (k = e.linesToResize) {\n        for (l = 0; l < k.length; l++) {\n          j = k[l], j.line.setAttr(\"stroke-width\", j.thickness / h);\n        }\n      }\n      e = e.objectsToResize;\n      for (l = 0; l < e.length; l++) {\n        k = e[l], k.translate(k.x, k.y, 1 / h, !0);\n      }\n    },\n    handleTouchEnd: function (b) {\n      this.initialDistance = NaN;\n      this.mouseIsDown = this.isDragging = !1;\n      a.AmMap.base.handleTouchEnd.call(this, b);\n    },\n    handleMouseDown: function (f) {\n      a.resetMouseOver();\n      this.mouseIsDown = this.mouseIsOver = !0;\n      this.balloon.hide(0);\n      f && this.mouseIsOver && f.preventDefault && this.panEventsEnabled && f.preventDefault();\n      if (this.chartCreated && !this.preventHover && (this.initialTouchZoom = this.zoomLevel(), this.dragMap && (this.stopAnimation(), this.mapContainerClickX = this.mapContainer.x, this.mapContainerClickY = this.mapContainer.y), f || (f = window.event), f.shiftKey && !0 === this.developerMode && this.getDevInfo(), f && f.touches)) {\n        var d = this.mouseX,\n          h = this.mouseY,\n          g = f.touches.item(1);\n        g && this.panEventsEnabled && this.boundingRect && (f = g.clientX - this.boundingRect.left, g = g.clientY - this.boundingRect.top, this.middleXP = (d + (f - d) / 2) / this.realWidth, this.middleYP = (h + (g - h) / 2) / this.realHeight, this.initialDistance = Math.sqrt(Math.pow(f - d, 2) + Math.pow(g - h, 2)));\n      }\n    },\n    stopDrag: function () {\n      this.isDragging = !1;\n    },\n    handleReleaseOutside: function () {\n      if (a.isModern) {\n        var f = this;\n        a.AmMap.base.handleReleaseOutside.call(f);\n        f.mouseIsDown = !1;\n        setTimeout(function () {\n          f.resetPinch.call(f);\n        }, 100);\n        if (!f.preventHover) {\n          f.stopDrag();\n          var d = f.zoomControl;\n          d && d.draggerUp && d.draggerUp();\n          f.mapWasDragged = !1;\n          var d = f.mapContainer,\n            h = f.mapContainerClickX,\n            g = f.mapContainerClickY;\n          isNaN(h) || isNaN(g) || !(3 < Math.abs(d.x - h) || 3 < Math.abs(d.y - g)) || (f.mapWasDragged = !0, d = {\n            type: \"dragCompleted\",\n            zoomX: f.zoomX(),\n            zoomY: f.zoomY(),\n            zoomLevel: f.zoomLevel(),\n            chart: f\n          }, f.fire(d));\n          (f.mouseIsOver && !f.mapWasDragged && !f.skipClick || f.wasTouched && 3 > Math.abs(f.mouseX - f.tmx) && 3 > Math.abs(f.mouseY - f.tmy)) && f.fire({\n            type: \"click\",\n            x: f.mouseX,\n            y: f.mouseY,\n            chart: f\n          });\n          f.mapContainerClickX = NaN;\n          f.mapContainerClickY = NaN;\n          f.objectWasClicked = !1;\n          f.zoomOnDoubleClick && f.mouseIsOver && (d = new Date().getTime(), 200 > d - f.previousClickTime && 40 < d - f.previousClickTime && f.doDoubleClickZoom(), f.previousClickTime = d);\n        }\n        f.wasTouched = !1;\n      }\n    },\n    resetPinch: function () {\n      this.mapWasPinched = !1;\n    },\n    handleMouseMove: function (E) {\n      var D = this;\n      a.AmMap.base.handleMouseMove.call(D, E);\n      if (!E || !E.touches || !D.tapToActivate || D.tapped) {\n        D.panEventsEnabled && D.mouseIsOver && E && E.preventDefault && E.preventDefault();\n        var B = D.previuosMouseX,\n          A = D.previuosMouseY,\n          z = D.mouseX,\n          x = D.mouseY,\n          w = D.zoomControl;\n        isNaN(B) && (B = z);\n        isNaN(A) && (A = x);\n        D.mouse2X = NaN;\n        D.mouse2Y = NaN;\n        E && E.touches && (E = E.touches.item(1)) && D.panEventsEnabled && D.boundingRect && (D.mouse2X = E.clientX - D.boundingRect.left, D.mouse2Y = E.clientY - D.boundingRect.top);\n        if (E = D.mapContainer) {\n          var v = D.mouse2X,\n            u = D.mouse2Y;\n          D.pinchTO && clearTimeout(D.pinchTO);\n          D.pinchTO = setTimeout(function () {\n            D.resetPinch.call(D);\n          }, 1000);\n          var s = D.realHeight,\n            o = D.realWidth,\n            j = D.mapWidth,\n            F = D.mapHeight;\n          D.mouseIsDown && D.dragMap && (3 < Math.abs(D.previuosMouseX - D.mouseX) || 3 < Math.abs(D.previuosMouseY - D.mouseY)) && (D.isDragging = !0);\n          if (!isNaN(v)) {\n            D.stopDrag();\n            var d = Math.sqrt(Math.pow(v - z, 2) + Math.pow(u - x, 2)),\n              i = D.initialDistance;\n            isNaN(i) && (i = Math.sqrt(Math.pow(v - z, 2) + Math.pow(u - x, 2)));\n            if (!isNaN(i)) {\n              var v = D.initialTouchZoom * d / i,\n                v = a.fitToBounds(v, w.minZoomLevel, w.maxZoomLevel),\n                w = D.zoomLevel(),\n                i = D.middleXP,\n                u = D.middleYP,\n                d = s / F,\n                C = o / j,\n                i = (D.zoomX() - i * C) * (v / w) + i * C,\n                u = (D.zoomY() - u * d) * (v / w) + u * d;\n              0.1 < Math.abs(v - w) && (D.zoomTo(v, i, u, !0), D.mapWasPinched = !0, clearTimeout(D.pinchTO));\n            }\n          }\n          v = E.scale;\n          D.isDragging && (D.balloon.hide(0), D.positionChanged(), B = E.x + (z - B), A = E.y + (x - A), D.preventDragOut && (F = -F * v + s / 2 - D.diffY * D.mapScale * v, s = s / 2 - D.diffY * D.mapScale * v, B = a.fitToBounds(B, -j * v + o / 2, o / 2), A = a.fitToBounds(A, F, s)), isNaN(B) || isNaN(A) || (E.translate(B, A, v, !0), D.updateSmallMap()));\n          D.previuosMouseX = z;\n          D.previuosMouseY = x;\n        }\n      }\n    },\n    selectObject: function (x, w) {\n      var v = this;\n      x || (x = v.dataProvider);\n      x.isOver = !1;\n      var u = x.linkToObject;\n      a.isString(u) && (u = v.getObjectById(u));\n      x.useTargetsZoomValues && u && (x.zoomX = u.zoomX, x.zoomY = u.zoomY, x.zoomLatitude = u.zoomLatitude, x.zoomLongitude = u.zoomLongitude, x.zoomLevel = u.zoomLevel);\n      var t = v.selectedObject;\n      t && v.returnInitialColor(t);\n      v.selectedObject = x;\n      var s = !1,\n        r,\n        q;\n      \"MapArea\" == x.objectType && (x.autoZoomReal && (s = !0), r = v.areasSettings.selectedOutlineColor, q = v.areasSettings.selectedOutlineThickness);\n      if (u && !s && (a.isString(u) && (u = v.getObjectById(u)), isNaN(x.zoomLevel) && isNaN(x.zoomX) && isNaN(x.zoomY))) {\n        if (v.extendMapData(u)) {\n          return;\n        }\n        v.selectObject(u);\n        return;\n      }\n      v.allowMultipleDescriptionWindows || v.closeAllDescriptions();\n      clearTimeout(v.selectedObjectTimeOut);\n      clearTimeout(v.processObjectsTimeOut);\n      u = v.zoomDuration;\n      !s && isNaN(x.zoomLevel) && isNaN(x.zoomX) && isNaN(x.zoomY) ? (v.showDescriptionAndGetUrl(), w || v.processObjects()) : (v.selectedObjectTimeOut = setTimeout(function () {\n        v.showDescriptionAndGetUrl.call(v);\n      }, 1000 * u + 200), v.showObjectsAfterZoom) ? w || (v.processObjectsTimeOut = setTimeout(function () {\n        v.processObjects.call(v);\n      }, 1000 * u + 200)) : w || v.processObjects();\n      u = x.displayObject;\n      s = x.selectedColorReal;\n      if (\"MapImage\" == x.objectType) {\n        r = v.imagesSettings.selectedOutlineColor;\n        q = v.imagesSettings.selectedOutlineThickness;\n        var u = x.image,\n          o = x.selectedScaleReal;\n        if (!isNaN(o) && 1 != o) {\n          var j = x.scale;\n          isNaN(x.tempScale) || (j = x.tempScale);\n          isNaN(j) && (j = 1);\n          x.tempScale = j;\n          var i = x.displayObject;\n          i.translate(i.x, i.y, j * o, !0);\n        }\n      }\n      if (u) {\n        if (a.removeCN(v, u, \"selected-object\"), a.setCN(v, u, \"selected-object\"), x.bringForwardOnHover && x.displayObject.toFront(), v.outlinesToFront(), !x.preserveOriginalAttributes) {\n          u.setAttr(\"stroke\", x.outlineColorReal);\n          void 0 !== s && u.setAttr(\"fill\", s);\n          void 0 !== r && u.setAttr(\"stroke\", r);\n          void 0 !== q && u.setAttr(\"stroke-width\", q);\n          \"MapLine\" == x.objectType && ((o = x.lineSvg) && o.setAttr(\"stroke\", s), o = x.arrowSvg) && (o.setAttr(\"fill\", s), o.setAttr(\"stroke\", s));\n          if (o = x.imageLabel) {\n            j = x.selectedLabelColorReal, void 0 !== j && o.setAttr(\"fill\", j);\n          }\n          x.selectable || (u.setAttr(\"cursor\", \"default\"), o && o.setAttr(\"cursor\", \"default\"));\n        }\n      } else {\n        v.returnInitialColorReal(x);\n      }\n      if (u = x.groupId) {\n        for (o = x.groupArray, o || (o = v.getGroupById(u), x.groupArray = o), j = 0; j < o.length; j++) {\n          if (i = o[j], i.isOver = !1, u = i.displayObject, \"MapImage\" == i.objectType && (u = i.image), u) {\n            var d = i.selectedColorReal;\n            void 0 !== d && u.setAttr(\"fill\", d);\n            void 0 !== r && u.setAttr(\"stroke\", r);\n            void 0 !== q && u.setAttr(\"stroke-width\", q);\n            \"MapLine\" == i.objectType && ((u = i.lineSvg) && u.setAttr(\"stroke\", s), u = i.arrowSvg) && (u.setAttr(\"fill\", s), u.setAttr(\"stroke\", s));\n          }\n        }\n      }\n      v.rescaleObjects();\n      v.zoomToSelectedObject();\n      t != x && v.fire({\n        type: \"selectedObjectChanged\",\n        chart: v\n      });\n    },\n    returnInitialColor: function (f, e) {\n      this.returnInitialColorReal(f);\n      e && (f.isFirst = !1);\n      if (this.selectedObject.bringForwardOnHover) {\n        var h = this.selectedObject.displayObject;\n        h && h.toFront();\n      }\n      if (h = f.groupId) {\n        var h = this.getGroupById(h),\n          g;\n        for (g = 0; g < h.length; g++) {\n          this.returnInitialColorReal(h[g]), e && (h[g].isFirst = !1);\n        }\n      }\n      this.outlinesToFront();\n    },\n    outlinesToFront: function () {\n      if (this.outlines) {\n        for (var b = 0; b < this.outlines.length; b++) {\n          this.outlines[b].toFront();\n        }\n      }\n    },\n    closeAllDescriptions: function () {\n      this.descriptionsDiv.innerHTML = \"\";\n    },\n    fireClosed: function () {\n      this.fire({\n        type: \"descriptionClosed\",\n        chart: this\n      });\n    },\n    returnInitialColorReal: function (r) {\n      r.isOver = !1;\n      var q = r.displayObject;\n      if (q) {\n        a.removeCN(this, q, \"selected-object\");\n        q.toPrevious();\n        if (\"MapImage\" == r.objectType) {\n          var p = r.tempScale;\n          isNaN(p) || q.translate(q.x, q.y, p, !0);\n          r.tempScale = NaN;\n          q = r.image;\n        }\n        p = r.colorReal;\n        if (\"MapLine\" == r.objectType) {\n          var o = r.lineSvg;\n          o && o.setAttr(\"stroke\", p);\n          if (o = r.arrowSvg) {\n            var n = r.arrowColor;\n            void 0 === n && (n = p);\n            o.setAttr(\"fill\", n);\n            o.setAttr(\"stroke\", n);\n          }\n        }\n        var o = r.alphaReal,\n          n = r.outlineAlphaReal,\n          m = r.outlineThicknessReal,\n          j = r.outlineColorReal;\n        if (r.showAsSelected) {\n          var p = r.selectedColorReal,\n            i,\n            d;\n          \"MapImage\" == r.objectType && (i = this.imagesSettings.selectedOutlineColor, d = this.imagesSettings.selectedOutlineThickness);\n          \"MapArea\" == r.objectType && (i = this.areasSettings.selectedOutlineColor, d = this.areasSettings.selectedOutlineThickness);\n          void 0 !== i && (j = i);\n          void 0 !== d && (m = d);\n        }\n        \"bubble\" == r.type && (p = void 0);\n        void 0 !== p && q.setAttr(\"fill\", p);\n        if (i = r.image) {\n          i.setAttr(\"fill\", p), i.setAttr(\"stroke\", j), i.setAttr(\"stroke-width\", m), i.setAttr(\"fill-opacity\", o), i.setAttr(\"stroke-opacity\", n);\n        }\n        \"MapArea\" == r.objectType && (p = 1, this.areasSettings.adjustOutlineThickness && (p = this.zoomLevel() * this.mapScale), q.setAttr(\"stroke\", j), q.setAttr(\"stroke-width\", m / p), q.setAttr(\"fill-opacity\", o), q.setAttr(\"stroke-opacity\", n));\n        (p = r.pattern) && q.pattern(p, this.mapScale, this.path);\n        (q = r.imageLabel) && !r.labelInactive && (r.showAsSelected && void 0 !== r.selectedLabelColor ? q.setAttr(\"fill\", r.selectedLabelColor) : q.setAttr(\"fill\", r.labelColorReal));\n      }\n    },\n    zoomToRectangle: function (i, d, p, o) {\n      var n = this.realWidth,\n        m = this.realHeight,\n        l = this.mapSet.scale,\n        j = this.zoomControl,\n        n = a.fitToBounds(p / n > o / m ? 0.8 * n / (p * l) : 0.8 * m / (o * l), j.minZoomLevel, j.maxZoomLevel);\n      this.zoomToMapXY(n, (i + p / 2) * l, (d + o / 2) * l);\n    },\n    zoomToLatLongRectangle: function (r, q, p, o) {\n      var n = this.dataProvider,\n        m = this.zoomControl,\n        j = Math.abs(p - r),\n        i = Math.abs(q - o),\n        d = Math.abs(n.rightLongitude - n.leftLongitude),\n        n = Math.abs(n.topLatitude - n.bottomLatitude),\n        m = a.fitToBounds(j / d > i / n ? 0.8 * d / j : 0.8 * n / i, m.minZoomLevel, m.maxZoomLevel);\n      this.zoomToLongLat(m, r + (p - r) / 2, o + (q - o) / 2);\n    },\n    getGroupById: function (d) {\n      var c = [];\n      this.getGroup(this.imagesProcessor.allObjects, d, c);\n      this.getGroup(this.linesProcessor.allObjects, d, c);\n      this.getGroup(this.areasProcessor.allObjects, d, c);\n      return c;\n    },\n    zoomToGroup: function (t) {\n      t = \"object\" == typeof t ? t : this.getGroupById(t);\n      var s, r, q, p, o;\n      for (o = 0; o < t.length; o++) {\n        var n = t[o].displayObject;\n        if (n) {\n          var j = n.getBBox(),\n            n = j.y,\n            i = j.y + j.height,\n            e = j.x,\n            j = j.x + j.width;\n          if (n < s || isNaN(s)) {\n            s = n;\n          }\n          if (i > p || isNaN(p)) {\n            p = i;\n          }\n          if (e < r || isNaN(r)) {\n            r = e;\n          }\n          if (j > q || isNaN(q)) {\n            q = j;\n          }\n        }\n      }\n      r += this.diffX;\n      q += this.diffX;\n      p += this.diffY;\n      s += this.diffY;\n      this.zoomToRectangle(r, s, q - r, p - s);\n    },\n    getGroup: function (g, e, j) {\n      if (g) {\n        var i;\n        for (i = 0; i < g.length; i++) {\n          var h = g[i];\n          h.groupId == e && j.push(h);\n        }\n      }\n    },\n    zoomToStageXY: function (h, d, l, k) {\n      if (!this.objectWasClicked) {\n        var j = this.zoomControl;\n        h = a.fitToBounds(h, j.minZoomLevel, j.maxZoomLevel);\n        var j = this.zoomLevel(),\n          i = this.mapSet.getBBox();\n        d = this.xyToCoordinates((d - this.mapContainer.x) / j - i.x * this.mapScale, (l - this.mapContainer.y) / j - i.y * this.mapScale);\n        this.zoomToLongLat(h, d.longitude, d.latitude, k);\n      }\n    },\n    zoomToLongLat: function (f, e, h, g) {\n      e = this.coordinatesToXY(e, h);\n      this.zoomToMapXY(f, e.x, e.y, g);\n    },\n    zoomToMapXY: function (h, e, l, k) {\n      var j = this.mapWidth,\n        i = this.mapHeight;\n      this.zoomTo(h, -(e / j) * h + this.realWidth / j / 2, -(l / i) * h + this.realHeight / i / 2, k);\n    },\n    zoomToObject: function (r) {\n      if (r) {\n        var q = r.zoomLatitude,\n          p = r.zoomLongitude;\n        isNaN(r.zoomLatitudeC) || (q = r.zoomLatitudeC);\n        isNaN(r.zoomLongitudeC) || (p = r.zoomLongitudeC);\n        var o = r.zoomLevel,\n          n = this.zoomInstantly,\n          m = r.zoomX,\n          j = r.zoomY,\n          i = this.realWidth,\n          d = this.realHeight;\n        isNaN(o) || (isNaN(q) || isNaN(p) ? this.zoomTo(o, m, j, n) : this.zoomToLongLat(o, p, q, n));\n        this.zoomInstantly = !1;\n        \"MapImage\" == r.objectType && isNaN(r.zoomX) && isNaN(r.zoomY) && isNaN(r.zoomLatitude) && isNaN(r.zoomLongitude) && !isNaN(r.latitude) && !isNaN(r.longitude) && this.zoomToLongLat(r.zoomLevel, r.longitude, r.latitude);\n        \"MapArea\" == r.objectType && (n = r.displayObject.getBBox(), m = this.mapScale, q = (n.x + this.diffX) * m, p = (n.y + this.diffY) * m, o = n.width * m, n = n.height * m, i = r.autoZoomReal && isNaN(r.zoomLevel) ? o / i > n / d ? 0.8 * i / o : 0.8 * d / n : r.zoomLevel, d = this.zoomControl, i = a.fitToBounds(i, d.minZoomLevel, d.maxZoomLevel), isNaN(r.zoomX) && isNaN(r.zoomY) && isNaN(r.zoomLatitude) && isNaN(r.zoomLongitude) && this.zoomToMapXY(i, q + o / 2, p + n / 2));\n        this.zoomControl.update();\n      }\n    },\n    zoomToSelectedObject: function () {\n      this.zoomToObject(this.selectedObject);\n    },\n    zoomTo: function (g, d, j, i) {\n      var h = this.zoomControl;\n      g = a.fitToBounds(g, h.minZoomLevel, h.maxZoomLevel);\n      h = this.zoomLevel();\n      isNaN(d) && (d = this.realWidth / this.mapWidth, d = (this.zoomX() - 0.5 * d) * (g / h) + 0.5 * d);\n      isNaN(j) && (j = this.realHeight / this.mapHeight, j = (this.zoomY() - 0.5 * j) * (g / h) + 0.5 * j);\n      this.stopAnimation();\n      isNaN(g) || (h = this.mapContainer, this.initialX = h.x, this.initialY = h.y, this.initialScale = h.scale, this.finalX = this.mapWidth * d, this.finalY = this.mapHeight * j, this.finalScale = g, this.finalX != this.initialX || this.finalY != this.initialY || this.finalScale != this.initialScale ? i ? (this.tweenPercent = 1, this.rescaleMapAndObjects(), this.wheelBusy = !1) : this.animateMap() : this.wheelBusy = !1);\n    },\n    loadXml: function (d) {\n      var c;\n      window.XMLHttpRequest && (c = new XMLHttpRequest());\n      c.overrideMimeType && c.overrideMimeType(\"text/xml\");\n      c.open(\"GET\", d, !1);\n      c.send();\n      this.parseXMLObject(c.responseXML);\n      this.svgData && this.buildEverything();\n    },\n    stopAnimation: function () {\n      this.frame = this.totalFrames;\n    },\n    processObjects: function (h) {\n      var e = this.selectedObject;\n      if (0 < e.images.length || 0 < e.areas.length || 0 < e.lines.length || e == this.dataProvider || h) {\n        h = this.container;\n        var l = this.stageImagesContainer;\n        l && l.remove();\n        this.stageImagesContainer = l = h.set();\n        this.trendLinesSet.push(l);\n        var k = this.stageLinesContainer;\n        k && k.remove();\n        this.stageLinesContainer = k = h.set();\n        this.trendLinesSet.push(k);\n        var j = this.mapImagesContainer;\n        j && j.remove();\n        this.mapImagesContainer = j = h.set();\n        this.mapContainer.push(j);\n        var i = this.mapLinesContainer;\n        i && i.remove();\n        this.mapLinesContainer = i = h.set();\n        this.mapContainer.push(i);\n        this.linesAboveImages ? (j.toFront(), l.toFront(), i.toFront(), k.toFront()) : (i.toFront(), k.toFront(), j.toFront(), l.toFront());\n        e && (this.imagesProcessor.reset(), this.linesProcessor.reset(), this.linesAboveImages ? (this.imagesProcessor.process(e), this.linesProcessor.process(e)) : (this.linesProcessor.process(e), this.imagesProcessor.process(e)));\n        this.rescaleObjects();\n      }\n    },\n    processAreas: function () {\n      this.areasProcessor.process(this.dataProvider);\n    },\n    buildSVGMap: function () {\n      a.remove(this.mapSet);\n      var r = this.svgData.g.path,\n        q = this.container,\n        p = q.set();\n      this.svgAreas = [];\n      this.svgAreasById = {};\n      void 0 === r.length && (r = [r]);\n      var o;\n      for (o = 0; o < r.length; o++) {\n        var n = r[o],\n          m = n.d,\n          j = n.title;\n        n.titleTr && (j = n.titleTr);\n        var i = q.path(m);\n        i.id = n.id;\n        if (this.areasSettings.preserveOriginalAttributes) {\n          i.customAttr = {};\n          for (var d in n) {\n            \"d\" != d && \"id\" != d && \"title\" != d && (i.customAttr[d] = n[d]);\n          }\n        }\n        n.outline && (i.outline = !0);\n        i.path = m;\n        this.svgAreasById[n.id] = {\n          area: i,\n          title: j,\n          className: n[\"class\"]\n        };\n        this.svgAreas.push(i);\n        p.push(i);\n      }\n      this.mapSet = p;\n      this.mapContainer.push(p);\n      this.resizeMap();\n    },\n    centerAlign: function () {},\n    setProjection: function (b) {\n      this.projection = b;\n      this.chartCreated = !1;\n      this.buildEverything();\n    },\n    addObjectEventListeners: function (e, d) {\n      var f = this;\n      e.mousedown(function (b) {\n        f.mouseDownMapObject(d, b);\n      }).mouseup(function (b) {\n        f.clickMapObject(d, b);\n      }).mouseover(function (b) {\n        f.balloonX = NaN;\n        f.rollOverMapObject(d, !0, b);\n      }).mouseout(function (b) {\n        f.balloonX = NaN;\n        f.rollOutMapObject(d, b);\n      }).touchend(function (b) {\n        4 > Math.abs(f.mouseX - f.tmx) && 4 > Math.abs(f.mouseY - f.tmy) && (f.tapped = !0);\n        f.tapToActivate && !f.tapped || f.mapWasDragged || f.mapWasPinched || (f.balloonX = NaN, f.rollOverMapObject(d, !0, b), f.clickMapObject(d, b));\n      }).touchstart(function (b) {\n        f.tmx = f.mouseX;\n        f.tmy = f.mouseY;\n        f.mouseDownMapObject(d, b);\n      }).keyup(function (b) {\n        13 == b.keyCode && f.clickMapObject(d, b);\n      });\n    },\n    checkIfSelected: function (e) {\n      var d = this.selectedObject;\n      if (d == e) {\n        return !0;\n      }\n      if (d = d.groupId) {\n        var d = this.getGroupById(d),\n          f;\n        for (f = 0; f < d.length; f++) {\n          if (d[f] == e) {\n            return !0;\n          }\n        }\n      }\n      return !1;\n    },\n    clearMap: function () {\n      this.chartDiv.innerHTML = \"\";\n      this.clearObjectList();\n    },\n    clearObjectList: function () {\n      var b = this.objectList;\n      b && b.div && (b.div.innerHTML = \"\");\n    },\n    checkIfLast: function (d) {\n      if (d) {\n        var c = d.parentNode;\n        if (c && c.lastChild == d) {\n          return !0;\n        }\n      }\n      return !1;\n    },\n    showAsRolledOver: function (g) {\n      var d = g.displayObject;\n      if (!g.showAsSelected && d && !g.isOver) {\n        d.node.onmouseout = function () {};\n        d.node.onmouseover = function () {};\n        d.node.onclick = function () {};\n        !g.isFirst && g.bringForwardOnHover && (d.toFront(), g.isFirst = !0);\n        var j = g.rollOverColorReal,\n          i;\n        g.preserveOriginalAttributes && (j = void 0);\n        \"bubble\" == g.type && (j = void 0);\n        void 0 == j && (isNaN(g.rollOverBrightnessReal) || (j = a.adjustLuminosity(g.colorReal, g.rollOverBrightnessReal / 100)));\n        if (void 0 != j) {\n          if (\"MapImage\" == g.objectType) {\n            (i = g.image) && i.setAttr(\"fill\", j);\n          } else {\n            if (\"MapLine\" == g.objectType) {\n              if ((i = g.lineSvg) && i.setAttr(\"stroke\", j), i = g.arrowSvg) {\n                i.setAttr(\"fill\", j), i.setAttr(\"stroke\", j);\n              }\n            } else {\n              d.setAttr(\"fill\", j);\n            }\n          }\n        }\n        (j = g.imageLabel) && !g.labelInactive && (i = g.labelRollOverColorReal, void 0 != i && j.setAttr(\"fill\", i));\n        j = g.rollOverOutlineColorReal;\n        void 0 != j && (\"MapImage\" == g.objectType ? (i = g.image) && i.setAttr(\"stroke\", j) : d.setAttr(\"stroke\", j));\n        \"MapImage\" == g.objectType ? (j = this.imagesSettings.rollOverOutlineThickness, (i = g.image) && (isNaN(j) || i.setAttr(\"stroke-width\", j))) : (j = this.areasSettings.rollOverOutlineThickness, isNaN(j) || d.setAttr(\"stroke-width\", j));\n        if (\"MapArea\" == g.objectType) {\n          j = this.areasSettings;\n          i = g.rollOverAlphaReal;\n          isNaN(i) || d.setAttr(\"fill-opacity\", i);\n          i = j.rollOverOutlineAlpha;\n          isNaN(i) || d.setAttr(\"stroke-opacity\", i);\n          i = 1;\n          this.areasSettings.adjustOutlineThickness && (i = this.zoomLevel() * this.mapScale);\n          var h = j.rollOverOutlineThickness;\n          isNaN(h) || d.setAttr(\"stroke-width\", h / i);\n          (j = j.rollOverPattern) && d.pattern(j, this.mapScale, this.path);\n        }\n        \"MapImage\" == g.objectType && (j = g.rollOverScaleReal, isNaN(j) || 1 == j || (i = d.scale, isNaN(i) && (i = 1), g.tempScale = i, d.translate(d.x, d.y, i * j, !0)));\n        this.useHandCursorOnClickableOjects && this.checkIfClickable(g) && d.setAttr(\"cursor\", \"pointer\");\n        g.mouseEnabled && this.addObjectEventListeners(d, g);\n        g.isOver = !0;\n      }\n      this.outlinesToFront();\n    },\n    rollOverMapObject: function (g, e, j) {\n      if (this.chartCreated) {\n        this.handleMouseMove();\n        var i = this.previouslyHovered;\n        i && i != g ? (!1 === this.checkIfSelected(i) && (this.returnInitialColor(i, !0), this.previouslyHovered = null), this.balloon.hide(0)) : clearTimeout(this.hoverInt);\n        if (!this.preventHover) {\n          if (!1 === this.checkIfSelected(g)) {\n            if (i = g.groupId) {\n              var i = this.getGroupById(i),\n                h;\n              for (h = 0; h < i.length; h++) {\n                i[h] != g && this.showAsRolledOver(i[h]);\n              }\n            }\n            this.showAsRolledOver(g);\n          } else {\n            (i = g.displayObject) && (this.allowClickOnSelectedObject ? i.setAttr(\"cursor\", \"pointer\") : i.setAttr(\"cursor\", \"default\"));\n          }\n          this.showDescriptionOnHover ? this.showDescription(g) : !this.showBalloonOnSelectedObject && this.checkIfSelected(g) || !1 === e || (h = this.balloon, this.balloon.fixedPosition = !1, e = g.colorReal, i = \"\", void 0 !== e && this.useObjectColorForBalloon || (e = h.fillColor), (h = g.balloonTextReal) && (i = this.formatString(h, g)), this.balloonLabelFunction && (i = this.balloonLabelFunction(g, this)), i && \"\" !== i && this.showBalloon(i, e, !1, this.balloonX, this.balloonY));\n          this.fire({\n            type: \"rollOverMapObject\",\n            mapObject: g,\n            chart: this,\n            event: j\n          });\n          this.previouslyHovered = g;\n        }\n      }\n    },\n    longitudeToX: function (b) {\n      return (this.longitudeToCoordinate(b) + this.diffX * this.mapScale) * this.zoomLevel() + this.mapContainer.x;\n    },\n    latitudeToY: function (b) {\n      return (this.latitudeToCoordinate(b) + this.diffY * this.mapScale) * this.zoomLevel() + this.mapContainer.y;\n    },\n    latitudeToStageY: function (b) {\n      return this.latitudeToCoordinate(b) * this.zoomLevel() + this.mapContainer.y + this.diffY * this.mapScale;\n    },\n    longitudeToStageX: function (b) {\n      return this.longitudeToCoordinate(b) * this.zoomLevel() + this.mapContainer.x + this.diffX * this.mapScale;\n    },\n    stageXToLongitude: function (b) {\n      b = (b - this.mapContainer.x) / this.zoomLevel();\n      return this.coordinateToLongitude(b);\n    },\n    stageYToLatitude: function (b) {\n      b = (b - this.mapContainer.y) / this.zoomLevel();\n      return this.coordinateToLatitude(b);\n    },\n    rollOutMapObject: function (d, c) {\n      this.hideBalloon();\n      d && this.chartCreated && d.isOver && (this.checkIfSelected(d) || this.returnInitialColor(d), this.fire({\n        type: \"rollOutMapObject\",\n        mapObject: d,\n        chart: this,\n        event: c\n      }));\n    },\n    formatString: function (i, d) {\n      var n = this.nf,\n        m = this.pf,\n        l = d.title;\n      d.titleTr && (l = d.titleTr);\n      void 0 == l && (l = \"\");\n      var k = d.value,\n        k = isNaN(k) ? \"\" : a.formatNumber(k, n),\n        n = d.percents,\n        n = isNaN(n) ? \"\" : a.formatNumber(n, m),\n        m = d.description;\n      void 0 == m && (m = \"\");\n      var j = d.customData;\n      void 0 == j && (j = \"\");\n      return i = a.massReplace(i, {\n        \"[[title]]\": l,\n        \"[[value]]\": k,\n        \"[[percent]]\": n,\n        \"[[description]]\": m,\n        \"[[customData]]\": j\n      });\n    },\n    mouseDownMapObject: function (d, c) {\n      this.fire({\n        type: \"mouseDownMapObject\",\n        mapObject: d,\n        chart: this,\n        event: c\n      });\n    },\n    clickMapObject: function (g, e) {\n      var j = this;\n      e && (e.touches || isNaN(g.zoomLevel) && isNaN(g.zoomX) && isNaN(g.zoomY) || j.hideBalloon());\n      if (j.chartCreated && !j.preventHover && j.checkTouchDuration(e) && !j.mapWasDragged && j.checkIfClickable(g) && !j.mapWasPinched) {\n        j.selectObject(g);\n        var i = j.zoomLevel(),\n          h = j.mapSet.getBBox(),\n          i = j.xyToCoordinates((j.mouseX - j.mapContainer.x) / i - h.x * j.mapScale, (j.mouseY - j.mapContainer.y) / i - h.y * j.mapScale);\n        j.clickLatitude = i.latitude;\n        j.clickLongitude = i.longitude;\n        e && e.touches && setTimeout(function () {\n          j.showBalloonAfterZoom.call(j);\n        }, 1000 * j.zoomDuration);\n        j.fire({\n          type: \"clickMapObject\",\n          mapObject: g,\n          chart: j,\n          event: e\n        });\n        j.objectWasClicked = !0;\n      }\n    },\n    showBalloonAfterZoom: function () {\n      var e = this.clickLongitude,\n        d = this.clickLatitude,\n        f = this.selectedObject;\n      \"MapImage\" != f.objectType || isNaN(f.longitude) || (e = f.longitude, d = f.latitude);\n      e = this.coordinatesToStageXY(e, d);\n      this.balloonX = e.x;\n      this.balloonY = e.y;\n      this.rollOverMapObject(this.selectedObject, !0);\n    },\n    checkIfClickable: function (d) {\n      var c = this.allowClickOnSelectedObject;\n      return this.selectedObject == d && c ? !0 : this.selectedObject != d || c ? !0 === d.selectable || \"MapArea\" == d.objectType && d.autoZoomReal || d.url || d.linkToObject || 0 < d.images.length || 0 < d.lines.length || !isNaN(d.zoomLevel) || !isNaN(d.zoomX) || !isNaN(d.zoomY) || d.description ? !0 : !1 : !1;\n    },\n    resizeMap: function () {\n      var h = this.mapSet;\n      if (h) {\n        var e = 1,\n          l = h.getBBox(),\n          k = this.realWidth,\n          j = this.realHeight,\n          i = l.width,\n          l = l.height;\n        0 < i && 0 < l && (this.fitMapToContainer && (e = i / k > l / j ? k / i : j / l), h.translate(0, 0, e, !0), this.mapScale = e, this.mapHeight = l * e, this.mapWidth = i * e);\n      }\n    },\n    zoomIn: function () {\n      var b = this.zoomLevel() * this.zoomControl.zoomFactor;\n      this.zoomTo(b);\n    },\n    zoomOut: function () {\n      var b = this.zoomLevel() / this.zoomControl.zoomFactor;\n      this.zoomTo(b);\n    },\n    moveLeft: function () {\n      var b = this.zoomX() + this.zoomControl.panStepSize;\n      this.zoomTo(this.zoomLevel(), b, this.zoomY());\n    },\n    moveRight: function () {\n      var b = this.zoomX() - this.zoomControl.panStepSize;\n      this.zoomTo(this.zoomLevel(), b, this.zoomY());\n    },\n    moveUp: function () {\n      var b = this.zoomY() + this.zoomControl.panStepSize;\n      this.zoomTo(this.zoomLevel(), this.zoomX(), b);\n    },\n    moveDown: function () {\n      var b = this.zoomY() - this.zoomControl.panStepSize;\n      this.zoomTo(this.zoomLevel(), this.zoomX(), b);\n    },\n    zoomX: function () {\n      return this.mapSet ? Math.round(10000 * this.mapContainer.x / this.mapWidth) / 10000 : NaN;\n    },\n    zoomY: function () {\n      return this.mapSet ? Math.round(10000 * this.mapContainer.y / this.mapHeight) / 10000 : NaN;\n    },\n    goHome: function () {\n      this.selectObject(this.dataProvider);\n      this.fire({\n        type: \"homeButtonClicked\",\n        chart: this\n      });\n    },\n    zoomLevel: function () {\n      return Math.round(100000 * this.mapContainer.scale) / 100000;\n    },\n    showDescriptionAndGetUrl: function () {\n      var e = this.selectedObject;\n      if (e) {\n        this.showDescription();\n        var d = e.url;\n        if (d) {\n          a.getURL(d, e.urlTarget);\n        } else {\n          if (d = e.linkToObject) {\n            if (a.isString(d)) {\n              var f = this.getObjectById(d);\n              if (f) {\n                this.selectObject(f);\n                return;\n              }\n            }\n            d && e.passZoomValuesToTarget && (d.zoomLatitude = this.zoomLatitude(), d.zoomLongitude = this.zoomLongitude(), d.zoomLevel = this.zoomLevel());\n            this.extendMapData(d) || this.selectObject(d);\n          }\n        }\n      }\n    },\n    extendMapData: function (d) {\n      var c = d.objectType;\n      if (\"MapImage\" != c && \"MapArea\" != c && \"MapLine\" != c) {\n        return a.extend(d, new a.MapData(), !0), this.dataProvider = d, this.zoomInstantly = !0, this.validateData(), !0;\n      }\n    },\n    showDescription: function (r) {\n      r || (r = this.selectedObject);\n      this.allowMultipleDescriptionWindows || this.closeAllDescriptions();\n      if (r.description) {\n        var q = r.descriptionWindow;\n        q && q.close();\n        q = new a.DescriptionWindow();\n        r.descriptionWindow = q;\n        var p = r.descriptionWindowWidth,\n          o = r.descriptionWindowHeight,\n          n = r.descriptionWindowLeft,\n          m = r.descriptionWindowTop,\n          j = r.descriptionWindowRight,\n          i = r.descriptionWindowBottom;\n        isNaN(j) || (n = this.realWidth - j);\n        isNaN(i) || (m = this.realHeight - i);\n        var d = r.descriptionWindowX;\n        isNaN(d) || (n = d);\n        d = r.descriptionWindowY;\n        isNaN(d) || (m = d);\n        isNaN(n) && (n = this.mouseX, n = n > this.realWidth / 2 ? n - p - 20 : n + 20);\n        isNaN(m) && (m = this.mouseY);\n        q.maxHeight = o;\n        d = r.title;\n        r.titleTr && (d = r.titleTr);\n        q.show(this, this.descriptionsDiv, r.description, d);\n        r = q.div.style;\n        r.position = \"absolute\";\n        r.width = p + \"px\";\n        r.maxHeight = o + \"px\";\n        isNaN(i) || (m -= q.div.offsetHeight);\n        isNaN(j) || (n -= q.div.offsetWidth);\n        r.left = n + \"px\";\n        r.top = m + \"px\";\n      }\n    },\n    parseXMLObject: function (d) {\n      var c = {\n        root: {}\n      };\n      this.parseXMLNode(c, \"root\", d);\n      this.svgData = c.root.svg;\n      this.getBounds();\n    },\n    getBounds: function () {\n      var f = this.dataProvider;\n      try {\n        var e = this.svgData.defs[\"amcharts:ammap\"];\n        f.leftLongitude = Number(e.leftLongitude);\n        f.rightLongitude = Number(e.rightLongitude);\n        f.topLatitude = Number(e.topLatitude);\n        f.bottomLatitude = Number(e.bottomLatitude);\n        f.projection = e.projection;\n        var h = e.wrappedLongitudes;\n        h && (f.rightLongitude += 360);\n        f.wrappedLongitudes = h;\n      } catch (g) {}\n    },\n    recalcLongitude: function (b) {\n      return this.dataProvider.wrappedLongitudes ? b < this.dataProvider.leftLongitude ? Number(b) + 360 : b : b;\n    },\n    latitudeToCoordinate: function (f) {\n      var e,\n        h = this.dataProvider;\n      if (this.mapSet) {\n        e = h.topLatitude;\n        var g = h.bottomLatitude;\n        \"mercator\" == h.projection && (f = this.mercatorLatitudeToCoordinate(f), e = this.mercatorLatitudeToCoordinate(e), g = this.mercatorLatitudeToCoordinate(g));\n        e = (f - e) / (g - e) * this.mapHeight;\n      }\n      return e;\n    },\n    longitudeToCoordinate: function (e) {\n      e = this.recalcLongitude(e);\n      var d,\n        f = this.dataProvider;\n      this.mapSet && (d = f.leftLongitude, d = (e - d) / (f.rightLongitude - d) * this.mapWidth);\n      return d;\n    },\n    mercatorLatitudeToCoordinate: function (b) {\n      89.5 < b && (b = 89.5);\n      -89.5 > b && (b = -89.5);\n      b = a.degreesToRadians(b);\n      return a.radiansToDegrees(0.5 * Math.log((1 + Math.sin(b)) / (1 - Math.sin(b))) / 2);\n    },\n    zoomLatitude: function () {\n      if (this.mapContainer) {\n        var d = this.mapSet.getBBox(),\n          c = (-this.mapContainer.x + this.previousWidth / 2) / this.zoomLevel() - d.x * this.mapScale,\n          d = (-this.mapContainer.y + this.previousHeight / 2) / this.zoomLevel() - d.y * this.mapScale;\n        return this.xyToCoordinates(c, d).latitude;\n      }\n    },\n    zoomLongitude: function () {\n      if (this.mapContainer) {\n        var d = this.mapSet.getBBox(),\n          c = (-this.mapContainer.x + this.previousWidth / 2) / this.zoomLevel() - d.x * this.mapScale,\n          d = (-this.mapContainer.y + this.previousHeight / 2) / this.zoomLevel() - d.y * this.mapScale;\n        return this.xyToCoordinates(c, d).longitude;\n      }\n    },\n    getAreaCenterLatitude: function (e) {\n      e = e.displayObject.getBBox();\n      var d = this.mapScale,\n        f = this.mapSet.getBBox();\n      return this.xyToCoordinates((e.x + e.width / 2 + this.diffX) * d - f.x * d, (e.y + e.height / 2 + this.diffY) * d - f.y * d).latitude;\n    },\n    getAreaCenterLongitude: function (e) {\n      e = e.displayObject.getBBox();\n      var d = this.mapScale,\n        f = this.mapSet.getBBox();\n      return this.xyToCoordinates((e.x + e.width / 2 + this.diffX) * d - f.x * d, (e.y + e.height / 2 + this.diffY) * d - f.y * d).longitude;\n    },\n    milesToPixels: function (d) {\n      var c = this.dataProvider;\n      return this.mapWidth / (c.rightLongitude - c.leftLongitude) * d / 69.172;\n    },\n    kilometersToPixels: function (d) {\n      var c = this.dataProvider;\n      return this.mapWidth / (c.rightLongitude - c.leftLongitude) * d / 111.325;\n    },\n    handleBackgroundClick: function () {\n      if (this.backgroundZoomsToTop && !this.mapWasDragged) {\n        var g = this.dataProvider;\n        if (this.checkIfClickable(g)) {\n          this.clickMapObject(g);\n        } else {\n          var e = g.zoomX,\n            j = g.zoomY,\n            i = g.zoomLongitude,\n            h = g.zoomLatitude,\n            g = g.zoomLevel;\n          isNaN(e) || isNaN(j) || this.zoomTo(g, e, j);\n          isNaN(i) || isNaN(h) || this.zoomToLongLat(g, i, h, !0);\n        }\n      }\n    },\n    parseXMLNode: function (x, w, v, u) {\n      void 0 === u && (u = \"\");\n      var t, s, r;\n      if (v) {\n        var q = v.childNodes.length;\n        for (t = 0; t < q; t++) {\n          s = v.childNodes[t];\n          var o = s.nodeName,\n            j = s.nodeValue ? this.trim(s.nodeValue) : \"\",\n            i = !1;\n          s.attributes && 0 < s.attributes.length && (i = !0);\n          if (0 !== s.childNodes.length || \"\" !== j || !1 !== i) {\n            if (3 == s.nodeType || 4 == s.nodeType) {\n              if (\"\" !== j) {\n                s = 0;\n                for (r in x[w]) {\n                  x[w].hasOwnProperty(r) && s++;\n                }\n                s ? x[w][\"#text\"] = j : x[w] = j;\n              }\n            } else {\n              if (1 == s.nodeType) {\n                var e;\n                void 0 !== x[w][o] ? void 0 === x[w][o].length ? (e = x[w][o], x[w][o] = [], x[w][o].push(e), x[w][o].push({}), e = x[w][o][1]) : \"object\" == typeof x[w][o] && (x[w][o].push({}), e = x[w][o][x[w][o].length - 1]) : (x[w][o] = {}, e = x[w][o]);\n                if (s.attributes && s.attributes.length) {\n                  for (j = 0; j < s.attributes.length; j++) {\n                    e[s.attributes[j].name] = s.attributes[j].value;\n                  }\n                }\n                void 0 !== x[w][o].length ? this.parseXMLNode(x[w][o], x[w][o].length - 1, s, u + \"  \") : this.parseXMLNode(x[w], o, s, u + \"  \");\n              }\n            }\n          }\n        }\n        s = 0;\n        v = \"\";\n        for (r in x[w]) {\n          \"#text\" == r ? v = x[w][r] : s++;\n        }\n        0 === s && void 0 === x[w].length && (x[w] = v);\n      }\n    },\n    doDoubleClickZoom: function () {\n      if (!this.mapWasDragged) {\n        var b = this.zoomLevel() * this.zoomControl.zoomFactor;\n        this.zoomToStageXY(b, this.mouseX, this.mouseY);\n      }\n    },\n    getDevInfo: function () {\n      var d = this.zoomLevel(),\n        c = this.mapSet.getBBox(),\n        c = this.xyToCoordinates((this.mouseX - this.mapContainer.x) / d - c.x * this.mapScale, (this.mouseY - this.mapContainer.y) / d - c.y * this.mapScale),\n        d = {\n          chart: this,\n          type: \"writeDevInfo\",\n          zoomLevel: d,\n          zoomX: this.zoomX(),\n          zoomY: this.zoomY(),\n          zoomLatitude: this.zoomLatitude(),\n          zoomLongitude: this.zoomLongitude(),\n          latitude: c.latitude,\n          longitude: c.longitude,\n          left: this.mouseX,\n          top: this.mouseY,\n          right: this.realWidth - this.mouseX,\n          bottom: this.realHeight - this.mouseY,\n          percentLeft: Math.round(this.mouseX / this.realWidth * 100) + \"%\",\n          percentTop: Math.round(this.mouseY / this.realHeight * 100) + \"%\",\n          percentRight: Math.round((this.realWidth - this.mouseX) / this.realWidth * 100) + \"%\",\n          percentBottom: Math.round((this.realHeight - this.mouseY) / this.realHeight * 100) + \"%\"\n        },\n        c = \"zoomLevel:\" + d.zoomLevel + \", zoomLongitude:\" + d.zoomLongitude + \", zoomLatitude:\" + d.zoomLatitude + \"\\n\",\n        c = c + (\"zoomX:\" + d.zoomX + \", zoomY:\" + d.zoomY + \"\\n\"),\n        c = c + (\"latitude:\" + d.latitude + \", longitude:\" + d.longitude + \"\\n\"),\n        c = c + (\"left:\" + d.left + \", top:\" + d.top + \"\\n\"),\n        c = c + (\"right:\" + d.right + \", bottom:\" + d.bottom + \"\\n\"),\n        c = c + (\"left:\" + d.percentLeft + \", top:\" + d.percentTop + \"\\n\"),\n        c = c + (\"right:\" + d.percentRight + \", bottom:\" + d.percentBottom + \"\\n\");\n      d.str = c;\n      this.fire(d);\n      return d;\n    },\n    getXY: function (e, d, f) {\n      void 0 !== e && (-1 != String(e).indexOf(\"%\") ? (e = Number(e.split(\"%\").join(\"\")), f && (e = 100 - e), e = Number(e) * d / 100) : f && (e = d - e));\n      return e;\n    },\n    getObjectById: function (e) {\n      var d = this.dataProvider;\n      if (d.areas) {\n        var f = this.getObject(e, d.areas);\n        if (f) {\n          return f;\n        }\n      }\n      if (f = this.getObject(e, d.images)) {\n        return f;\n      }\n      if (e = this.getObject(e, d.lines)) {\n        return e;\n      }\n    },\n    getObject: function (g, e) {\n      if (e) {\n        var j;\n        for (j = 0; j < e.length; j++) {\n          var i = e[j];\n          if (i.id == g) {\n            return i;\n          }\n          if (i.areas) {\n            var h = this.getObject(g, i.areas);\n            if (h) {\n              return h;\n            }\n          }\n          if (h = this.getObject(g, i.images)) {\n            return h;\n          }\n          if (i = this.getObject(g, i.lines)) {\n            return i;\n          }\n        }\n      }\n    },\n    parseData: function () {\n      var b = this.dataProvider;\n      this.processObject(b.areas, b, \"area\");\n      this.processObject(b.images, b, \"image\");\n      this.processObject(b.lines, b, \"line\");\n    },\n    processObject: function (g, d, j) {\n      if (g) {\n        var i;\n        for (i = 0; i < g.length; i++) {\n          var h = g[i];\n          h.parentObject = d;\n          \"area\" == j && a.extend(h, new a.MapArea(this.theme), !0);\n          \"image\" == j && (h = a.extend(h, new a.MapImage(this.theme), !0));\n          \"line\" == j && (h = a.extend(h, new a.MapLine(this.theme), !0));\n          g[i] = h;\n          h.areas && this.processObject(h.areas, h, \"area\");\n          h.images && this.processObject(h.images, h, \"image\");\n          h.lines && this.processObject(h.lines, h, \"line\");\n        }\n      }\n    },\n    positionChanged: function () {\n      var b = {\n        type: \"positionChanged\",\n        zoomX: this.zoomX(),\n        zoomY: this.zoomY(),\n        zoomLevel: this.zoomLevel(),\n        chart: this\n      };\n      this.fire(b);\n    },\n    getX: function (d, c) {\n      return this.getXY(d, this.realWidth, c);\n    },\n    getY: function (d, c) {\n      return this.getXY(d, this.realHeight, c);\n    },\n    trim: function (d) {\n      if (d) {\n        var c;\n        for (c = 0; c < d.length; c++) {\n          if (-1 === \" \\n\\r\\t\\f\\x0B\\u00a0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000\".indexOf(d.charAt(c))) {\n            d = d.substring(c);\n            break;\n          }\n        }\n        for (c = d.length - 1; 0 <= c; c--) {\n          if (-1 === \" \\n\\r\\t\\f\\x0B\\u00a0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000\".indexOf(d.charAt(c))) {\n            d = d.substring(0, c + 1);\n            break;\n          }\n        }\n        return -1 === \" \\n\\r\\t\\f\\x0B\\u00a0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000\".indexOf(d.charAt(0)) ? d : \"\";\n      }\n    },\n    destroy: function () {\n      a.AmMap.base.destroy.call(this);\n    },\n    x2c: function (d) {\n      var c = this.dataProvider.leftLongitude;\n      return Math.round(this.unscaledMapWidth * (d - c) / (this.dataProvider.rightLongitude - c) * 100) / 100;\n    },\n    y2c: function (d) {\n      var c = this.dataProvider.topLatitude;\n      return Math.round(this.unscaledMapHeight * (d - c) / (this.dataProvider.bottomLatitude - c) * 100) / 100;\n    },\n    normalize: function (e) {\n      if (!e.pathsArray) {\n        var d;\n        if (e.normalized) {\n          d = e.normalized;\n        } else {\n          var f = a.normalizePath(e.node);\n          d = e.node.getAttribute(\"d\");\n          e.normalized = d;\n          f.maxX > this.maxMapX && (this.maxMapX = f.maxX);\n          f.minX < this.minMapX && (this.minMapX = f.minX);\n          f.maxY > this.maxMapY && (this.maxMapY = f.maxY);\n          f.minY < this.minMapY && (this.minMapY = f.minY);\n        }\n        e.node.setAttribute(\"d\", d);\n      }\n    },\n    redraw: function (i) {\n      var e = i.normalized,\n        e = e.split(\" Z\").join(\"\"),\n        e = e.split(\"M\");\n      i.pathsArray = [];\n      for (var n = 0; n < e.length; n++) {\n        var m = e[n];\n        if (m) {\n          for (var m = m.split(\"L\"), l = [], k = 0; k < m.length; k++) {\n            if (m[k]) {\n              var j = m[k].split(\" \"),\n                j = this.xyToCoordinates(Number(j[1]) - this.minMapX, Number(j[2]) - this.minMapY, this.dpProjectionFunction, this.sourceMapWidth, this.sourceMapHeight);\n              l.push([j.longitude, j.latitude]);\n            }\n          }\n          i.pathsArray.push(l);\n        }\n      }\n      e = \"\";\n      for (n = 0; n < i.pathsArray.length; n++) {\n        e += this.redrawArea(i.pathsArray[n]);\n      }\n      i.node.setAttribute(\"d\", e);\n      i.path = e;\n    },\n    redrawArea: function (i) {\n      for (var d = !1, p = \"\", o = 0; o < i.length; o++) {\n        var n = i[o][0],\n          m = i[o][1],\n          l = a.degreesToRadians(i[o][0]),\n          j = a.degreesToRadians(i[o][1]),\n          j = this.projectionFunction(l, j),\n          l = a.roundTo(this.x2c(a.radiansToDegrees(j[0])), 3),\n          j = a.roundTo(this.y2c(a.radiansToDegrees(j[1])), 3);\n        l < this.minMapXX && (this.minMapXX = l, this.leftLongLat = {\n          longitude: n,\n          latitude: m\n        });\n        l > this.maxMapXX && (this.maxMapXX = l, this.rightLongLat = {\n          longitude: n,\n          latitude: m\n        });\n        j < this.minMapYY && (this.minMapYY = j, this.topLongLat = {\n          longitude: n,\n          latitude: m\n        });\n        j > this.maxMapYY && (this.maxMapYY = j, this.bottomLongLat = {\n          longitude: n,\n          latitude: m\n        });\n        d ? p += \" L \" : (p += \" M \", d = !0);\n        p += l + \" \" + j;\n      }\n      return p + \" Z \";\n    },\n    normalizeMap: function () {\n      var t = a.degreesToRadians(this.dataProvider.leftLongitude),\n        s = a.degreesToRadians(this.dataProvider.rightLongitude),\n        r = a.degreesToRadians(this.dataProvider.topLatitude),\n        q = a.degreesToRadians(this.dataProvider.bottomLatitude),\n        p = t + (s - t) / 2,\n        o = r + (q - r) / 2,\n        n = this.dpProjectionFunction(p, r)[1],\n        j = this.dpProjectionFunction(p, q)[1],\n        i = this.dpProjectionFunction(t, o)[0],\n        d = this.dpProjectionFunction(s, o)[0],\n        r = a.equirectangular(p, r),\n        q = a.equirectangular(p, q),\n        n = (r[1] - q[1]) / (n - j),\n        t = a.equirectangular(t, o),\n        s = a.equirectangular(s, o),\n        i = (t[0] - s[0]) / (i - d);\n      this.minMapX = Infinity;\n      this.maxMapX = -Infinity;\n      this.minMapY = Infinity;\n      this.maxMapY = -Infinity;\n      for (d = 0; d < this.svgAreas.length; d++) {\n        this.normalize(this.svgAreas[d]);\n      }\n      this.sourceMapHeight = Math.abs(this.maxMapY - this.minMapY);\n      this.sourceMapWidth = Math.abs(this.maxMapX - this.minMapX);\n      this.unscaledMapWidth = this.sourceMapWidth * i;\n      this.unscaledMapHeight = this.sourceMapHeight * n;\n      this.diffY = this.diffX = 0;\n    },\n    fixMapPosition: function () {\n      var t = a.degreesToRadians(this.dataProvider.leftLongitude),\n        s = a.degreesToRadians(this.dataProvider.rightLongitude),\n        r = a.degreesToRadians(this.dataProvider.topLatitude),\n        q = a.degreesToRadians(this.dataProvider.bottomLatitude),\n        p = t + (s - t) / 2,\n        o = r + (q - r) / 2,\n        n = this.dpProjectionFunction(p, r)[1],\n        j = this.dpProjectionFunction(p, q)[1],\n        i = this.dpProjectionFunction(t, o)[0],\n        d = this.dpProjectionFunction(s, o)[0];\n      this.sourceMapHeight = this.mapHeight / this.mapScale;\n      this.sourceMapWidth = this.mapWidth / this.mapScale;\n      this.unscaledMapWidth = (t - s) / (i - d) * this.sourceMapWidth;\n      this.unscaledMapHeight = (r - q) / (n - j) * this.sourceMapHeight;\n      s = this.coordinatesToXY(a.radiansToDegrees(p), a.radiansToDegrees(r));\n      t = this.coordinatesToXY(a.radiansToDegrees(t), a.radiansToDegrees(o));\n      r = o = Infinity;\n      for (q = 0; q < this.svgAreas.length; q++) {\n        p = this.svgAreas[q].getBBox(), p.y < o && (o = p.y), p.x < r && (r = p.x);\n      }\n      this.diffY = s.y / this.mapScale - o;\n      this.diffX = t.x / this.mapScale - r;\n      for (q = 0; q < this.svgAreas.length; q++) {\n        this.svgAreas[q].translate(this.diffX, this.diffY);\n      }\n    },\n    changeProjection: function () {\n      this.minMapXX = Infinity;\n      this.maxMapXX = -Infinity;\n      this.minMapYY = Infinity;\n      this.maxMapYY = -Infinity;\n      this.projectionChanged = !1;\n      for (var b = 0; b < this.svgAreas.length; b++) {\n        this.redraw(this.svgAreas[b]);\n      }\n      this.projectionChanged = !0;\n      this.resizeMap();\n    },\n    coordinatesToXY: function (f, d) {\n      var h, g;\n      h = !1;\n      this.dataProvider && (h = this.dataProvider.wrappedLongitudes) && (f = this.recalcLongitude(f));\n      this.projectionFunction ? (g = this.projectionFunction(a.degreesToRadians(f), a.degreesToRadians(d)), h = this.mapScale * a.roundTo(this.x2c(a.radiansToDegrees(g[0])), 3), g = this.mapScale * a.roundTo(this.y2c(a.radiansToDegrees(g[1])), 3)) : (h = this.longitudeToCoordinate(f), g = this.latitudeToCoordinate(d));\n      return {\n        x: h,\n        y: g\n      };\n    },\n    coordinatesToStageXY: function (f, e) {\n      var h = this.coordinatesToXY(f, e),\n        g = h.x * this.zoomLevel() + this.mapContainer.x,\n        h = h.y * this.zoomLevel() + this.mapContainer.y;\n      return {\n        x: g,\n        y: h\n      };\n    },\n    stageXYToCoordinates: function (f, e) {\n      var h = this.mapSet.getBBox(),\n        g = (f - this.mapContainer.x) / this.zoomLevel() - h.x * this.mapScale,\n        h = (e - this.mapContainer.y) / this.zoomLevel() - h.y * this.mapScale;\n      return this.xyToCoordinates(g, h);\n    },\n    xyToCoordinates: function (x, w, v, u, t) {\n      var s;\n      isNaN(u) && (u = this.mapWidth);\n      isNaN(t) && (t = this.mapHeight);\n      v || (v = this.projectionFunction);\n      if (s = v.invert) {\n        var r = this.dataProvider.leftLongitude,\n          q = this.dataProvider.rightLongitude,\n          o = this.dataProvider.topLatitude,\n          j = this.dataProvider.bottomLatitude,\n          i = r + (q - r) / 2,\n          d = o + (j - o) / 2,\n          o = a.radiansToDegrees(v(a.degreesToRadians(i), a.degreesToRadians(o))[1]),\n          j = a.radiansToDegrees(v(a.degreesToRadians(i), a.degreesToRadians(j))[1]),\n          r = a.radiansToDegrees(v(a.degreesToRadians(r), a.degreesToRadians(d))[0]),\n          q = a.radiansToDegrees(v(a.degreesToRadians(q), a.degreesToRadians(d))[0]);\n        this.projectionChanged && (o = a.radiansToDegrees(v(a.degreesToRadians(this.topLongLat.longitude), a.degreesToRadians(this.topLongLat.latitude))[1]), j = a.radiansToDegrees(v(a.degreesToRadians(this.bottomLongLat.longitude), a.degreesToRadians(this.bottomLongLat.latitude))[1]), r = a.radiansToDegrees(v(a.degreesToRadians(this.leftLongLat.longitude), a.degreesToRadians(this.leftLongLat.latitude))[0]), q = a.radiansToDegrees(v(a.degreesToRadians(this.rightLongLat.longitude), a.degreesToRadians(this.rightLongLat.latitude))[0]));\n        x = a.degreesToRadians(x / u * (q - r) + r);\n        w = a.degreesToRadians(w / t * (j - o) + o);\n        w = s(x, w);\n        s = a.radiansToDegrees(w[0]);\n        w = a.radiansToDegrees(w[1]);\n      } else {\n        s = this.coordinateToLongitude(x), w = this.coordinateToLatitude(w);\n      }\n      return {\n        longitude: a.roundTo(s, 4),\n        latitude: a.roundTo(w, 4)\n      };\n    },\n    coordinateToLatitude: function (g, d) {\n      var j;\n      void 0 === d && (d = this.mapHeight);\n      if (this.mapSet) {\n        var i = this.dataProvider,\n          h = i.bottomLatitude;\n        j = i.topLatitude;\n        \"mercator\" == i.projection ? (i = this.mercatorLatitudeToCoordinate(h), j = this.mercatorLatitudeToCoordinate(j), j = 2 * a.degreesToRadians(g * (i - j) / d + j), j = a.radiansToDegrees(2 * Math.atan(Math.exp(j)) - 0.5 * Math.PI)) : j = g / d * (h - j) + j;\n      }\n      return Math.round(1000000 * j) / 1000000;\n    },\n    coordinateToLongitude: function (f, e) {\n      var h,\n        g = this.dataProvider;\n      void 0 === e && (e = this.mapWidth);\n      this.mapSet && (h = f / e * (g.rightLongitude - g.leftLongitude) + g.leftLongitude);\n      return Math.round(1000000 * h) / 1000000;\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.ZoomControl = a.Class({\n    construct: function (b) {\n      this.cname = \"ZoomControl\";\n      this.panStepSize = 0.1;\n      this.zoomFactor = 2;\n      this.maxZoomLevel = 64;\n      this.minZoomLevel = 1;\n      this.panControlEnabled = !1;\n      this.zoomControlEnabled = !0;\n      this.buttonRollOverColor = \"#DADADA\";\n      this.buttonFillColor = \"#FFFFFF\";\n      this.buttonFillAlpha = 1;\n      this.buttonBorderColor = \"#000000\";\n      this.buttonBorderAlpha = 0.1;\n      this.buttonIconAlpha = this.buttonBorderThickness = 1;\n      this.gridColor = this.buttonIconColor = \"#000000\";\n      this.homeIconFile = \"homeIcon.gif\";\n      this.gridBackgroundColor = \"#000000\";\n      this.draggerAlpha = this.gridAlpha = this.gridBackgroundAlpha = 0;\n      this.draggerSize = this.buttonSize = 31;\n      this.iconSize = 11;\n      this.homeButtonEnabled = !0;\n      this.buttonCornerRadius = 2;\n      this.gridHeight = 5;\n      this.roundButtons = !0;\n      this.top = this.left = 10;\n      a.applyTheme(this, b, this.cname);\n    },\n    init: function (af, ae) {\n      var ad = this;\n      ad.chart = af;\n      a.remove(ad.set);\n      var ac = ae.set();\n      a.setCN(af, ac, \"zoom-control\");\n      var ab = ad.buttonSize,\n        aa = ad.zoomControlEnabled,\n        Z = ad.panControlEnabled,\n        Y = ad.buttonFillColor,\n        X = ad.buttonFillAlpha,\n        W = ad.buttonBorderThickness,\n        V = ad.buttonBorderColor,\n        U = ad.buttonBorderAlpha,\n        N = ad.buttonCornerRadius,\n        Q = ad.buttonRollOverColor,\n        S = ad.gridHeight,\n        i = ad.zoomFactor,\n        R = ad.minZoomLevel,\n        L = ad.maxZoomLevel,\n        s = ad.buttonIconAlpha,\n        J = ad.buttonIconColor,\n        T = ad.roundButtons,\n        P = af.svgIcons,\n        j = af.getX(ad.left),\n        d = af.getY(ad.top);\n      isNaN(ad.right) || (j = af.getX(ad.right, !0), j = Z ? j - 3 * ab : j - ab);\n      isNaN(ad.bottom) || (d = af.getY(ad.bottom, !0), aa && (d -= S + 3 * ab), d = Z ? d - 3 * ab : ad.homeButtonEnabled ? d - 0.5 * ab : d + ab);\n      ac.translate(j, d);\n      ad.previousDY = NaN;\n      var K,\n        j = ab / 4 - 1;\n      if (aa) {\n        K = ae.set();\n        a.setCN(af, K, \"zoom-control-zoom\");\n        ac.push(K);\n        ad.set = ac;\n        ad.zoomSet = K;\n        5 < S && (aa = a.rect(ae, ab + 6, S + 2 * ab + 6, ad.gridBackgroundColor, ad.gridBackgroundAlpha, 0, \"#000000\", 0, 4), a.setCN(af, aa, \"zoom-bg\"), aa.translate(-3, -3), aa.mouseup(function () {\n          ad.handleBgUp();\n        }).touchend(function () {\n          ad.handleBgUp();\n        }), K.push(aa));\n        var M = ab;\n        T && (M = ab / 1.5);\n        ad.draggerSize = M;\n        var o = Math.log(L / R) / Math.log(i) + 1;\n        1000 < o && (o = 1000);\n        var aa = S / o,\n          I,\n          O = ae.set();\n        O.translate((ab - M) / 2 + 1, 1, NaN, !0);\n        K.push(O);\n        for (I = 1; I < o; I++) {\n          d = ab + I * aa, d = a.line(ae, [1, M - 2], [d, d], ad.gridColor, ad.gridAlpha, 1), a.setCN(af, d, \"zoom-grid\"), O.push(d);\n        }\n        d = new a.SimpleButton();\n        d.setDownHandler(ad.draggerDown, ad);\n        d.setClickHandler(ad.draggerUp, ad);\n        d.init(ae, M, aa, Y, X, W, V, U, N, Q);\n        a.setCN(af, d.set, \"zoom-dragger\");\n        K.push(d.set);\n        d.set.setAttr(\"opacity\", ad.draggerAlpha);\n        ad.dragger = d.set;\n        ad.previousY = NaN;\n        d = new a.SimpleButton();\n        P ? (M = ae.set(), o = a.line(ae, [-j, j], [0, 0], J, s, 1), I = a.line(ae, [0, 0], [-j, j], J, s, 1), M.push(o), M.push(I), d.svgIcon = M) : d.setIcon(af.pathToImages + \"plus.gif\", ad.iconSize);\n        d.setClickHandler(af.zoomIn, af);\n        d.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T);\n        a.setCN(af, d.set, \"zoom-in\");\n        K.push(d.set);\n        d = new a.SimpleButton();\n        P ? d.svgIcon = a.line(ae, [-j, j], [0, 0], J, s, 1) : d.setIcon(af.pathToImages + \"minus.gif\", ad.iconSize);\n        d.setClickHandler(af.zoomOut, af);\n        d.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T);\n        d.set.translate(0, S + ab);\n        a.setCN(af, d.set, \"zoom-out\");\n        K.push(d.set);\n        S -= aa;\n        L = Math.log(L / 100) / Math.log(i);\n        ad.realStepSize = S / (L - Math.log(R / 100) / Math.log(i));\n        ad.realGridHeight = S;\n        ad.stepMax = L;\n      }\n      Z && (Z = ae.set(), a.setCN(af, Z, \"zoom-control-pan\"), ac.push(Z), K && K.translate(ab, 4 * ab), i = new a.SimpleButton(), P ? i.svgIcon = a.line(ae, [j / 5, -j + j / 5, j / 5], [-j, 0, j], J, s, 1) : i.setIcon(af.pathToImages + \"panLeft.gif\", ad.iconSize), i.setClickHandler(af.moveLeft, af), i.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T), i.set.translate(0, ab), a.setCN(af, i.set, \"pan-left\"), Z.push(i.set), i = new a.SimpleButton(), P ? i.svgIcon = a.line(ae, [-j / 5, j - j / 5, -j / 5], [-j, 0, j], J, s, 1) : i.setIcon(af.pathToImages + \"panRight.gif\", ad.iconSize), i.setClickHandler(af.moveRight, af), i.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T), i.set.translate(2 * ab, ab), a.setCN(af, i.set, \"pan-right\"), Z.push(i.set), i = new a.SimpleButton(), P ? i.svgIcon = a.line(ae, [-j, 0, j], [j / 5, -j + j / 5, j / 5], J, s, 1) : i.setIcon(af.pathToImages + \"panUp.gif\", ad.iconSize), i.setClickHandler(af.moveUp, af), i.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T), i.set.translate(ab, 0), a.setCN(af, i.set, \"pan-up\"), Z.push(i.set), i = new a.SimpleButton(), P ? i.svgIcon = a.line(ae, [-j, 0, j], [-j / 5, j - j / 5, -j / 5], J, s, 1) : i.setIcon(af.pathToImages + \"panDown.gif\", ad.iconSize), i.setClickHandler(af.moveDown, af), i.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T), i.set.translate(ab, 2 * ab), a.setCN(af, i.set, \"pan-down\"), Z.push(i.set), ac.push(Z));\n      ad.homeButtonEnabled && (Z = new a.SimpleButton(), P ? Z.svgIcon = a.polygon(ae, [-j, 0, j, j - 1, j - 1, 2, 2, -2, -2, -j + 1, -j + 1], [0, -j, 0, 0, j - 1, j - 1, 2, 2, j - 1, j - 1, 0], J, s, 1, J, s) : Z.setIcon(af.pathToImages + ad.homeIconFile, ad.iconSize), Z.setClickHandler(af.goHome, af), ad.panControlEnabled && (U = X = 0), Z.init(ae, ab, ab, Y, X, W, V, U, N, Q, s, J, T), ad.panControlEnabled ? Z.set.translate(ab, ab) : K && K.translate(0, 1.5 * ab), a.setCN(af, Z.set, \"pan-home\"), ac.push(Z.set));\n      ad.update();\n    },\n    draggerDown: function () {\n      this.chart.stopDrag();\n      this.isDragging = !0;\n    },\n    draggerUp: function () {\n      this.isDragging = !1;\n    },\n    handleBgUp: function () {\n      var b = this.chart;\n      b.zoomTo(100 * Math.pow(this.zoomFactor, this.stepMax - (b.mouseY - this.zoomSet.y - this.set.y - this.buttonSize - this.realStepSize / 2) / this.realStepSize));\n    },\n    update: function () {\n      var i;\n      i = this.zoomFactor;\n      var d = this.realStepSize,\n        n = this.stepMax,\n        m = this.dragger,\n        l = this.buttonSize,\n        k,\n        j = this.chart;\n      j && (this.isDragging ? (j.stopDrag(), k = m.y + (j.mouseY - this.previousY), k = a.fitToBounds(k, l, this.realGridHeight + l), j.zoomTo(100 * Math.pow(i, n - (k - l) / d), NaN, NaN, !0)) : (i = Math.log(j.zoomLevel() / 100) / Math.log(i), k = (n - i) * d + l), this.previousY = j.mouseY, this.previousDY != k && m && (m.translate((this.buttonSize - this.draggerSize) / 2, k), this.previousDY = k));\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.SimpleButton = a.Class({\n    construct: function () {},\n    init: function (C, B, A, z, y, x, w, v, u, s, o, j, D) {\n      var d = this;\n      d.rollOverColor = s;\n      d.color = z;\n      d.container = C;\n      s = C.set();\n      d.set = s;\n      D ? (B /= 2, z = a.circle(C, B, z, y, x, w, v), z.translate(B, B)) : z = a.rect(C, B, A, z, y, x, w, v, u);\n      s.push(z);\n      y = d.iconPath;\n      var i;\n      y && (i = d.iconSize, x = (B - i) / 2, D && (x = (2 * B - i) / 2), i = C.image(y, x, (A - i) / 2, i, i));\n      d.svgIcon && (i = d.svgIcon, D ? i.translate(B, B) : i.translate(B / 2, B / 2));\n      s.setAttr(\"cursor\", \"pointer\");\n      i && (s.push(i), i.setAttr(\"opacity\", o), i.node.style.pointerEvents = \"none\");\n      z.mousedown(function () {\n        d.handleDown();\n      }).touchstart(function () {\n        d.handleDown();\n      }).mouseup(function () {\n        d.handleUp();\n      }).touchend(function () {\n        d.handleUp();\n      }).mouseover(function () {\n        d.handleOver();\n      }).mouseout(function () {\n        d.handleOut();\n      });\n      d.bg = z;\n    },\n    setIcon: function (d, c) {\n      this.iconPath = d;\n      this.iconSize = c;\n    },\n    setClickHandler: function (d, c) {\n      this.clickHandler = d;\n      this.scope = c;\n    },\n    setDownHandler: function (d, c) {\n      this.downHandler = d;\n      this.scope = c;\n    },\n    handleUp: function () {\n      var b = this.clickHandler;\n      b && b.call(this.scope);\n    },\n    handleDown: function () {\n      var b = this.downHandler;\n      b && b.call(this.scope);\n    },\n    handleOver: function () {\n      this.container.chart.skipClick = !0;\n      this.bg.setAttr(\"fill\", this.rollOverColor);\n    },\n    handleOut: function () {\n      this.container.chart.skipClick = !1;\n      this.bg.setAttr(\"fill\", this.color);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.SmallMap = a.Class({\n    construct: function (b) {\n      this.cname = \"SmallMap\";\n      this.mapColor = \"#e6e6e6\";\n      this.rectangleColor = \"#FFFFFF\";\n      this.top = this.right = 10;\n      this.minimizeButtonWidth = 23;\n      this.backgroundColor = \"#9A9A9A\";\n      this.backgroundAlpha = 1;\n      this.borderColor = \"#FFFFFF\";\n      this.iconColor = \"#000000\";\n      this.borderThickness = 3;\n      this.borderAlpha = 1;\n      this.size = 0.2;\n      this.enabled = !0;\n      a.applyTheme(this, b, this.cname);\n    },\n    init: function (C, B) {\n      var A = this;\n      if (A.enabled) {\n        A.chart = C;\n        A.container = B;\n        A.width = C.realWidth * A.size;\n        A.height = C.realHeight * A.size;\n        a.remove(A.mapSet);\n        a.remove(A.allSet);\n        a.remove(A.set);\n        var z = B.set();\n        A.set = z;\n        a.setCN(C, z, \"small-map\");\n        var y = B.set();\n        A.allSet = y;\n        z.push(y);\n        A.buildSVGMap();\n        var x = A.borderThickness,\n          w = A.borderColor,\n          v = a.rect(B, A.width + x, A.height + x, A.backgroundColor, A.backgroundAlpha, x, w, A.borderAlpha);\n        a.setCN(C, v, \"small-map-bg\");\n        v.translate(-x / 2, -x / 2);\n        y.push(v);\n        v.toBack();\n        var u,\n          s,\n          v = A.minimizeButtonWidth,\n          o = new a.SimpleButton(),\n          j = v / 2;\n        C.svgIcons ? o.svgIcon = a.line(B, [-j / 2, 0, j / 2], [-j / 4, j / 4, -j / 4], A.iconColor, 1, 1) : o.setIcon(C.pathToImages + \"arrowDown.gif\", v);\n        o.setClickHandler(A.minimize, A);\n        o.init(B, v, v, w, 1, 1, w, 1);\n        a.setCN(C, o.set, \"small-map-down\");\n        o = o.set;\n        A.downButtonSet = o;\n        z.push(o);\n        var D = new a.SimpleButton();\n        C.svgIcons ? D.svgIcon = a.line(B, [-j / 2, 0, j / 2], [j / 4, -j / 4, j / 4], A.iconColor, 1, 1) : D.setIcon(C.pathToImages + \"arrowUp.gif\", v);\n        D.setClickHandler(A.maximize, A);\n        D.init(B, v, v, w, 1, 1, w, 1);\n        a.setCN(C, D.set, \"small-map-up\");\n        w = D.set;\n        A.upButtonSet = w;\n        w.hide();\n        z.push(w);\n        var d, i;\n        isNaN(A.top) || (u = C.getY(A.top) + x, i = 0);\n        isNaN(A.bottom) || (u = C.getY(A.bottom, !0) - A.height - x, i = A.height - v + x / 2);\n        isNaN(A.left) || (s = C.getX(A.left) + x, d = -x / 2);\n        isNaN(A.right) || (s = C.getX(A.right, !0) - A.width - x, d = A.width - v + x / 2);\n        x = B.set();\n        x.clipRect(1, 1, A.width, A.height);\n        y.push(x);\n        A.rectangleC = x;\n        z.translate(s, u);\n        o.translate(d, i);\n        w.translate(d, i);\n        y.mouseup(function () {\n          A.handleMouseUp();\n        });\n        A.drawRectangle();\n      } else {\n        a.remove(A.allSet), a.remove(A.downButtonSet), a.remove(A.upButtonSet);\n      }\n    },\n    minimize: function () {\n      this.downButtonSet.hide();\n      this.upButtonSet.show();\n      this.allSet.hide();\n    },\n    maximize: function () {\n      this.downButtonSet.show();\n      this.upButtonSet.hide();\n      this.allSet.show();\n    },\n    buildSVGMap: function () {\n      var i = this.chart,\n        d = {\n          fill: this.mapColor,\n          stroke: this.mapColor,\n          \"stroke-opacity\": 1\n        },\n        p = this.container,\n        o = p.set();\n      a.setCN(i, o, \"small-map-image\");\n      var n;\n      for (n = 0; n < i.svgAreas.length; n++) {\n        var m = p.path(i.svgAreas[n].path).attr(d);\n        o.push(m);\n      }\n      this.allSet.push(o);\n      d = o.getBBox();\n      p = this.size * i.mapScale;\n      n = -d.x * p;\n      var m = -d.y * p,\n        l = 0,\n        j = 0;\n      i.centerMap && (l = (this.width - d.width * p) / 2, j = (this.height - d.height * p) / 2);\n      this.mapWidth = d.width * p;\n      this.mapHeight = d.height * p;\n      n += l;\n      m += j;\n      this.dx = l;\n      this.dy = j;\n      o.translate(n, m, p);\n      this.mapSet = o;\n      this.mapX = n;\n      this.mapY = m;\n    },\n    update: function () {\n      var i = this.chart;\n      if (i) {\n        var e = i.zoomLevel(),\n          n = this.width,\n          m = this.height,\n          l = n / (i.realWidth * e),\n          k = i.mapContainer.getBBox(),\n          n = n / e,\n          m = m / e,\n          j = this.rectangle;\n        j.translate(-(i.mapContainer.x + k.x * e) * l + this.dx, -(i.mapContainer.y + k.y * e) * l + this.dy);\n        0 < n && 0 < m && (j.setAttr(\"width\", Math.ceil(n + 1)), j.setAttr(\"height\", Math.ceil(m + 1)));\n        this.rWidth = n;\n        this.rHeight = m;\n      }\n    },\n    drawRectangle: function () {\n      var b = this.rectangle;\n      a.remove(b);\n      b = a.rect(this.container, 10, 10, \"#000\", 0, 1, this.rectangleColor, 1);\n      a.setCN(this.chart, b, \"small-map-rectangle\");\n      this.rectangleC.push(b);\n      this.rectangle = b;\n    },\n    handleMouseUp: function () {\n      var d = this.chart,\n        c = d.zoomLevel();\n      d.zoomToMapXY(c, (d.mouseX - this.set.x - this.mapX) / this.size + d.diffX * d.mapScale, (d.mouseY - this.set.y - this.mapY) / this.size + d.diffY * d.mapScale);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AreasProcessor = a.Class({\n    construct: function (b) {\n      this.chart = b;\n    },\n    process: function (r) {\n      this.updateAllAreas();\n      this.allObjects = [];\n      r = r.areas;\n      var q = this.chart;\n      q.outlines = [];\n      var p = r.length,\n        o,\n        n,\n        m = 0,\n        j = !1,\n        i = !1,\n        e = 0;\n      for (o = 0; o < p; o++) {\n        if (n = r[o], n.value = Number(n.value), n = n.value, !isNaN(n)) {\n          if (!1 === j || j < n) {\n            j = n;\n          }\n          if (!1 === i || i > n) {\n            i = n;\n          }\n          m += Math.abs(n);\n          e++;\n        }\n      }\n      this.minValue = i;\n      this.maxValue = j;\n      isNaN(q.minValue) || (this.minValue = q.minValue);\n      isNaN(q.maxValue) || (this.maxValue = q.maxValue);\n      q.maxValueReal = j;\n      q.minValueReal = i;\n      for (o = 0; o < p; o++) {\n        n = r[o], isNaN(n.value) ? n.percents = void 0 : (n.percents = (n.value - i) / m * 100, i == j && (n.percents = 100));\n      }\n      for (o = 0; o < p; o++) {\n        n = r[o], this.createArea(n);\n      }\n      q.outlinesToFront();\n    },\n    updateAllAreas: function () {\n      var y = this.chart,\n        x = y.areasSettings,\n        w = x.unlistedAreasColor,\n        v = x.unlistedAreasAlpha,\n        u = x.unlistedAreasOutlineColor,\n        s = x.unlistedAreasOutlineAlpha,\n        r = y.svgAreas,\n        q = y.dataProvider,\n        o = q.areas,\n        j = {},\n        i;\n      for (i = 0; i < o.length; i++) {\n        j[o[i].id] = o[i];\n      }\n      for (i = 0; i < r.length; i++) {\n        o = r[i];\n        if (x.preserveOriginalAttributes) {\n          if (o.customAttr) {\n            for (var d in o.customAttr) {\n              o.setAttr(d, o.customAttr[d]);\n            }\n          }\n        } else {\n          void 0 != w && o.setAttr(\"fill\", w);\n          isNaN(v) || o.setAttr(\"fill-opacity\", v);\n          void 0 != u && o.setAttr(\"stroke\", u);\n          isNaN(s) || o.setAttr(\"stroke-opacity\", s);\n          var z = x.outlineThickness;\n          x.adjustOutlineThickness && (z = z / y.zoomLevel() / y.mapScale);\n          o.setAttr(\"stroke-width\", z);\n        }\n        a.setCN(y, o, \"map-area-unlisted\");\n        q.getAreasFromMap && !j[o.id] && (z = new a.MapArea(y.theme), z.parentObject = q, z.id = o.id, z.outline = o.outline, q.areas.push(z));\n      }\n    },\n    createArea: function (R) {\n      var Q = this.chart,\n        P = Q.svgAreasById[R.id],\n        O = Q.areasSettings;\n      if (P && P.className) {\n        var N = Q.areasClasses[P.className];\n        N && (O = a.processObject(N, a.AreasSettings, Q.theme));\n      }\n      var M = O.color,\n        L = O.alpha,\n        K = O.outlineThickness,\n        J = O.rollOverColor,\n        I = O.selectedColor,\n        H = O.rollOverAlpha,\n        G = O.rollOverBrightness,\n        s = O.outlineColor,\n        z = O.outlineAlpha,\n        E = O.balloonText,\n        d = O.selectable,\n        D = O.pattern,\n        o = O.rollOverOutlineColor,\n        i = O.bringForwardOnHover,\n        j = O.preserveOriginalAttributes;\n      this.allObjects.push(R);\n      R.chart = Q;\n      R.baseSettings = O;\n      R.autoZoomReal = void 0 == R.autoZoom ? O.autoZoom : R.autoZoom;\n      N = R.color;\n      void 0 == N && (N = M);\n      var F = R.alpha;\n      isNaN(F) && (F = L);\n      L = R.rollOverAlpha;\n      isNaN(L) && (L = H);\n      isNaN(L) && (L = F);\n      H = R.rollOverColor;\n      void 0 == H && (H = J);\n      J = R.pattern;\n      void 0 == J && (J = D);\n      D = R.selectedColor;\n      void 0 == D && (D = I);\n      I = R.balloonText;\n      void 0 === I && (I = E);\n      void 0 == O.colorSolid || isNaN(R.value) || (E = Math.floor((R.value - this.minValue) / ((this.maxValue - this.minValue) / Q.colorSteps)), E == Q.colorSteps && E--, E *= 1 / (Q.colorSteps - 1), this.maxValue == this.minValue && (E = 1), R.colorReal = a.getColorFade(N, O.colorSolid, E));\n      void 0 != R.color && (R.colorReal = R.color);\n      void 0 == R.selectable && (R.selectable = d);\n      void 0 == R.colorReal && (R.colorReal = M);\n      M = R.outlineColor;\n      void 0 == M && (M = s);\n      s = R.outlineAlpha;\n      isNaN(s) && (s = z);\n      z = R.outlineThickness;\n      isNaN(z) && (z = K);\n      K = R.rollOverOutlineColor;\n      void 0 == K && (K = o);\n      o = R.rollOverBrightness;\n      void 0 == o && (o = G);\n      void 0 == R.bringForwardOnHover && (R.bringForwardOnHover = i);\n      void 0 == R.preserveOriginalAttributes && (R.preserveOriginalAttributes = j);\n      isNaN(O.selectedBrightness) || (D = a.adjustLuminosity(R.colorReal, O.selectedBrightness / 100));\n      R.alphaReal = F;\n      R.rollOverColorReal = H;\n      R.rollOverAlphaReal = L;\n      R.balloonTextReal = I;\n      R.selectedColorReal = D;\n      R.outlineColorReal = M;\n      R.outlineAlphaReal = s;\n      R.rollOverOutlineColorReal = K;\n      R.outlineThicknessReal = z;\n      R.patternReal = J;\n      R.rollOverBrightnessReal = o;\n      R.accessibleLabel || (R.accessibleLabel = O.accessibleLabel);\n      a.processDescriptionWindow(O, R);\n      if (P && (G = P.area, i = P.title, R.enTitle = P.title, i && !R.title && (R.title = i), (P = Q.language) ? (i = a.mapTranslations) && (P = i[P]) && P[R.enTitle] && (R.titleTr = P[R.enTitle]) : R.titleTr = void 0, G)) {\n        P = R.tabIndex;\n        void 0 === P && (P = O.tabIndex);\n        void 0 !== P && G.setAttr(\"tabindex\", P);\n        R.displayObject = G;\n        R.outline && (F = 0, R.alphaReal = 0, R.rollOverAlphaReal = 0, R.mouseEnabled = !1, Q.outlines.push(G), G.node.setAttribute(\"pointer-events\", \"none\"));\n        R.mouseEnabled && Q.addObjectEventListeners(G, R);\n        var x;\n        void 0 != N && (x = N);\n        void 0 != R.colorReal && (x = R.showAsSelected || Q.selectedObject == R ? R.selectedColorReal : R.colorReal);\n        G.node.setAttribute(\"class\", \"\");\n        a.setCN(Q, G, \"map-area\");\n        a.setCN(Q, G, \"map-area-\" + G.id);\n        O.adjustOutlineThickness && (z = z / Q.zoomLevel() / Q.mapScale);\n        R.preserveOriginalAttributes || (G.setAttr(\"fill\", x), G.setAttr(\"stroke\", M), G.setAttr(\"stroke-opacity\", s), G.setAttr(\"stroke-width\", z), G.setAttr(\"fill-opacity\", F));\n        Q.makeObjectAccessible(R);\n        J && G.pattern(J, Q.mapScale, Q.path);\n        R.hidden && G.hide();\n      }\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.AreasSettings = a.Class({\n    construct: function (b) {\n      this.cname = \"AreasSettings\";\n      this.alpha = 1;\n      this.autoZoom = !1;\n      this.balloonText = \"[[title]]\";\n      this.color = \"#FFCC00\";\n      this.colorSolid = \"#990000\";\n      this.unlistedAreasAlpha = 1;\n      this.unlistedAreasColor = \"#DDDDDD\";\n      this.outlineColor = \"#FFFFFF\";\n      this.outlineThickness = this.outlineAlpha = 1;\n      this.selectedColor = this.rollOverOutlineColor = \"#CC0000\";\n      this.unlistedAreasOutlineColor = \"#FFFFFF\";\n      this.unlistedAreasOutlineAlpha = 1;\n      this.descriptionWindowWidth = 250;\n      this.bringForwardOnHover = this.adjustOutlineThickness = !0;\n      this.accessibleLabel = \"[[title]] [[value]] [[description]]\";\n      a.applyTheme(this, b, this.cname);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.ImagesProcessor = a.Class({\n    construct: function (b) {\n      this.chart = b;\n      this.reset();\n    },\n    process: function (f) {\n      var e = f.images,\n        h;\n      for (h = e.length - 1; 0 <= h; h--) {\n        var g = e[h];\n        this.createImage(g, h);\n        g.parentArray = e;\n      }\n      this.counter = h;\n      f.parentObject && f.remainVisible && this.process(f.parentObject);\n    },\n    createImage: function (af, ae) {\n      af = a.processObject(af, a.MapImage);\n      af.arrays = [];\n      isNaN(ae) && (this.counter++, ae = this.counter);\n      var ad = this.chart,\n        ac = ad.container,\n        ab = ad.mapImagesContainer,\n        aa = ad.stageImagesContainer,\n        Z = ad.imagesSettings;\n      af.remove && af.remove();\n      var Y = Z.color,\n        X = Z.alpha,\n        W = Z.rollOverColor,\n        V = Z.rollOverOutlineColor,\n        U = Z.selectedColor,\n        N = Z.balloonText,\n        Q = Z.outlineColor,\n        S = Z.outlineAlpha,\n        i = Z.outlineThickness,\n        R = Z.selectedScale,\n        L = Z.rollOverScale,\n        s = Z.selectable,\n        J = Z.labelPosition,\n        T = Z.labelColor,\n        P = Z.labelFontSize,\n        j = Z.bringForwardOnHover,\n        d = Z.labelRollOverColor,\n        K = Z.rollOverBrightness,\n        M = Z.selectedLabelColor;\n      af.index = ae;\n      af.chart = ad;\n      af.baseSettings = ad.imagesSettings;\n      var o = ac.set();\n      af.displayObject = o;\n      var I = af.color;\n      void 0 == I && (I = Y);\n      Y = af.alpha;\n      isNaN(Y) && (Y = X);\n      void 0 == af.bringForwardOnHover && (af.bringForwardOnHover = j);\n      X = af.outlineAlpha;\n      isNaN(X) && (X = S);\n      S = af.rollOverColor;\n      void 0 == S && (S = W);\n      W = af.selectedColor;\n      void 0 == W && (W = U);\n      U = af.balloonText;\n      void 0 === U && (U = N);\n      N = af.outlineColor;\n      void 0 == N && (N = Q);\n      af.outlineColorReal = N;\n      Q = af.outlineThickness;\n      isNaN(Q) && (Q = i);\n      (i = af.labelPosition) || (i = J);\n      J = af.labelColor;\n      void 0 == J && (J = T);\n      T = af.labelRollOverColor;\n      void 0 == T && (T = d);\n      d = af.selectedLabelColor;\n      void 0 == d && (d = M);\n      M = af.labelFontSize;\n      isNaN(M) && (M = P);\n      P = af.selectedScale;\n      isNaN(P) && (P = R);\n      R = af.rollOverScale;\n      isNaN(R) && (R = L);\n      L = af.rollOverBrightness;\n      void 0 == L && (L = K);\n      void 0 == af.selectable && (af.selectable = s);\n      af.colorReal = I;\n      isNaN(Z.selectedBrightness) || (W = a.adjustLuminosity(af.colorReal, Z.selectedBrightness / 100));\n      af.alphaReal = Y;\n      af.rollOverColorReal = S;\n      af.balloonTextReal = U;\n      af.selectedColorReal = W;\n      af.labelColorReal = J;\n      af.labelRollOverColorReal = T;\n      af.selectedLabelColorReal = d;\n      af.labelFontSizeReal = M;\n      af.labelPositionReal = i;\n      af.selectedScaleReal = P;\n      af.rollOverScaleReal = R;\n      af.rollOverOutlineColorReal = V;\n      af.rollOverBrightnessReal = L;\n      af.accessibleLabel || (af.accessibleLabel = Z.accessibleLabel);\n      a.processDescriptionWindow(Z, af);\n      af.centeredReal = void 0 == af.centered ? Z.centered : af.centered;\n      V = af.type;\n      L = af.imageURL;\n      R = af.svgPath;\n      P = af.width;\n      M = af.height;\n      s = af.scale;\n      isNaN(af.percentWidth) || (P = af.percentWidth / 100 * ad.realWidth);\n      isNaN(af.percentHeight) || (M = af.percentHeight / 100 * ad.realHeight);\n      var O;\n      L || V || R || (V = \"circle\", P = 1, X = Y = 0);\n      S = K = 0;\n      Z = af.selectedColorReal;\n      if (V) {\n        isNaN(P) && (P = 10);\n        isNaN(M) && (M = 10);\n        \"kilometers\" == af.widthAndHeightUnits && (P = ad.kilometersToPixels(af.width), M = ad.kilometersToPixels(af.height));\n        \"miles\" == af.widthAndHeightUnits && (P = ad.milesToPixels(af.width), M = ad.milesToPixels(af.height));\n        if (\"circle\" == V || \"bubble\" == V) {\n          M = P;\n        }\n        O = this.createPredefinedImage(I, N, Q, V, P, M);\n        S = K = 0;\n        af.centeredReal ? (isNaN(af.right) || (K = P * s), isNaN(af.bottom) || (S = M * s)) : (K = P * s / 2, S = M * s / 2);\n        O.translate(K, S, s, !0);\n      } else {\n        L ? (isNaN(P) && (P = 10), isNaN(M) && (M = 10), O = ac.image(L, 0, 0, P, M), O.node.setAttribute(\"preserveAspectRatio\", \"none\"), O.setAttr(\"opacity\", Y), af.centeredReal && (K = isNaN(af.right) ? -P / 2 : P / 2, S = isNaN(af.bottom) ? -M / 2 : M / 2, O.translate(K, S, NaN, !0))) : R && (O = ac.path(R), L = O.getBBox(), af.centeredReal ? (K = -L.x * s - L.width * s / 2, isNaN(af.right) || (K = -K), S = -L.y * s - L.height * s / 2, isNaN(af.bottom) || (S = -S)) : K = S = 0, O.translate(K, S, s, !0), O.x = K, O.y = S);\n      }\n      O && (o.push(O), af.image = O, O.setAttr(\"stroke-opacity\", X), O.setAttr(\"stroke-width\", Q), O.setAttr(\"stroke\", N), O.setAttr(\"fill-opacity\", Y), \"bubble\" != V && O.setAttr(\"fill\", I), a.setCN(ad, O, \"map-image\"), void 0 != af.id && a.setCN(ad, O, \"map-image-\" + af.id));\n      I = af.labelColorReal;\n      !af.showAsSelected && ad.selectedObject != af || void 0 == Z || (O && O.setAttr(\"fill\", Z), I = af.selectedLabelColorReal);\n      O = null;\n      void 0 !== af.label && (O = a.text(ac, af.label, I, ad.fontFamily, af.labelFontSizeReal, af.labelAlign), a.setCN(ad, O, \"map-image-label\"), void 0 !== af.id && a.setCN(ad, O, \"map-image-label-\" + af.id), I = af.labelBackgroundAlpha, (Y = af.labelBackgroundColor) && 0 < I && (X = O.getBBox(), ac = a.rect(ac, X.width + 16, X.height + 10, Y, I), a.setCN(ad, ac, \"map-image-label-background\"), void 0 != af.id && a.setCN(ad, ac, \"map-image-label-background-\" + af.id), o.push(ac), af.labelBG = ac), af.imageLabel = O, o.push(O), a.setCN(ad, o, \"map-image-container\"), void 0 != af.id && a.setCN(ad, o, \"map-image-container-\" + af.id), this.labelsToReposition.push(af), af.arrays.push({\n        arr: this.labelsToReposition,\n        el: af\n      }));\n      ac = isNaN(af.latitude) || isNaN(af.longitude) ? !0 : !1;\n      af.lineId && (O = this.chart.getObjectById(af.lineId)) && 0 < O.longitudes.length && (ac = !1);\n      ac ? aa.push(o) : ab.push(o);\n      o.toBack();\n      o && (o.rotation = af.rotation, isNaN(af.rotation) || o.rotate(af.rotation), af.arrays.push({\n        arr: this.allSvgObjects,\n        el: o\n      }), this.allSvgObjects.push(o));\n      this.allObjects.push(af);\n      ad.makeObjectAccessible(af);\n      ab = af.tabIndex;\n      void 0 === ab && (ab = ad.imagesSettings.tabIndex);\n      void 0 !== ab && o.setAttr(\"tabindex\", ab);\n      af.arrays.push({\n        arr: this.allObjects,\n        el: af\n      });\n      isNaN(af.longitude) || isNaN(af.latitude) || !af.fixedSize || (af.objToResize = {\n        image: o,\n        mapImage: af,\n        scale: 1\n      }, this.objectsToResize.push(af.objToResize), af.arrays.push({\n        arr: this.objectsToResize,\n        el: af.objToResize\n      }));\n      this.updateSizeAndPosition(af);\n      af.mouseEnabled && ad.addObjectEventListeners(o, af);\n      af.hidden && o.hide();\n      a.removeFromArray(ad.updatableImages, af);\n      af.animateAlongLine && (ad.updatableImages.push(af), af.delayAnimateAlong());\n      return af;\n    },\n    updateSizeAndPosition: function (A) {\n      var z = this.chart,\n        y = A.displayObject,\n        x = z.getX(A.left),\n        w = z.getY(A.top),\n        v,\n        u = A.image.getBBox();\n      isNaN(A.right) || (x = z.getX(A.right, !0) - u.width * A.scale);\n      isNaN(A.bottom) || (w = z.getY(A.bottom, !0) - u.height * A.scale);\n      var s = A.longitude,\n        q = A.latitude,\n        o = A.positionOnLine,\n        u = A.imageLabel,\n        j = this.chart.zoomLevel(),\n        i,\n        B;\n      A.lineId && (A.line = this.chart.getObjectById(A.lineId));\n      if (A.line && A.line.getCoordinates) {\n        A.line.chart = z;\n        var d = A.line.getCoordinates(o, A.lineSegment);\n        d && (s = z.coordinateToLongitude(d.x), q = z.coordinateToLatitude(d.y), i = d.x, B = d.y, A.animateAngle && (v = a.radiansToDegrees(d.angle)));\n      }\n      isNaN(v) || y.rotate(v + A.extraAngle);\n      if (!isNaN(x) && !isNaN(w)) {\n        y.translate(x, w, NaN, !0);\n      } else {\n        if (!isNaN(q) && !isNaN(s)) {\n          if (w = z.coordinatesToXY(s, q), x = w.x, w = w.y, isNaN(i) || (x = i), isNaN(B) || (w = B), A.fixedSize) {\n            i = A.positionScale;\n            isNaN(i) ? i = 0 : (--i, i *= 1 - 2 * Math.abs(o - 0.5));\n            if (o = A.objectToResize) {\n              o.scale = 1 + i;\n            }\n            y.translate(x, w, 1 / j + i, !0);\n          } else {\n            y.translate(x, w, NaN, !0);\n          }\n        }\n      }\n      this.positionLabel(u, A, A.labelPositionReal);\n    },\n    positionLabel: function (t, s, r) {\n      if (t) {\n        var q = s.image,\n          p = 0,\n          o = 0,\n          n = 0,\n          j = 0;\n        q && (j = q.getBBox(), o = q.y + j.y, p = q.x + j.x, n = j.width, j = j.height, s.svgPath && (n *= s.scale, j *= s.scale));\n        var q = t.getBBox(),\n          i = q.width,\n          e = q.height;\n        \"right\" == r && (p += n + i / 2 + 5, o += j / 2 - 2);\n        \"left\" == r && (p += -i / 2 - 5, o += j / 2 - 2);\n        \"top\" == r && (o -= e / 2 + 3, p += n / 2);\n        \"bottom\" == r && (o += j + e / 2, p += n / 2);\n        \"middle\" == r && (p += n / 2, o += j / 2);\n        t.translate(p + s.labelShiftX, o + s.labelShiftY, NaN, !0);\n        t = s.labelFontSizeReal;\n        s.labelBG && s.labelBG.translate(p - q.width / 2 + s.labelShiftX - 9, o - t / 2 + s.labelShiftY - 4, NaN, !0);\n      }\n    },\n    createPredefinedImage: function (i, d, p, o, n, m) {\n      var l = this.chart.container,\n        j;\n      switch (o) {\n        case \"circle\":\n          j = a.circle(l, n / 2, i, 1, p, d, 1);\n          break;\n        case \"rectangle\":\n          j = a.polygon(l, [-n / 2, n / 2, n / 2, -n / 2], [m / 2, m / 2, -m / 2, -m / 2], i, 1, p, d, 1, 0, !0);\n          break;\n        case \"bubble\":\n          j = a.circle(l, n / 2, i, 1, p, d, 1, !0);\n          break;\n        case \"hexagon\":\n          n /= Math.sqrt(3), j = a.polygon(l, [0.866 * n, 0 * n, -0.866 * n, -0.866 * n, 0 * n, 0.866 * n], [0.5 * n, 1 * n, 0.5 * n, -0.5 * n, -1 * n, -0.5 * n], i, 1, p, d, 1);\n      }\n      return j;\n    },\n    reset: function () {\n      this.objectsToResize = [];\n      this.allSvgObjects = [];\n      this.allObjects = [];\n      this.allLabels = [];\n      this.labelsToReposition = [];\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.ImagesSettings = a.Class({\n    construct: function (b) {\n      this.cname = \"ImagesSettings\";\n      this.balloonText = \"[[title]]\";\n      this.alpha = 1;\n      this.borderAlpha = 0;\n      this.borderThickness = 1;\n      this.labelPosition = \"right\";\n      this.labelColor = \"#000000\";\n      this.labelFontSize = 11;\n      this.color = \"#000000\";\n      this.labelRollOverColor = \"#00CC00\";\n      this.centered = !0;\n      this.rollOverScale = this.selectedScale = 1;\n      this.descriptionWindowWidth = 250;\n      this.bringForwardOnHover = !0;\n      this.outlineColor = \"transparent\";\n      this.adjustAnimationSpeed = !1;\n      this.baseAnimationDistance = 500;\n      this.pauseDuration = 0;\n      this.easingFunction = a.easeInOutQuad;\n      this.animationDuration = 3;\n      this.positionScale = 1;\n      this.accessibleLabel = \"[[title]] [[description]]\";\n      a.applyTheme(this, b, this.cname);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.LinesProcessor = a.Class({\n    construct: function (b) {\n      this.chart = b;\n      this.reset();\n    },\n    process: function (f) {\n      var e = f.lines,\n        h;\n      for (h = 0; h < e.length; h++) {\n        var g = e[h];\n        this.createLine(g, h);\n        g.parentArray = e;\n      }\n      this.counter = h;\n      f.parentObject && f.remainVisible && this.process(f.parentObject);\n    },\n    createLine: function (aw, av) {\n      aw = a.processObject(aw, a.MapLine);\n      isNaN(av) && (this.counter++, av = this.counter);\n      aw.index = av;\n      aw.remove && aw.remove();\n      var au = this.chart,\n        at = au.linesSettings,\n        ar = this.objectsToResize,\n        aq = au.mapLinesContainer,\n        ap = au.stageLinesContainer,\n        ao = at.thickness,\n        an = at.dashLength,\n        am = at.arrow,\n        al = at.arrowSize,\n        ak = at.arrowColor,\n        ah = at.arrowAlpha,\n        ai = at.color,\n        aj = at.alpha,\n        ac = at.rollOverColor,\n        Z = at.selectedColor,\n        ag = at.rollOverAlpha,\n        ae = at.balloonText,\n        af = at.bringForwardOnHover,\n        aa = at.arc,\n        Y = at.rollOverBrightness,\n        ad = au.container;\n      aw.chart = au;\n      aw.baseSettings = at;\n      var ab = ad.set();\n      aw.displayObject = ab;\n      var V = aw.tabIndex;\n      void 0 === V && (V = at.tabIndex);\n      void 0 !== V && ab.setAttr(\"tabindex\", V);\n      this.allSvgObjects.push(ab);\n      aw.arrays.push({\n        arr: this.allSvgObjects,\n        el: ab\n      });\n      this.allObjects.push(aw);\n      aw.arrays.push({\n        arr: this.allObjects,\n        el: aw\n      });\n      aw.mouseEnabled && au.addObjectEventListeners(ab, aw);\n      if (aw.remainVisible || au.selectedObject == aw.parentObject) {\n        V = aw.thickness;\n        isNaN(V) && (V = ao);\n        ao = aw.dashLength;\n        isNaN(ao) && (ao = an);\n        an = aw.color;\n        void 0 == an && (an = ai);\n        ai = aw.alpha;\n        isNaN(ai) && (ai = aj);\n        aj = aw.rollOverAlpha;\n        isNaN(aj) && (aj = ag);\n        isNaN(aj) && (aj = ai);\n        ag = aw.rollOverColor;\n        void 0 == ag && (ag = ac);\n        ac = aw.selectedColor;\n        void 0 == ac && (ac = Z);\n        Z = aw.balloonText;\n        void 0 === Z && (Z = ae);\n        ae = aw.arc;\n        isNaN(ae) && (ae = aa);\n        aa = aw.arrow;\n        if (!aa || \"none\" == aa && \"none\" != am) {\n          aa = am;\n        }\n        am = aw.arrowColor;\n        void 0 == am && (am = ak);\n        void 0 == am && (am = an);\n        ak = aw.arrowAlpha;\n        isNaN(ak) && (ak = ah);\n        isNaN(ak) && (ak = ai);\n        ah = aw.arrowSize;\n        isNaN(ah) && (ah = al);\n        al = aw.rollOverBrightness;\n        void 0 == al && (al = Y);\n        aw.colorReal = an;\n        aw.arrowColor = am;\n        isNaN(at.selectedBrightness) || (ac = a.adjustLuminosity(aw.colorReal, at.selectedBrightness / 100));\n        aw.alphaReal = ai;\n        aw.rollOverColorReal = ag;\n        aw.rollOverAlphaReal = aj;\n        aw.balloonTextReal = Z;\n        aw.selectedColorReal = ac;\n        aw.thicknessReal = V;\n        aw.rollOverBrightnessReal = al;\n        aw.accessibleLabel || (aw.accessibleLabel = at.accessibleLabel);\n        void 0 === aw.shiftArrow && (aw.shiftArrow = at.shiftArrow);\n        void 0 == aw.bringForwardOnHover && (aw.bringForwardOnHover = af);\n        a.processDescriptionWindow(at, aw);\n        af = this.processCoordinates(aw.x, au.realWidth);\n        Y = this.processCoordinates(aw.y, au.realHeight);\n        al = aw.longitudes;\n        at = aw.latitudes;\n        aj = al.length;\n        if (0 < aj) {\n          for (af = [], Y = [], ag = 0; ag < aj; ag++) {\n            Z = au.coordinatesToXY(al[ag], at[ag]), af.push(Z.x), Y.push(Z.y);\n          }\n        }\n        if (0 < af.length) {\n          aw.segments = af.length;\n          a.dx = 0;\n          a.dy = 0;\n          var W,\n            T,\n            U,\n            aj = 10 * (1 - Math.abs(ae));\n          10 <= aj && (aj = NaN);\n          1 > aj && (aj = 1);\n          aw.arcRadius = [];\n          aw.distances = [];\n          al = au.mapContainer.scale;\n          if (isNaN(aj)) {\n            for (aj = 0; aj < af.length - 1; aj++) {\n              T = Math.sqrt(Math.pow(af[aj + 1] - af[aj], 2) + Math.pow(Y[aj + 1] - Y[aj], 2)), aw.distances[aj] = T;\n            }\n            aj = a.line(ad, af, Y, an, 1, V / al, ao, !1, !1, !0);\n            an = a.line(ad, af, Y, an, 0.001, 5 / al, ao, !1, !1, !0);\n            aj.setAttr(\"stroke-linecap\", \"round\");\n          } else {\n            ag = 1;\n            0 > ae && (ag = 0);\n            Z = {\n              fill: \"none\",\n              stroke: an,\n              \"stroke-opacity\": 1,\n              \"stroke-width\": V / al,\n              \"fill-opacity\": 0,\n              \"stroke-linecap\": \"round\"\n            };\n            void 0 !== ao && 0 < ao && (Z[\"stroke-dasharray\"] = ao);\n            for (var ao = \"\", X = 0; X < af.length - 1; X++) {\n              var Q = af[X],\n                R = af[X + 1],\n                s = Y[X],\n                i = Y[X + 1];\n              T = Math.sqrt(Math.pow(R - Q, 2) + Math.pow(i - s, 2));\n              U = T / 2 * aj;\n              W = 270 + 180 * Math.acos(T / 2 / U) / Math.PI;\n              isNaN(W) && (W = 270);\n              if (Q < R) {\n                var d = Q,\n                  Q = R,\n                  R = d,\n                  d = s,\n                  s = i,\n                  i = d;\n                W = -W;\n              }\n              0 < ae && (W = -W);\n              ao += \"M\" + Q + \",\" + s + \"A\" + U + \",\" + U + \",0,0,\" + ag + \",\" + R + \",\" + i;\n              aw.arcRadius[X] = U;\n              aw.distances[X] = T;\n            }\n            aj = ad.path(ao).attr(Z);\n            an = ad.path(ao).attr({\n              \"fill-opacity\": 0,\n              stroke: an,\n              \"stroke-width\": 5 / al,\n              \"stroke-opacity\": 0.001,\n              fill: \"none\"\n            });\n          }\n          a.setCN(au, aj, \"map-line\");\n          void 0 != aw.id && a.setCN(au, aj, \"map-line-\" + aw.id);\n          a.dx = 0.5;\n          a.dy = 0.5;\n          ab.push(aj);\n          ab.push(an);\n          aj.setAttr(\"opacity\", ai);\n          if (\"none\" != aa) {\n            var S, o, j;\n            if (\"end\" == aa || \"both\" == aa) {\n              ag = af[af.length - 1], X = Y[Y.length - 1], 1 < af.length ? (Z = af[af.length - 2], S = Y[Y.length - 2]) : (Z = ag, S = X), S = 180 * Math.atan((X - S) / (ag - Z)) / Math.PI, isNaN(W) || (S += W), o = ag, j = X, S = 0 > ag - Z ? S - 90 : S + 90;\n            }\n            ai = [-ah / 2 - 0.5, -0.5, ah / 2 - 0.5];\n            ao = [ah, -0.5, ah];\n            aw.shiftArrow && \"middle\" != aa && (ao = [0, 1.2 * -ah, 0]);\n            \"both\" == aa && (ah = a.polygon(ad, ai, ao, am, ak, 1, am, ak, void 0, !0), ab.push(ah), ah.translate(o, j, 1 / al, !0), isNaN(S) || ah.rotate(S), a.setCN(au, aj, \"map-line-arrow\"), void 0 != aw.id && a.setCN(au, aj, \"map-line-arrow-\" + aw.id), aw.fixedSize && ar.push(ah));\n            if (\"start\" == aa || \"both\" == aa) {\n              ah = af[0], j = Y[0], 1 < af.length ? (ag = af[1], o = Y[1]) : (ag = ah, o = j), S = 180 * Math.atan((j - o) / (ah - ag)) / Math.PI, isNaN(W) || (S -= W), o = ah, S = 0 > ah - ag ? S - 90 : S + 90;\n            }\n            \"middle\" == aa && (ag = af[af.length - 1], X = Y[Y.length - 1], 1 < af.length ? (Z = af[af.length - 2], S = Y[Y.length - 2]) : (Z = ag, S = X), o = Z + (ag - Z) / 2, j = S + (X - S) / 2, S = 180 * Math.atan((X - S) / (ag - Z)) / Math.PI, isNaN(W) || (W = T / 2, U -= Math.sqrt(U * U - W * W), 0 > ae && (U = -U), W = Math.sin(S / 180 * Math.PI), -1 == W && (W = 1), o -= W * U, j += Math.cos(S / 180 * Math.PI) * U), S = 0 > ag - Z ? S - 90 : S + 90);\n            ah = a.polygon(ad, ai, ao, am, ak, 1, am, ak, void 0, !0);\n            a.setCN(au, aj, \"map-line-arrow\");\n            void 0 != aw.id && a.setCN(au, aj, \"map-line-arrow-\" + aw.id);\n            ab.push(ah);\n            ah.translate(o, j, 1 / al, !0);\n            isNaN(S) || ah.rotate(S);\n            aw.fixedSize && (ar.push(ah), aw.arrays.push({\n              arr: ar,\n              el: ah\n            }));\n            aw.arrowSvg = ah;\n          }\n          aw.fixedSize && aj && (ar = {\n            line: aj,\n            thickness: V\n          }, this.linesToResize.push(ar), aw.arrays.push({\n            arr: this.linesToResize,\n            el: ar\n          }), ar = {\n            line: an,\n            thickness: 5\n          }, this.linesToResize.push(ar), aw.arrays.push({\n            arr: this.linesToResize,\n            el: ar\n          }));\n          aw.lineSvg = aj;\n          aw.showAsSelected && !isNaN(ac) && aj.setAttr(\"stroke\", ac);\n          0 < at.length ? aq.push(ab) : ap.push(ab);\n          aw.hidden && ab.hide();\n          au.makeObjectAccessible(aw);\n        }\n      }\n    },\n    processCoordinates: function (h, e) {\n      var l = [],\n        k;\n      for (k = 0; k < h.length; k++) {\n        var j = h[k],\n          i = Number(j);\n        isNaN(i) && (i = Number(j.replace(\"%\", \"\")) * e / 100);\n        isNaN(i) || l.push(i);\n      }\n      return l;\n    },\n    reset: function () {\n      this.objectsToResize = [];\n      this.allSvgObjects = [];\n      this.allObjects = [];\n      this.linesToResize = [];\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.LinesSettings = a.Class({\n    construct: function (b) {\n      this.cname = \"LinesSettings\";\n      this.balloonText = \"[[title]]\";\n      this.thickness = 1;\n      this.dashLength = 0;\n      this.arrowSize = 10;\n      this.arrowAlpha = 1;\n      this.arrow = \"none\";\n      this.color = \"#990000\";\n      this.descriptionWindowWidth = 250;\n      this.bringForwardOnHover = !0;\n      a.applyTheme(this, b, this.cname);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.MapObject = a.Class({\n    construct: function (b) {\n      this.fixedSize = this.mouseEnabled = !0;\n      this.images = [];\n      this.lines = [];\n      this.areas = [];\n      this.remainVisible = !0;\n      this.passZoomValuesToTarget = !1;\n      this.objectType = this.cname;\n      a.applyTheme(this, b, \"MapObject\");\n      this.arrays = [];\n    },\n    deleteObject: function () {\n      this.remove();\n      this.parentArray && a.removeFromArray(this.parentArray, this);\n      if (this.arrays) {\n        for (var b = 0; b < this.arrays.length; b++) {\n          a.removeFromArray(this.arrays[b].arr, this.arrays[b].el);\n        }\n      }\n      this.arrays = [];\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.MapArea = a.Class({\n    inherits: a.MapObject,\n    construct: function (b) {\n      this.cname = \"MapArea\";\n      a.MapArea.base.construct.call(this, b);\n      a.applyTheme(this, b, this.cname);\n    },\n    validate: function () {\n      this.chart.areasProcessor.createArea(this);\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.MapLine = a.Class({\n    inherits: a.MapObject,\n    construct: function (b) {\n      this.cname = \"MapLine\";\n      this.longitudes = [];\n      this.latitudes = [];\n      this.x = [];\n      this.y = [];\n      this.segments = 0;\n      this.arrow = \"none\";\n      a.MapLine.base.construct.call(this, b);\n      a.applyTheme(this, b, this.cname);\n    },\n    validate: function () {\n      this.chart.linesProcessor.createLine(this);\n    },\n    remove: function () {\n      var b = this.displayObject;\n      b && b.remove();\n    },\n    getCoordinates: function (x, w) {\n      isNaN(w) && (w = 0);\n      isNaN(this.arc) || this.isValid || (this.isValid = !0, this.validate());\n      if (!isNaN(x)) {\n        var v, u, t, s, r, q;\n        if (1 < this.longitudes.length) {\n          u = this.chart.coordinatesToXY(this.longitudes[w], this.latitudes[w]);\n          var o = this.chart.coordinatesToXY(this.longitudes[w + 1], this.latitudes[w + 1]);\n          v = u.x;\n          t = o.x;\n          u = u.y;\n          s = o.y;\n        } else {\n          1 < this.x.length && (v = this.x[w], t = this.x[w + 1], u = this.y[w], s = this.y[w + 1]);\n        }\n        o = Math.sqrt(Math.pow(t - v, 2) + Math.pow(s - u, 2));\n        v < t && !isNaN(this.arc) && 0 !== this.arc && (x = 1 - x);\n        r = v + (t - v) * x;\n        q = u + (s - u) * x;\n        var j = Math.atan2(s - u, t - v);\n        if (!isNaN(this.arc) && 0 !== this.arc && this.arcRadius) {\n          var i = 0;\n          v < t && (i = v, v = t, t = i, i = u, u = s, s = i, i = Math.PI);\n          q = this.arcRadius[w];\n          0 > this.arc && (o = -o);\n          r = v + (t - v) / 2 + Math.sqrt(q * q - o / 2 * (o / 2)) * (u - s) / o;\n          var d = u + (s - u) / 2 + Math.sqrt(q * q - o / 2 * (o / 2)) * (t - v) / o;\n          v = 180 * Math.atan2(u - d, v - r) / Math.PI;\n          t = 180 * Math.atan2(s - d, t - r) / Math.PI;\n          180 < t - v && (t -= 360);\n          j = a.degreesToRadians(v + (t - v) * x);\n          r += q * Math.cos(j);\n          q = d + q * Math.sin(j);\n          j = 0 < this.arc ? j + Math.PI / 2 : j - Math.PI / 2;\n          j += i;\n        }\n        this.distance = o;\n        return {\n          x: r,\n          y: q,\n          angle: j\n        };\n      }\n    },\n    fixToStage: function () {\n      if (0 < this.latitudes.length) {\n        this.y = [];\n        for (var d = 0; d < this.latitudes.length; d++) {\n          var c = this.chart.coordinatesToStageXY(this.longitudes[d], this.latitudes[d]);\n          this.y.push(c.y);\n          this.x.push(c.x);\n        }\n        this.latitudes = [];\n        this.longitudes = [];\n      }\n      this.validate();\n    },\n    fixToMap: function () {\n      if (0 < this.y.length) {\n        this.latitudes = [];\n        for (var d = 0; d < this.y.length; d++) {\n          var c = this.chart.stageXYToCoordinates(this.x[d], this.y[d]);\n          this.latitudes.push(c.latitude);\n          this.longitudes.push(c.longitude);\n        }\n        this.y = [];\n        this.x = [];\n      }\n      this.validate();\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.MapImage = a.Class({\n    inherits: a.MapObject,\n    construct: function (b) {\n      this.cname = \"MapImage\";\n      this.scale = 1;\n      this.widthAndHeightUnits = \"pixels\";\n      this.labelShiftY = this.labelShiftX = 0;\n      this.positionOnLine = 0.5;\n      this.direction = 1;\n      this.lineSegment = this.extraAngle = 0;\n      this.animateAngle = !0;\n      this.createEvents(\"animationStart\", \"animationEnd\");\n      a.MapImage.base.construct.call(this, b);\n      a.applyTheme(this, b, this.cname);\n      this.delayCounter = 0;\n    },\n    validate: function () {\n      this.chart.imagesProcessor.createImage(this);\n    },\n    updatePosition: function () {\n      this.chart.imagesProcessor.updateSizeAndPosition(this);\n    },\n    remove: function () {\n      var b = this.displayObject;\n      b && b.remove();\n      (b = this.imageLabel) && b.remove();\n    },\n    animateTo: function (f, e, h, g) {\n      isNaN(h) || (this.animationDuration = h);\n      g && (this.easingFunction = g);\n      this.finalX = f;\n      this.finalY = e;\n      isNaN(this.longitude) || (this.initialX = this.longitude);\n      isNaN(this.left) || (this.initialX = this.left);\n      isNaN(this.right) || (this.initialX = this.right);\n      isNaN(this.latitude) || (this.initialY = this.latitude);\n      isNaN(this.top) || (this.initialY = this.top);\n      isNaN(this.bottom) || (this.initialY = this.bottom);\n      this.animatingAlong = !1;\n      this.animate();\n    },\n    animateAlong: function (e, d, f) {\n      1 == this.positionOnLine && this.flipDirection && (this.direction = -1, this.extraAngle = 180);\n      isNaN(d) || (this.animationDuration = d);\n      f && (this.easingFunction = f);\n      e && (this.line = this.chart.getObjectById(e));\n      this.animateAlongLine = this.line;\n      this.animatingAlong = !0;\n      this.animate();\n    },\n    animate: function () {\n      var d = this.chart.imagesSettings,\n        c = this.animationDuration;\n      isNaN(c) && (c = d.animationDuration);\n      this.totalFrames = c * a.updateRate;\n      c = 1;\n      this.line && d.adjustAnimationSpeed && (this.line.distances && (c = this.line.distances[this.lineSegment] * this.chart.zoomLevel(), c = Math.abs(c / d.baseAnimationDistance)), this.totalFrames = Math.round(c * this.totalFrames));\n      this.frame = 0;\n      this.fire({\n        type: \"animationStart\",\n        chart: this.chart,\n        image: this,\n        lineSegment: this.lineSegment,\n        direction: this.direction\n      });\n    },\n    update: function () {\n      var e = this.totalFrames;\n      this.frame++;\n      this.delayCounter--;\n      0 === this.delayCounter && this.animateAlong();\n      if (!(0 < this.delayCounter)) {\n        if (this.frame <= e) {\n          this.updatePosition();\n          var d = this.chart.imagesSettings,\n            f = this.easingFunction;\n          f || (f = d.easingFunction);\n          e = f(0, this.frame, 0, 1, e);\n          -1 == this.direction && (e = 1 - e);\n          this.animatingAlong ? this.positionOnLine = e : (d = this.initialX + (this.finalX - this.initialX) * e, isNaN(this.longitude) || (this.longitude = d), isNaN(this.left) || (this.left = d), isNaN(this.right) || (this.right = d), e = this.initialY + (this.finalY - this.initialY) * e, isNaN(this.latitude) || (this.latitude = e), isNaN(this.top) || (this.top = e), isNaN(this.bottom) || (this.bottom = e));\n        } else {\n          this.frame == e + 1 && (this.fire({\n            type: \"animationEnd\",\n            chart: this.chart,\n            image: this,\n            lineSegment: this.lineSegment,\n            direction: this.direction\n          }), this.line && this.animatingAlong && (1 == this.direction ? this.lineSegment < this.line.segments - 2 ? (this.lineSegment++, this.delayAnimateAlong(), this.positionOnLine = 0) : this.flipDirection ? (this.direction = -1, this.extraAngle = 180, this.delayAnimateAlong()) : this.loop && (this.delayAnimateAlong(), this.lineSegment = 0) : 0 < this.lineSegment ? (this.lineSegment--, this.delayAnimateAlong(), this.positionOnLine = 0) : this.loop && this.flipDirection ? (this.direction = 1, this.extraAngle = 0, this.delayAnimateAlong()) : this.loop && this.delayAnimateAlong()));\n        }\n      }\n    },\n    delayAnimateAlong: function () {\n      this.animateAlongLine && (this.delayCounter = this.chart.imagesSettings.pauseDuration * a.updateRate);\n    },\n    fixToStage: function () {\n      if (!isNaN(this.longitude)) {\n        var b = this.chart.coordinatesToStageXY(this.longitude, this.latitude);\n        this.left = b.x;\n        this.top = b.y;\n        this.latitude = this.longitude = void 0;\n      }\n      this.validate();\n    },\n    fixToMap: function () {\n      if (!isNaN(this.left)) {\n        var b = this.chart.stageXYToCoordinates(this.left, this.top);\n        this.longitude = b.longitude;\n        this.latitude = b.latitude;\n        this.top = this.left = void 0;\n      }\n      this.validate();\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.degreesToRadians = function (b) {\n    return b / 180 * Math.PI;\n  };\n  a.radiansToDegrees = function (b) {\n    return b / Math.PI * 180;\n  };\n  a.getColorFade = function (i, d, n) {\n    var m = a.hex2RGB(d);\n    d = m[0];\n    var l = m[1],\n      m = m[2],\n      k = a.hex2RGB(i);\n    i = k[0];\n    var j = k[1],\n      k = k[2];\n    i += Math.round((d - i) * n);\n    j += Math.round((l - j) * n);\n    k += Math.round((m - k) * n);\n    return \"rgb(\" + i + \",\" + j + \",\" + k + \")\";\n  };\n  a.hex2RGB = function (b) {\n    return [parseInt(b.substring(1, 3), 16), parseInt(b.substring(3, 5), 16), parseInt(b.substring(5, 7), 16)];\n  };\n  a.processDescriptionWindow = function (d, c) {\n    isNaN(c.descriptionWindowX) && (c.descriptionWindowX = d.descriptionWindowX);\n    isNaN(c.descriptionWindowY) && (c.descriptionWindowY = d.descriptionWindowY);\n    isNaN(c.descriptionWindowLeft) && (c.descriptionWindowLeft = d.descriptionWindowLeft);\n    isNaN(c.descriptionWindowRight) && (c.descriptionWindowRight = d.descriptionWindowRight);\n    isNaN(c.descriptionWindowTop) && (c.descriptionWindowTop = d.descriptionWindowTop);\n    isNaN(c.descriptionWindowBottom) && (c.descriptionWindowBottom = d.descriptionWindowBottom);\n    isNaN(c.descriptionWindowWidth) && (c.descriptionWindowWidth = d.descriptionWindowWidth);\n    isNaN(c.descriptionWindowHeight) && (c.descriptionWindowHeight = d.descriptionWindowHeight);\n  };\n  a.normalizePath = function (y) {\n    for (var x = \"\", w = a.parsePath(y.getAttribute(\"d\")), v, u, s = Infinity, r = -Infinity, q = Infinity, o = -Infinity, j = 0; j < w.length; j++) {\n      var i = w[j],\n        d = i.letter,\n        z = i.x,\n        i = i.y;\n      \"h\" == d && (d = \"L\", z += v, i = u);\n      \"H\" == d && (d = \"L\", i = u);\n      \"v\" == d && (d = \"L\", z = v, i += u);\n      \"V\" == d && (d = \"L\", z = v);\n      if (\"m\" === d || \"l\" === d) {\n        d = d.toUpperCase(), z += v, i += u;\n      }\n      z = a.roundTo(z, 3);\n      i = a.roundTo(i, 3);\n      v = z;\n      u = i;\n      z > r && (r = z);\n      z < s && (s = z);\n      i > o && (o = i);\n      i < q && (q = i);\n      x = \"z\" == d.toLowerCase() ? x + \"Z \" : x + (d + \" \" + z + \" \" + i + \" \");\n    }\n    y.setAttribute(\"d\", x);\n    return {\n      minX: s,\n      maxX: r,\n      minY: q,\n      maxY: o\n    };\n  };\n  a.mercatorLatitudeToRadians = function (b) {\n    return Math.log(Math.tan(Math.PI / 4 + a.degreesToRadians(b) / 2));\n  };\n  a.parsePath = function (g) {\n    g = g.match(/([MmLlHhVvZz]{1}[0-9.,\\-\\s]*)/g);\n    for (var e = [], j = 0; j < g.length; j++) {\n      var i = g[j].match(/([MmLlHhVvZz]{1})|([0-9.\\-]+)/g),\n        h = {\n          letter: i[0]\n        };\n      switch (i[0]) {\n        case \"Z\":\n        case \"Z\":\n        case \"z\":\n          break;\n        case \"V\":\n        case \"v\":\n          h.y = Number(i[1]);\n          break;\n        case \"H\":\n        case \"h\":\n          h.x = Number(i[1]);\n          break;\n        default:\n          h.x = Number(i[1]), h.y = Number(i[2]);\n      }\n      e.push(h);\n    }\n    return e;\n  };\n  a.acos = function (b) {\n    return 1 < b ? 0 : -1 > b ? Math.PI : Math.acos(b);\n  };\n  a.asin = function (b) {\n    return 1 < b ? Math.PI / 2 : -1 > b ? -Math.PI / 2 : Math.asin(b);\n  };\n  a.sinci = function (b) {\n    return b ? b / Math.sin(b) : 1;\n  };\n  a.asqrt = function (b) {\n    return 0 < b ? Math.sqrt(b) : 0;\n  };\n  a.winkel3 = function (e, d) {\n    var f = a.aitoff(e, d);\n    return [(f[0] + e / Math.PI * 2) / 2, (f[1] + d) / 2];\n  };\n  a.winkel3.invert = function (P, O) {\n    var N = P,\n      M = O,\n      L = 25,\n      K = Math.PI / 2;\n    do {\n      var J = Math.cos(M),\n        I = Math.sin(M),\n        H = Math.sin(2 * M),\n        G = I * I,\n        F = J * J,\n        E = Math.sin(N),\n        s = Math.cos(N / 2),\n        x = Math.sin(N / 2),\n        C = x * x,\n        d = 1 - F * s * s,\n        z = d ? a.acos(J * s) * Math.sqrt(o = 1 / d) : o = 0,\n        o,\n        d = 0.5 * (2 * z * J * x + N / K) - P,\n        i = 0.5 * (z * I + M) - O,\n        j = 0.5 * o * (F * C + z * J * s * G) + 0.5 / K,\n        D = o * (E * H / 4 - z * I * x),\n        I = 0.125 * o * (H * x - z * I * F * E),\n        G = 0.5 * o * (G * s + z * C * J) + 0.5,\n        J = D * I - G * j,\n        D = (i * D - d * G) / J,\n        d = (d * I - i * j) / J,\n        N = N - D,\n        M = M - d;\n    } while ((0.000001 < Math.abs(D) || 0.000001 < Math.abs(d)) && 0 < --L);\n    return [N, M];\n  };\n  a.aitoff = function (f, d) {\n    var h = Math.cos(d),\n      g = a.sinci(a.acos(h * Math.cos(f /= 2)));\n    return [2 * h * Math.sin(f) * g, Math.sin(d) * g];\n  };\n  a.orthographic = function (d, c) {\n    return [Math.cos(c) * Math.sin(d), Math.sin(c)];\n  };\n  a.equirectangular = function (d, c) {\n    return [d, c];\n  };\n  a.equirectangular.invert = function (d, c) {\n    return [d, c];\n  };\n  a.eckert5 = function (e, d) {\n    var f = Math.PI;\n    return [e * (1 + Math.cos(d)) / Math.sqrt(2 + f), 2 * d / Math.sqrt(2 + f)];\n  };\n  a.eckert5.invert = function (f, e) {\n    var h = Math.sqrt(2 + Math.PI),\n      g = e * h / 2;\n    return [h * f / (1 + Math.cos(g)), g];\n  };\n  a.eckert6 = function (h, e) {\n    for (var l = Math.PI, k = (1 + l / 2) * Math.sin(e), j = 0, i = Infinity; 10 > j && 0.00001 < Math.abs(i); j++) {\n      e -= i = (e + Math.sin(e) - k) / (1 + Math.cos(e));\n    }\n    k = Math.sqrt(2 + l);\n    return [h * (1 + Math.cos(e)) / k, 2 * e / k];\n  };\n  a.eckert6.invert = function (f, d) {\n    var h = 1 + Math.PI / 2,\n      g = Math.sqrt(h / 2);\n    return [2 * f * g / (1 + Math.cos(d *= g)), a.asin((d + Math.sin(d)) / h)];\n  };\n  a.mercator = function (d, c) {\n    c >= Math.PI / 2 - 0.02 && (c = Math.PI / 2 - 0.02);\n    c <= -Math.PI / 2 + 0.02 && (c = -Math.PI / 2 + 0.02);\n    return [d, Math.log(Math.tan(Math.PI / 4 + c / 2))];\n  };\n  a.mercator.invert = function (d, c) {\n    return [d, 2 * Math.atan(Math.exp(c)) - Math.PI / 2];\n  };\n  a.miller = function (d, c) {\n    return [d, 1.25 * Math.log(Math.tan(Math.PI / 4 + 0.4 * c))];\n  };\n  a.miller.invert = function (d, c) {\n    return [d, 2.5 * Math.atan(Math.exp(0.8 * c)) - 0.625 * Math.PI];\n  };\n  a.eckert3 = function (f, e) {\n    var h = Math.PI,\n      g = Math.sqrt(h * (4 + h));\n    return [2 / g * f * (1 + Math.sqrt(1 - 4 * e * e / (h * h))), 4 / g * e];\n  };\n  a.eckert3.invert = function (f, d) {\n    var h = Math.PI,\n      g = Math.sqrt(h * (4 + h)) / 2;\n    return [f * g / (1 + a.asqrt(1 - d * d * (4 + h) / (4 * h))), d * g / 2];\n  };\n})();\n(function () {\n  var a = window.AmCharts;\n  a.MapData = a.Class({\n    inherits: a.MapObject,\n    construct: function () {\n      this.cname = \"MapData\";\n      a.MapData.base.construct.call(this);\n      this.projection = \"mercator\";\n      this.topLatitude = 90;\n      this.bottomLatitude = -90;\n      this.leftLongitude = -180;\n      this.rightLongitude = 180;\n      this.zoomLevel = 1;\n      this.getAreasFromMap = !1;\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.DescriptionWindow = a.Class({\n    construct: function () {},\n    show: function (r, q, p, o) {\n      var n = this;\n      n.chart = r;\n      var m = document.createElement(\"div\");\n      m.style.position = \"absolute\";\n      var j = r.classNamePrefix + \"-description-\";\n      m.className = \"ammapDescriptionWindow \" + j + \"div\";\n      n.div = m;\n      q.appendChild(m);\n      var i = \".gif\";\n      r.svgIcons && (i = \".svg\");\n      var e = document.createElement(\"img\");\n      e.className = \"ammapDescriptionWindowCloseButton \" + j + \"close-img\";\n      e.src = r.pathToImages + \"xIcon\" + i;\n      e.style.cssFloat = \"right\";\n      e.style.cursor = \"pointer\";\n      e.onclick = function () {\n        n.close();\n      };\n      e.onmouseover = function () {\n        e.src = r.pathToImages + \"xIconH\" + i;\n      };\n      e.onmouseout = function () {\n        e.src = r.pathToImages + \"xIcon\" + i;\n      };\n      m.appendChild(e);\n      q = document.createElement(\"div\");\n      q.className = \"ammapDescriptionTitle \" + j + \"title-div\";\n      q.onmousedown = function () {\n        n.div.style.zIndex = 1000;\n      };\n      m.appendChild(q);\n      q.innerHTML = o;\n      o = q.offsetHeight;\n      q = document.createElement(\"div\");\n      q.className = \"ammapDescriptionText \" + j + \"text-div\";\n      q.style.maxHeight = n.maxHeight - o - 20 + \"px\";\n      m.appendChild(q);\n      q.innerHTML = p;\n    },\n    close: function () {\n      try {\n        this.div.parentNode.removeChild(this.div), this.chart.fireClosed();\n      } catch (b) {}\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.ValueLegend = a.Class({\n    construct: function (b) {\n      this.cname = \"ValueLegend\";\n      this.enabled = !0;\n      this.showAsGradient = !1;\n      this.minValue = 0;\n      this.height = 12;\n      this.width = 200;\n      this.bottom = this.left = 10;\n      this.borderColor = \"#FFFFFF\";\n      this.borderAlpha = this.borderThickness = 1;\n      this.color = \"#000000\";\n      this.fontSize = 11;\n      a.applyTheme(this, b, this.cname);\n    },\n    init: function (x, w) {\n      if (this.enabled) {\n        var v = x.areasSettings.color,\n          u = x.areasSettings.colorSolid,\n          t = x.colorSteps;\n        a.remove(this.set);\n        var s = w.set();\n        this.set = s;\n        a.setCN(x, s, \"value-legend\");\n        var r = 0,\n          q = this.minValue,\n          o = this.fontSize,\n          j = x.fontFamily,\n          i = this.color,\n          d = {\n            precision: x.precision,\n            decimalSeparator: x.decimalSeparator,\n            thousandsSeparator: x.thousandsSeparator\n          };\n        void 0 == q && (q = a.formatNumber(x.minValueReal, d));\n        void 0 !== q && (r = a.text(w, q, i, j, o, \"left\"), r.translate(0, o / 2 - 1), a.setCN(x, r, \"value-legend-min-label\"), s.push(r), r = r.getBBox().height);\n        q = this.maxValue;\n        void 0 === q && (q = a.formatNumber(x.maxValueReal, d));\n        void 0 !== q && (r = a.text(w, q, i, j, o, \"right\"), r.translate(this.width, o / 2 - 1), a.setCN(x, r, \"value-legend-max-label\"), s.push(r), r = r.getBBox().height);\n        if (this.showAsGradient) {\n          v = a.rect(w, this.width, this.height, [v, u], 1, this.borderThickness, this.borderColor, 1, 0, 0), a.setCN(x, v, \"value-legend-gradient\"), v.translate(0, r), s.push(v);\n        } else {\n          for (o = this.width / t, j = 0; j < t; j++) {\n            i = a.getColorFade(v, u, 1 * j / (t - 1)), i = a.rect(w, o, this.height, i, 1, this.borderThickness, this.borderColor, 1), a.setCN(x, i, \"value-legend-color\"), a.setCN(x, i, \"value-legend-color-\" + j), i.translate(o * j, r), s.push(i);\n          }\n        }\n        u = v = 0;\n        t = s.getBBox();\n        r = x.getY(this.bottom, !0);\n        o = x.getY(this.top);\n        j = x.getX(this.right, !0);\n        i = x.getX(this.left);\n        isNaN(o) || (v = o);\n        isNaN(r) || (v = r - t.height);\n        isNaN(i) || (u = i);\n        isNaN(j) || (u = j - t.width);\n        s.translate(u, v);\n      } else {\n        a.remove(this.set);\n      }\n    }\n  });\n})();\n(function () {\n  var a = window.AmCharts;\n  a.ObjectList = a.Class({\n    construct: function (b) {\n      this.divId = b;\n    },\n    init: function (d) {\n      this.chart = d;\n      var c = this.divId;\n      this.container && (c = this.container);\n      this.div = \"object\" != typeof c ? document.getElementById(c) : c;\n      c = document.createElement(\"div\");\n      c.className = \"ammapObjectList \" + d.classNamePrefix + \"-object-list-div\";\n      this.div.appendChild(c);\n      this.addObjects(d.dataProvider, c);\n    },\n    addObjects: function (h, e) {\n      var l = this.chart,\n        k = document.createElement(\"ul\");\n      k.className = l.classNamePrefix + \"-object-list-ul\";\n      var j;\n      if (h.areas) {\n        for (j = 0; j < h.areas.length; j++) {\n          var i = h.areas[j];\n          void 0 === i.showInList && (i.showInList = l.showAreasInList);\n          this.addObject(i, k);\n        }\n      }\n      if (h.images) {\n        for (j = 0; j < h.images.length; j++) {\n          i = h.images[j], void 0 === i.showInList && (i.showInList = l.showImagesInList), this.addObject(i, k);\n        }\n      }\n      if (h.lines) {\n        for (j = 0; j < h.lines.length; j++) {\n          i = h.lines[j], void 0 === i.showInList && (i.showInList = l.showLinesInList), this.addObject(i, k);\n        }\n      }\n      0 < k.childNodes.length && e.appendChild(k);\n    },\n    addObject: function (i, e) {\n      var n = this;\n      if (i.showInList && void 0 !== i.title) {\n        var m = n.chart,\n          l = document.createElement(\"li\");\n        l.className = m.classNamePrefix + \"-object-list-li\";\n        var k = i.titleTr;\n        k || (k = i.title);\n        var k = document.createTextNode(k),\n          j = document.createElement(\"a\");\n        j.className = m.classNamePrefix + \"-object-list-a\";\n        j.appendChild(k);\n        l.appendChild(j);\n        e.appendChild(l);\n        this.addObjects(i, l);\n        j.onmouseover = function () {\n          n.chart.rollOverMapObject(i, !1);\n        };\n        j.onmouseout = function () {\n          n.chart.rollOutMapObject(i);\n        };\n        j.onclick = function () {\n          n.chart.clickMapObject(i);\n        };\n      }\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}